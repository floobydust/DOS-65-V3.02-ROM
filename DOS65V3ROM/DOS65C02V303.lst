  Thu Apr 29 2021  3:45                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                                        pw      132
     2                                        pl      66
     3                                        globals on
     4                                        case    off
     5                                        inclist on
     6                        ;W65C02_DOS.asm
     7                        ;version 3.03-ROM
     8                        ;This is the core of the ROM resident version of DOS/65
     9                        ;and is derived from SYSGEN V3.02.
    10                        ; The target platform is the C02 Pocket SBC - KM
    11                        ;
    12                        ;Changes from V2.1 to V3.0
    13                        ;include:
    14                        ;               added USER command and use
    15                        ;               added ability to input .KIM & .HEX
    16                        ;               added batch file functions
    17                        ;               made directory entries per line a parameter
    18                        ;               implemented use of IOSTAT to save & pass
    19                        ;               drive number and user code
    20                        ;               made use of SWITCH always the case
    21                        ;
    22                        ;released:      24 February 2015 (3.00S)
    23                        ;last revised:
    24                        ;               2 March 2015 (3.01S)
    25                        ;                       added check of number actual sectors in image write
    26                        ;                       made trkcnt separate variable
    27                        ;               21 August 2015 (3.02)
    28                        ;                       corrected file name parsing error
    29                        ;                       set dir entries per line to 2
    30                        ;               2 July 2017 (3.02W ROM)
    31                        ;                       conversion to ROM
    32                        ;                       eliminated pem page 0 swap
    33                        ;                       corrected sysdef location
    34                        ;                       changed sim references to simram
    35                        ;                       set 4 wide directory in ccm
    36                        ;               14 March 2021 - KM
    37                        ;                       several changes to structure - saves RAM usage
    38                        ;                       Page Zero start at $80 (Monitor/BIOS uses $A0 - $FF)
    39                        ;                       condensed defined area - removed all SD related code
    40                        ;                       removed DEFS for allocation maps, RAM initialized at coldstart
    41                        ;                       moved SIM to a half-page boundary (frees up another chunk of RAM)
    42                        ;                       added allocation maps for three additional drives
    43                        ;                       coldstart requires 2.0 pages of RAM initialized
    44                        ;                       warmstart requires 1.5 pages of RAM initialized
    45                        ;                       fixed a problem with invalid drive looping on error output
    46                        ;                       much reduced ROM image size ~3KB smaller
    47                        ;
    48                        ;               11 April 2021 - KM (3.03)
    49                        ;This new version contains an updated CCM section
    50                        ; uses CMOS instructions and addressing modes
    51                        ; is smaller in size, at 2046 bytes
    52                        ; several performance improvements due to CMOS updates
    53                        ; no loss of function, but a few minor performance hits
    54                        ;
    55                        ;This new version contains an updated PEM section
    56                        ; uses CMOS instructions and addressing modes
    57                        ; is smaller in size, at 2776 bytes
  Thu Apr 29 2021  3:45                                                                                                    Page 2


    58                        ; several performance improvements due to CMOS updates
    59                        ;
    60                        ;This program contains the complete DOS/65 operating system, including:
    61                        ; CCM, PEM and SIM. All are assembled and linked to a single Intel HEX file.
    62                        ; This can be loaded into ROM, but still require that the C02BIOS and C02Monitor
    63                        ; are also loaded into the ROM as well. Note that the SIM section calls several
    64                        ; functions from the BIOS/Monitor code via the integrated JMP tables.
    65                        ; DOS/65 is booted from ROM via the C02Monitor using "Ctrl-B".
    66                        ;
    67                        ; ROM size is 6.5KB, which includes 512 bytes allocated for CCM/PEM/SIM RAM.
    68                        ; This is copied from ROM to RAM during a Cold start for memory usage which is
    69                        ; dynamic when DOS/65 is running.
    70                        ;
    71                        ;base addresses and definitions
    72             00000080   pzstrt          equ     $80             ;start of page zero system RAM
    73             00000100   btejmp          equ     $100            ;warm boot jump
    74             00000103   pemjmp          equ     $103            ;jump to PEM
    75             00000106   iostat          equ     $106            ;I/O status
    76             00000107   dflfcb          equ     $107            ;default FCB
    77             00000128   dflbuf          equ     $128            ;default buffer
    78             00000800   tea             equ     $800            ;tea start - KM
    79                        ;C02 Pocket SBC memory parameters
    80             00007000   ramstrt         equ     $7000           ;start of high ram used by system
    81             0000C000   romstrt         equ     $C000           ;default ROM location - KM
    82             0000D800   romorg          equ     $D800           ;changed for condensed RAM image - KM
    83             00000600   hstbuf          equ     $0600           ;moved host buffer to low RAM - KM
    84                        ;
    85                        ;fixed parameters
    86             0000000A   lf              equ     $0A             ;linefeeed
    87             0000000D   cr              equ     $0D             ;return
    88             0000001A   eof             equ     $1A             ;end of file
    89             00000000   null            equ     0               ;null
    90             00000003   ctlc            equ     3               ;abort
    91             00000005   ctle            equ     5               ;physical cr lf
    92             00000009   ctli            equ     9               ;tab character
    93             00000010   ctlp            equ     $10             ;toggle printer
    94             00000012   ctlr            equ     $12             ;repeat line
    95             00000013   ctls            equ     $13             ;freeze
    96             00000018   ctlx            equ     $18             ;cancel
    97             0000003B   semico          equ     $3B             ;semicolon
    98             0000007F   delete          equ     $7F             ;delete character
    99             00000025   numcmd          equ     37              ;number of PEM commands
   100                        
   101                        ;page zero use
   102                                        page0
   103                        ;ccm
   104                        ;pem
   105             00000080   addinp          equ     pzstrt          ;initialized to a,y
   106             00000082   bufadd          equ     addinp+2        ;buffer address
   107             00000084   alcpnt          equ     bufadd+2        ;allocation map pointer
   108             00000086   chkpnt          equ     alcpnt+2        ;checksum map pointer
   109             00000088   msgptr          equ     chkpnt+2        ;message pointer
   110             00000088   movptr          equ     msgptr          ;and move pointer
   111             0000008A   dcbloc          equ     msgptr+2        ;pointer to dcb
   112                        ;sim
   113             0000008C   sim_dmaadr      equ     dcbloc+2        ;record buffer
   114             0000008E   sim_dcbpnt      equ     sim_dmaadr+2    ;pointer into selected dcb
   115             00000090   sim_movepnt     equ     sim_dcbpnt+2    ;read or write move host pointer
   116                        ;mon
   117             00000092   wblk_ptr        equ     sim_movepnt+2   ;pointer in write_blk
   118             00000094   rblk_ptr        equ     wblk_ptr+2      ;pointer in read_blk
   119             00000096   cmd_save        equ     rblk_ptr+2      ;save cmd in send_cmd
   120             00000098   stdio_d1        equ     cmd_save+2      ;pointer for txtout
  Thu Apr 29 2021  3:45                                                                                                    Page 3


   121                        
   122                                        ends
   123                        
   124                        dosram          section indirect ramstrt
   125                        
   126                        ;RAM code and variables
   127                        ;
   128                        ;CCM section
   129                        ;
   130 00:7000: 4C 00 C0     ccmram          jmp     ccm
   131                        ;input buffer
   132                        cnsbuf
   133 00:7003: 7F           cnsmax          byte    127
   134 00:7004: 00           cnslng          byte    0
   135 00:7005:              cnstxt          defs    128             ;set to 128 for safety
   136                        ;fcb one
   137 00:7085:              fcbone          defs    33
   138                        ;SUBMIT flag = 0 if no submit operation in process
   139 00:70A6: 00           subflg          byte    0               ;=255 if sumbit
   140                        ;submit FCB
   141 00:70A7: 00           subfcb          byte    0               ;will be drive A
   142 00:70A8: 24 24 24 20                  byte    '$$$     '      ;name field
       00:70AC: 20 20 20 20 
   143 00:70B0: 53 55 42                     byte    'SUB'           ;type field
   144 00:70B3: 00                           byte    0               ;extent
   145 00:70B4: 00 00                        byte    0,0             ;unused
   146 00:70B6: 00           SUBRC           byte    0               ;number of records
   147 00:70B7:                              defs    16              ;block number area
   148 00:70C7: 00           SUBCR           byte    0               ;current record to read
   149                        ;com type field
   150 00:70C8: 43 4F 4D     typcom          byte    "COM"
   151                        ;variable storage
   152 00:70CB: 00           cnbfpt          byte    0               ;buffer index
   153 00:70CC: 00           dfldsk          byte    0               ;default drive
   154 00:70CD: 00           tmpdsk          byte    0               ;temporary drive
   155 00:70CE: 00           dsksav          byte    0               ;save default during $$$.sub ops
   156 00:70CF: 00           count           byte    0               ;counter
   157 00:70D0: 00           curpnt          byte    0               ;input parse start
   158 00:70D1: 00           diradd          byte    0               ;directory number
   159 00:70D2: 00           savx            byte    0               ;save x location
   160 00:70D3: 00           savy            byte    0               ;save y location
   161 00:70D4: 00           length          byte    0               ;number pages to save
   162 00:70D5: 00           oldtmp          byte    0               ;temp drive in ren
   163 00:70D6: 00 08        dskbuf          word    tea             ;disk buffer start
   164 00:70D8: 00           across          byte    0               ;dir count on line
   165 00:70D9: 09           moduls          byte    9               ;modulus-1 for number input
   166 00:70DA: 00 00        num             word    0               ;input number
   167 00:70DC: 00 00        tnum            word    0               ;temp in bldnum
   168 00:70DE: 00 08        sadr            word    tea             ;save start address
   169 00:70E0: 00 08        DoLoc           word    tea             ;GO destination
   170                        ;
   171                        ;PEM section
   172                                        org     $/256*256+256
   173 00:7100: 4C 00 C8     pemram          jmp     pem
   174                        ;pem variable storage
   175 00:7103: 00           drvcmd          byte    0               ;new commanded drive
   176 00:7104: 00           drvflg          byte    0               ;0 = nothing changed,
   177                        ;                                       255 - drive number destroyed
   178 00:7105: 00           usrcde          byte    0               ;user code
   179 00:7106: 00           skpdir          byte    0               ;positive if no change
   180 00:7107: 00           fcbind          byte    0               ;index to block number
   181 00:7108: 00           savext          byte    0               ;save extent
   182 00:7109: 00           frscol          byte    0               ;first col
  Thu Apr 29 2021  3:45                                                                                                    Page 4


   183 00:710A: 00           pndkey          byte    0               ;pending input
   184 00:710B: 00           lstflg          byte    0               ;printer flag
   185 00:710C: 00           positn          byte    0               ;print position
   186 00:710D: 00           cmdinp          byte    0               ;input command
   187 00:710E: 00 00        addout          word    0               ;output address
   188             0000710E   bytout          equ     addout          ;output value
   189 00:7110: 00           bufpsn          byte    0               ;input buffer position
   190 00:7111: 00           exrwfl          byte    0               ;extend flag
   191 00:7112: 00           tmpdrv          byte    0               ;temporary drive flag & number
   192 00:7113: 00 00        countr          word    0               ;record counter
   193 00:7115: 00                           byte    0               ;overflow
   194 00:7116: 00 00        lkdown          word    0               ;down pnt. for block search
   195 00:7118: 00 00        lookup          word    0               ;up pnt. for block search
   196 00:711A: 00           olddrv          byte    0               ;old drive number
   197 00:711B: 00           curdrv          byte    0               ;current drive
   198 00:711C: 00           lginvc          byte    0               ;log in status
   199 00:711D: 00           ronlst          byte    0               ;read write status
   200 00:711E: 00 00        dirnum          word    0               ;directory number
   201 00:7120: 00           subrec          byte    0               ;directory offset
   202 00:7121: 00 00        recnum          word    0               ;record number
   203             00007121   blknum          equ     recnum          ;block number
   204 00:7123: 00                           byte    0               ;overflow
   205 00:7124: 00           chrcnt          byte    0               ;character count
   206 00:7125: 00           cmppnt          byte    0               ;comparison pointer
   207 00:7126: 00           nxtrec          byte    0               ;next record
   208 00:7127: 00           numrec          byte    0               ;number records
   209 00:7128: 00 00        dirrec          word    0               ;directory record
   210 00:712A: 00           dirmod          byte    0               ;directory mod 4
   211 00:712B: 00           index           byte    0               ;buffer index
   212 00:712C: 00           numcnt          byte    0               ;counter
   213 00:712D: 00           outflg          byte    0               ;output enable flag
   214 00:712E: 00           lstcol          byte    0               ;last column
   215 00:712F: 00           mpdrsy          byte    0               ;save for y in mapdir
   216 00:7130: 00           mpdrtm          byte    0               ;temp in mapdir
   217 00:7131: 00           blmode          byte    0               ;<128 if byte else word
   218 00:7132: 00 00        maxdrc          word    0               ;max directory record
   219 00:7134: 00           sab             byte    0               ;mask for block
   220 00:7135: 00           sxb             byte    0               ;shift for block
   221 00:7136: 00 00 00     rtclk           byte    0,0,0           ;real time clock
   222 00:7139: 00 00        gpcnt           word    0               ;gp counter
   223 00:713B: 00           trkctr          byte    0               ;track counter
   224                        ;following region is used to capture dcb
   225                        dcb
   226 00:713C: 00 00        maxblk          word    0               ;maximum block number
   227 00:713E: 00 00        sectrk          word    0               ;sectors per track
   228 00:7140: 00 00        nsystr          word    0               ;number system tracks
   229 00:7142: 00           blkscd          byte    0               ;block size code
   230 00:7143: 00 00        maxdir          word    0               ;maximum directory number
   231 00:7145: 00 00        alcmap          word    0               ;address of allocation map
   232 00:7147: 00           chkflg          byte    0               ;check flag
   233 00:7148: 00 00        chkmap          word    0               ;address of checksum map
   234 00:714A: 00           wrtype          byte    0               ;write type 0=norm,1=dir,2=unalloc
   235 00:714B: 00           exm             byte    0               ;extent mask
   236 00:714C: 00           cexm1f          byte    0               ;exm complemented and 1f
   237                        ;
   238                        ;SIM section
   239                        ; Note: the start of SIM RAM has been changed to a half-page address!
   240                        ; Nothing "should" require any additional code changes.
   241                        ; However (there's always one!), The XSBC123 Xmodem utility did
   242                        ; require a change in the startup, as it was grabbing the jmp
   243                        ; addresses for monitor routines, but assuming everything was
   244                        ; on a page boundary (only grabbing the high order byte) - KM
   245                        ;
  Thu Apr 29 2021  3:45                                                                                                    Page 5


   246                                        org     $/256*256+128
   247 00:7180: 4C 47 D3     simram          jmp     sim_boot        ;from cold start
   248 00:7183: 4C 72 D3     sim_wboote      jmp     sim_wboot       ;from warm boot
   249 00:7186: 4C CB D5                     jmp     mon_consts      ;check for input
   250 00:7189: 4C D1 D5                     jmp     mon_conrde      ;get input
   251 00:718C: 4C DD D5                     jmp     mon_conwrt      ;send to terminal
   252 00:718F: EA                           nop                     ;printer output
   253 00:7190: EA                           nop
   254 00:7191: 60                           rts
   255 00:7192: EA                           nop                     ;punch output
   256 00:7193: EA                           nop
   257 00:7194: 60                           rts
   258 00:7195: EA                           nop                     ;reader input
   259 00:7196: EA                           nop
   260 00:7197: 60                           rts
   261 00:7198: EA                           nop                     ;home drive
   262 00:7199: EA                           nop
   263 00:719A: 60                           rts
   264 00:719B: 4C 80 D3                     jmp     sim_seldsk      ;select disk
   265 00:719E: 4C C2 D5                     jmp     sim_seltrk      ;set track
   266 00:71A1: 4C B0 D5                     jmp     sim_selsec      ;set sector
   267 00:71A4: 4C B9 D5                     jmp     sim_setdma      ;set buffer address
   268 00:71A7: 4C C2 D3                     jmp     sim_read        ;read sector
   269 00:71AA: 4C D4 D3                     jmp     sim_write       ;write sector
   270 00:71AD: A9 01                        lda     #1              ;printer always ready
   271 00:71AF: 60                           rts
   272 00:71B0: A2 80                        ldx     #128            ;clock entry - disable for now
   273 00:71B2: 60                           rts
   274 00:71B3: 4C C1 D3                     jmp     sim_xlate       ;translate (goes to a RTS)
   275                        ;console definition block
   276 00:71B6: 00                           byte    0               ;scratch
   277 00:71B7: 08           sysdef          byte    8               ;backspace
   278 00:71B8: 01                           byte    1               ;clear to end of line
   279 00:71B9: 0C                           byte    $0C             ;forward space
   280 00:71BA: 00                           byte    0               ;normal video
   281 00:71BB: 5E                           byte    '^'             ;invert video
   282 00:71BC: 18                           byte    24              ;lines per screen
   283 00:71BD: 50                           byte    80              ;char per line
   284 00:71BE: 0C                           byte    $0C             ;form feed
   285 00:71BF: 1E                           byte    $1E             ;home
   286 00:71C0: 02                           byte    2               ;clear to end of screen
   287                        ;sim data area
   288 00:71C1: 00           sim_sekdsk      byte    0               ;seek disk number
   289 00:71C2: 00           sim_hstwrt      byte    0               ;0=written,1=pending host write
   290                        ;allocate the following data areas to unused ram space
   291 00:71C3:              sim_hstact      defs    1               ;host active flag
   292 00:71C4:              sim_unacnt      defs    1               ;unalloc rec cnt
   293 00:71C5:              sim_sektrk      defs    2               ;seek track number
   294 00:71C7:              sim_seksec      defs    2               ;seek sector number
   295 00:71C9:              sim_hstdsk      defs    1               ;host disk number
   296 00:71CA:              sim_hsttrk      defs    2               ;host track number
   297 00:71CC:              sim_hstsec      defs    2               ;host sector number
   298 00:71CE:              sim_sekhst      defs    2               ;seek shr secshf
   299 00:71D0:              sim_unadsk      defs    1               ;last unalloc disk
   300 00:71D1:              sim_unatrk      defs    2               ;last unalloc track
   301 00:71D3:              sim_unasec      defs    2               ;last unalloc sector
   302 00:71D5:              sim_erflag      defs    1               ;error reporting
   303 00:71D6:              sim_rsflag      defs    1               ;read sector flag
   304 00:71D7:              sim_readop      defs    1               ;1 if read operation
   305 00:71D8:              sim_wrtype      defs    1               ;write operation type
   306 00:71D9:              sim_d65spt      defs    2               ;dos/65 records/track
   307                        
   308                                org     $/256*256+256
  Thu Apr 29 2021  3:45                                                                                                    Page 6


   309                        ;
   310                        ;Major change here. To conserve ROM space, the allocation maps for the disk
   311                        ; drives are no longer stored in ROM. Therefore, they don't need to be copied
   312                        ; to RAM during a cold start. During startup, the map space shown below
   313                        ; is cleared out by a routine in the SIM module. It uses bufmap and bufmapend
   314                        ; as start and end addresses. - KM
   315                        ;
   316                        ;With other changes, enough RAM space was saved to add access and allocation
   317                        ; maps for three additional drives, now from: A - G (total of 7)
   318                        ; Note that the hstbuf has been moved to low RAM at $0600, which is the
   319                        ; default LBA buffer for the C02BIOS. - KM
   320                        ;
   321                        bufmap
   322                        
   323                        ;allocation and checksum maps
   324                        ;drive a
   325             00007200   almpa           equ     bufmap
   326                        ;drive b
   327             00007400   almpb           equ     almpa+512
   328                        ;drive c
   329             00007600   almpc           equ     almpb+512
   330                        ;drive d
   331             00007800   almpd           equ     almpc+512
   332                        ;drive e
   333             00007A00   almpe           equ     almpd+512
   334                        ;drive f
   335             00007C00   almpf           equ     almpe+512
   336                        ;drive g
   337             00007E00   almpg           equ     almpf+512
   338                        ;
   339             00008000   bufmapend       equ     almpg+512
   340                        
   341                                code
   342                        ;main program
   343                                org     romstrt
   344                        ;-------------------------------
   345                        ;DOS/65 Console Command Module
   346                        ;-------------------------------
   347                        ;CCM unique definitions
   348             00000008   nbuilt  equ     8               ;number built in commands
   349             00000004   dirpln  equ     4               ;number dir listings per line
   350                        ;entry point
   351 00:C000: 80 27        CCM     bra     CCMStr
   352                        ;$$$.sub related subroutines
   353                        ;prepare drive A and FCB pointer for $$$.sub operation
   354 00:C002: AD CC 70     PrpSUB  lda     dfldsk          ;get default drive
   355 00:C005: 8D CE 70             sta     dsksav          ;save it
   356 00:C008: 9C CC 70             stz     dfldsk          ;set default to A
   357 00:C00B: 20 B7 C4             jsr     slctds          ;and select A
   358                        ;set up submit FCB pointer
   359 00:C00E: A9 A7        setsub  lda     #<subfcb        ;low
   360 00:C010: A0 70                ldy     #>subfcb
   361 00:C012: 60                   rts
   362                        ;recover disk assignments after $$$.sub ops
   363 00:C013: AD CE 70     RcvDsk  lda     dsksav          ;return drive to default
   364 00:C016: 8D CC 70             sta     dfldsk
   365 00:C019: 4C B7 C4             jmp     slctds          ;and select it
   366                        ;delete $$$.SUB file and clear flag
   367 00:C01C: 20 0E C0     delsub  jsr     setsub          ;set up FCB address
   368 00:C01F: 20 CE C4             jsr     dltfil          ;do delete
   369 00:C022: 20 13 C0             jsr     rcvdsk          ;restore drives
   370 00:C025: 9C A6 70     stpsub  stz     subflg          ;clear submit flag
   371 00:C028: 60                   rts
  Thu Apr 29 2021  3:45                                                                                                    Page 7


   372                        ;main program
   373 00:C029: D8           CCMStr  cld                     ;set binary mode
   374 00:C02A: AD 06 01             lda     iostat          ;get drive and user numbers
   375 00:C02D: 4A                   lsr     a               ;move user to low nibble
   376 00:C02E: 4A                   lsr     a
   377 00:C02F: 4A                   lsr     a
   378 00:C030: 4A                   lsr     a
   379 00:C031: 20 B1 C3             jsr     setusr          ;tell PEM user number
   380 00:C034: AD 06 01             lda     iostat          ;get data again
   381 00:C037: 29 07                and     #%00000111      ;mask for drive only
   382 00:C039: 8D CC 70             sta     dfldsk          ;save it
   383 00:C03C: 20 B7 C4             jsr     slctds          ;select drive
   384 00:C03F: A9 28                lda     #<DflBuf        ;set default buffer
   385 00:C041: A0 01                ldy     #>DflBuf
   386 00:C043: 20 E6 C4             jsr     setbuf
   387 00:C046: 20 B3 C4             jsr     rstdsk          ;initialize system
   388                        ;now see if $$$.sub file on A
   389 00:C049: 9C A6 70             stz     subflg          ;clear submit flag
   390 00:C04C: 20 02 C0             jsr     prpsub          ;get ready for $$$.sub
   391 00:C04F: 20 C3 C4             jsr     srchfr          ;search for file
   392                        ;if $$$.sub file present set subflg to use file
   393 00:C052: 30 07                bmi     nosub           ;flag ok if a=255
   394 00:C054: A9 FF                lda     #255            ;set flag
   395 00:C056: 8D A6 70             sta     subflg          ;save it
   396 00:C059: 80 03                bra     ccmlpe          ;and go to main loop
   397 00:C05B: 20 13 C0     nosub   jsr     rcvdsk          ;return to original default
   398 00:C05E: A2 FF        ccmlpe  ldx     #$ff            ;set
   399 00:C060: 9A                   txs                     ;stack
   400 00:C061: D8                   cld                     ;set binary mode
   401 00:C062: A9 28                lda     #<DflBuf        ;set default buffer
   402 00:C064: A0 01                ldy     #>DflBuf
   403 00:C066: 20 E6 C4             jsr     setbuf
   404 00:C069: 20 1C C5             jsr     hdrout          ;send header
   405 00:C06C: A9 3E                lda     #'>'            ;then print
   406 00:C06E: 20 A7 C4             jsr     chrout          ;prompt
   407                        ;at this point we check flag for use of $$$.SUB file
   408 00:C071: AD A6 70             lda     subflg          ;test it
   409 00:C074: 30 02                bmi     L01
   410 00:C076: 80 57                bra     usecns          ;if clear use console
   411                        ;we must use $$$.SUB file
   412 00:C078: 20 0E C0     L01     jsr     setsub          ;get FCB pointer
   413 00:C07B: 20 BB C4             jsr     openfl          ;try to open
   414 00:C07E: 10 05                bpl     L02             ;use if OK
   415 00:C080: 20 1C C0             jsr     delsub          ;get rid of file
   416 00:C083: 80 4A                bra     usecns          ;use console if no open
   417 00:C085: AE B6 70     L02     ldx     subrc           ;get record count
   418 00:C088: CA                   dex
   419 00:C089: 8E C7 70             stx     subcr           ;and read last record
   420 00:C08C: 20 0E C0             jsr     setsub          ;get ready for sub
   421 00:C08F: 20 D2 C4             jsr     rdrcrd          ;read record
   422 00:C092: F0 05                beq     L03             ;if OK get data
   423 00:C094: 20 1C C0             jsr     delsub          ;else clean up from EOF
   424 00:C097: 80 36                bra     usecns          ;and use console
   425                        ;read was OK so move record to command buffer
   426 00:C099: A2 00        L03     ldx     #0
   427 00:C09B: BD 28 01     movsub  lda     dflbuf,x        ;get char
   428 00:C09E: 9D 04 70             sta     cnslng,x        ;move it
   429 00:C0A1: E8                   inx                     ;bump index
   430 00:C0A2: 10 F7                bpl     movsub          ;loop until index 128
   431                        ;now delete record
   432 00:C0A4: CE B6 70             dec     subrc           ;drop number records by one
   433 00:C0A7: 20 0E C0             jsr     setsub          ;get ready for sub
   434 00:C0AA: 20 BF C4             jsr     clsefl
  Thu Apr 29 2021  3:45                                                                                                    Page 8


   435 00:C0AD: 10 05                bpl     typbuf          ;if OK go type line
   436 00:C0AF: 20 1C C0             jsr     delsub          ;then delete $$$.SUB
   437 00:C0B2: 80 1B                bra     usecns          ;switch to console if bad
   438                        ;send command line to console
   439 00:C0B4: A2 00        typbuf  ldx     #0              ;start one past length
   440 00:C0B6: BD 05 70     print0  lda     cnstxt,x        ;get char
   441 00:C0B9: F0 06                beq     gotend          ;done if zero
   442 00:C0BB: 20 3B C5             jsr     cotsxy          ;save x and send to console
   443 00:C0BE: E8                   inx
   444 00:C0BF: 10 F5                bpl     print0          ;do next
   445 00:C0C1: 20 AF C4     gotend  jsr     chkcst          ;check for key pressed
   446 00:C0C4: F0 10                beq     nobrak          ;no break if no key
   447 00:C0C6: 20 9D C4             jsr     cnsrdx          ;get key without echo
   448 00:C0C9: 20 1C C0             jsr     delsub          ;stop $$$.SUB use
   449 00:C0CC: 4C 00 C0             jmp     ccm             ;and go back to start
   450                        ;next line is the entry that stops $$$.SUB processing
   451 00:C0CF: A9 03        usecns  lda     #<cnsbuf        ;point to start
   452 00:C0D1: A0 70                ldy     #>cnsbuf        ;of buffer
   453 00:C0D3: 20 AB C4             jsr     rdebuf          ;do buffer read
   454                        ;next line is the entry point from $$$.SUB read
   455 00:C0D6: A0 00        nobrak  ldy     #0              ;clear index
   456 00:C0D8: AE 04 70             ldx     cnslng          ;get length
   457 00:C0DB: D0 02                bne     lwrupr          ;continue
   458 00:C0DD: 80 71                bra     ccmlp2          ;loop if empty
   459 00:C0DF: B9 05 70     lwrupr  lda     cnstxt,y        ;else get char
   460 00:C0E2: C9 61                cmp     #'a'            ;if less than a
   461 00:C0E4: 90 09                bcc     nxtchg          ;skip convert
   462 00:C0E6: C9 7B                cmp     #'z'+1          ;if over z
   463 00:C0E8: B0 05                bcs     nxtchg          ;skip convert
   464 00:C0EA: 29 5F                and     #%01011111      ;else convert
   465 00:C0EC: 99 05 70             sta     cnstxt,y        ;put back in buffer
   466 00:C0EF: C8           nxtchg  iny                     ;bump index
   467 00:C0F0: CA                   dex                     ;count down
   468 00:C0F1: D0 EC                bne     lwrupr          ;loop if more
   469 00:C0F3: 8A                   txa                     ;set a to zero
   470 00:C0F4: 99 05 70             sta     cnstxt,y        ;insert stopper
   471 00:C0F7: 8D CB 70             sta     cnbfpt          ;initialize pointer
   472 00:C0FA: 20 63 C6     mrecmd  jsr     stdflb          ;set default buffer
   473 00:C0FD: 20 E2 C4             jsr     intdsk          ;get drive number
   474 00:C100: 8D CC 70             sta     dfldsk          ;store as default
   475 00:C103: 20 6C C5             jsr     prslin          ;parse command
   476 00:C106: D0 4E                bne     cmderr          ;error if afn
   477 00:C108: AD CD 70             lda     tmpdsk          ;get temporary
   478 00:C10B: F0 04                beq     nodrch          ;if zero ok
   479 00:C10D: A9 10                lda     #nbuilt*2       ;else set and
   480 00:C10F: 80 2A                bra     dotrns          ;do transient
   481 00:C111: A2 00        nodrch  ldx     #0              ;zero table index
   482 00:C113: 9C CF 70             stz     count           ;and clear count
   483 00:C116: A0 01        tsnxfn  ldy     #1              ;set fcb index
   484 00:C118: BD D3 C7     tsnxch  lda     fnctbl,x        ;get table entry
   485 00:C11B: F0 1A                beq     gotcmd          ;if zero got it
   486 00:C11D: D9 85 70             cmp     fcbone,y        ;else test
   487 00:C120: D0 04                bne     nocmpr          ;no good if not =
   488 00:C122: E8                   inx                     ;bump
   489 00:C123: C8                   iny                     ;pointers
   490 00:C124: D0 F2                bne     tsnxch          ;and loop
   491 00:C126: E8           nocmpr  inx                     ;go to end
   492 00:C127: BD D3 C7             lda     fnctbl,x        ;of table
   493 00:C12A: D0 FA                bne     nocmpr          ;entry
   494 00:C12C: E8                   inx                     ;point to next
   495 00:C12D: EE CF 70             inc     count           ;bump count
   496 00:C130: AD CF 70             lda     count           ;and if not
   497 00:C133: C9 08                cmp     #nbuilt         ;limit then
  Thu Apr 29 2021  3:45                                                                                                    Page 9


   498 00:C135: D0 DF                bne     tsnxfn          ;try next
   499 00:C137: AD CF 70     gotcmd  lda     count           ;get count
   500 00:C13A: 0A                   asl     a               ;multiply by two
   501 00:C13B: AA           dotrns  tax                     ;use as index
   502 00:C13C: 20 53 C1             jsr     ccm_cmd         ;call execute command
   503 00:C13F: 20 EB C4     extcmd  jsr     rstddr          ;restore default
   504 00:C142: 20 6C C5     extwod  jsr     prslin          ;parse more
   505 00:C145: AD 86 70             lda     fcbone+1        ;if first
   506 00:C148: 38                   sec                     ;character
   507 00:C149: E9 20                sbc     #' '            ;not a space
   508 00:C14B: 0D CD 70             ora     tmpdsk          ;or if temporary
   509 00:C14E: D0 06                bne     cmderr          ;then an error
   510 00:C150: 4C 5E C0     ccmlp2  jmp     ccmlpe          ;else loop
   511 00:C153: 7C 47 C7     ccm_cmd jmp     (xqfntb,x)      ;execute command
   512                        ;command error syntax handler
   513 00:C156: 20 94 C4     cmderr  jsr     ccrlf           ;do a cr lf
   514 00:C159: AC D0 70             ldy     curpnt          ;get command pointer
   515 00:C15C: B9 05 70     cmerlp  lda     cnstxt,y        ;get char
   516 00:C15F: F0 0A                beq     cmerex          ;if null then done
   517 00:C161: C9 20                cmp     #' '            ;if space
   518 00:C163: F0 06                beq     cmerex          ;then done
   519 00:C165: 20 3B C5             jsr     cotsxy          ;output with save
   520 00:C168: C8                   iny                     ;point to next
   521 00:C169: D0 F1                bne     cmerlp          ;and loop
   522 00:C16B: A9 3F        cmerex  lda     #'?'            ;send a
   523 00:C16D: 20 A7 C4             jsr     chrout          ;question mark
   524 00:C170: 80 DE                bra     ccmlp2          ;and start over
   525                        ;execute dir command
   526                        ; dir <afn>
   527 00:C172: 20 6C C5     dir     jsr     prslin          ;find object file
   528 00:C175: 20 6A C6             jsr     clrslt          ;clear auto and select
   529 00:C178: A9 20                lda     #' '            ;if name
   530 00:C17A: CD 86 70             cmp     fcbone+1        ;and
   531 00:C17D: D0 0F                bne     findfr          ;type are
   532 00:C17F: CD 8E 70             cmp     fcbone+9        ;not empty
   533 00:C182: D0 0A                bne     findfr          ;then use it
   534 00:C184: A9 3F                lda     #'?'            ;else
   535 00:C186: A0 0B                ldy     #11             ;fill
   536 00:C188: 99 85 70     fillqu  sta     fcbone,y        ;fcb
   537 00:C18B: 88                   dey                     ;with
   538 00:C18C: D0 FA                bne     fillqu          ;question marks
   539 00:C18E: 20 12 C5     findfr  jsr     srchf1          ;search for first match
   540 00:C191: 30 53                bmi     notfnd          ;error if none
   541 00:C193: A9 04        fnddir  lda     #dirpln         ;set across
   542 00:C195: 8D D8 70             sta     across          ;to entries per line
   543 00:C198: 20 94 C4             jsr     ccrlf           ;do a crlf
   544 00:C19B: 20 1F C5     dirl    jsr     hdr             ;do header
   545 00:C19E: A9 3A                lda     #':'            ;then a
   546 00:C1A0: 20 A7 C4             jsr     chrout          ;colon
   547 00:C1A3: AD D1 70             lda     diradd          ;get number
   548 00:C1A6: 0A                   asl     a               ;and
   549 00:C1A7: 0A                   asl     a               ;multiply
   550 00:C1A8: 0A                   asl     a               ;by
   551 00:C1A9: 0A                   asl     a               ;thirty two
   552 00:C1AA: 0A                   asl     a               ;then
   553 00:C1AB: 29 60                and     #%01100000      ;mask out insignificant
   554 00:C1AD: A8                   tay                     ;make a pointer
   555 00:C1AE: C8                   iny                     ;and bump
   556 00:C1AF: A2 01                ldx     #1              ;set counter
   557 00:C1B1: B9 28 01     nmelpe  lda     dflbuf,y        ;get name
   558 00:C1B4: 20 3B C5             jsr     cotsxy          ;else send to console
   559 00:C1B7: C8           noname  iny                     ;bump index
   560 00:C1B8: E8                   inx                     ;and count
  Thu Apr 29 2021  3:45                                                                                                    Page 10


   561 00:C1B9: E0 0C                cpx     #12             ;if count is 12
   562 00:C1BB: F0 0B                beq     endnme          ;then done
   563 00:C1BD: E0 09                cpx     #9              ;or if not 9
   564 00:C1BF: D0 F0                bne     nmelpe          ;then loop
   565 00:C1C1: A9 2E                lda     #'.'            ;else send
   566 00:C1C3: 20 3B C5             jsr     cotsxy          ;a period
   567 00:C1C6: 80 E9                bra     nmelpe          ;and loop
   568 00:C1C8: 20 AF C4     endnme  jsr     chkcst          ;check console status
   569 00:C1CB: D0 18                bne     extdir          ;if key down quit
   570 00:C1CD: 20 60 C5             jsr     setone          ;else point to fcb
   571 00:C1D0: 20 C7 C4             jsr     srchnx          ;else search for next
   572 00:C1D3: 8D D1 70             sta     diradd          ;save number
   573 00:C1D6: 30 0D                bmi     extdir          ;quit if not found
   574 00:C1D8: CE D8 70             dec     across          ;drop count
   575 00:C1DB: F0 B6                beq     fnddir          ;new line if 0
   576 00:C1DD: 20 A5 C4             jsr     spcout          ;send one space
   577 00:C1E0: 20 A5 C4             jsr     spcout          ;two spaces
   578 00:C1E3: 80 B6                bra     dirl            ;and stay
   579 00:C1E5: 60           extdir  rts                     ;else done
   580                        ;not found error handler
   581 00:C1E6: A0 33        notfnd  ldy     #ntfnms         ;point to message
   582 00:C1E8: 80 5F                bra     remsg           ;send and exit
   583                        ;execute ren command
   584                        ; ren <ufn> <ufn>
   585                        ;where first ufn is from name and second is to name
   586 00:C1EA: 20 6C C5     ren     jsr     prslin          ;get old name
   587 00:C1ED: D0 55                bne     renerr          ;error if afn
   588 00:C1EF: 20 65 C5             jsr     tmpold          ;save drive
   589 00:C1F2: 20 6A C6             jsr     clrslt          ;clear auto and select
   590 00:C1F5: 20 12 C5             jsr     srchf1          ;if file does not exist
   591 00:C1F8: 30 4D                bmi     fntfnd          ;then an error
   592 00:C1FA: 20 9D C6             jsr     frssec          ;move name to second half
   593 00:C1FD: AC CB 70             ldy     cnbfpt          ;get pointer
   594 00:C200: B9 05 70             lda     cnstxt,y        ;and then char
   595 00:C203: C9 20                cmp     #' '            ;if not a space
   596 00:C205: D0 3A                bne     rensyn          ;then error
   597 00:C207: 20 6C C5             jsr     prslin          ;get new name
   598 00:C20A: D0 35                bne     rensyn          ;error if afn
   599 00:C20C: AD CD 70             lda     tmpdsk          ;get new drive
   600 00:C20F: F0 12                beq     nonwdr          ;if zero ok
   601 00:C211: CD D5 70             cmp     oldtmp          ;compare to old
   602 00:C214: F0 0D                beq     nonwdr          ;ok if same
   603 00:C216: 38                   sec                     ;drop for default check
   604 00:C217: E9 01                sbc     #1
   605 00:C219: CD CC 70             cmp     dfldsk          ;if not default
   606 00:C21C: D0 23                bne     rensyn          ;is error
   607 00:C21E: AD D5 70             lda     oldtmp          ;and then if from not
   608 00:C221: D0 1E                bne     rensyn          ;default is error
   609 00:C223: AD D5 70     nonwdr  lda     oldtmp          ;else get old
   610 00:C226: 8D CD 70             sta     tmpdsk          ;and save
   611 00:C229: 9C 95 70             stz     fcbone+16       ;clear fcb offset
   612 00:C22C: 20 6A C6             jsr     clrslt          ;reselect
   613 00:C22F: 20 12 C5             jsr     srchf1          ;search for old
   614 00:C232: 10 09                bpl     filexs          ;error if found
   615 00:C234: 20 9D C6             jsr     frssec          ;swap names
   616 00:C237: 20 60 C5             jsr     setone          ;point to fcb
   617 00:C23A: 4C DE C4             jmp     renmfl          ;and do it
   618                        ;ren file exists error handler
   619 00:C23D: A0 3D        filexs  ldy     #flexms         ;point to
   620 00:C23F: 80 08                bra     remsg           ;and send
   621                        ;ren syntax error handler
   622 00:C241: 20 EB C4     rensyn  jsr     rstddr          ;restore default
   623 00:C244: 4C 56 C1     renerr  jmp     cmderr          ;do error
  Thu Apr 29 2021  3:45                                                                                                    Page 11


   624                        ;ren source file not found error handler
   625 00:C247: A0 33        fntfnd  ldy     #ntfnms         ;point to
   626 00:C249: 4C 7D C6     remsg   jmp     sndmsg          ;and send
   627                        ;execute save command
   628                        ; save <length> <drive:>ufn (<address>)
   629 00:C24C: A9 00        save    lda     #<tea           ;set start address to tea start
   630 00:C24E: A0 08                ldy     #>tea
   631 00:C250: 8D DE 70             sta     sadr
   632 00:C253: 8C DF 70             sty     sadr+1
   633 00:C256: 20 C2 C6             jsr     bldnum          ;calculate length
   634 00:C259: D0 7A                bne     saverr          ;error if > 255 pages
   635 00:C25B: 8D D4 70             sta     length          ;else save low
   636 00:C25E: 0D D4 70             ora     length          ;test for zero length
   637 00:C261: F0 72                beq     saverr          ;error if is
   638 00:C263: 20 6C C5             jsr     prslin          ;get file name
   639 00:C266: D0 6D                bne     saverr          ;error if afn
   640 00:C268: 20 9D C6             jsr     frssec          ;move name to second half
   641 00:C26B: 20 65 C5             jsr     tmpold          ;save drive
   642 00:C26E: 20 C2 C6             jsr     bldnum          ;it is so find value
   643 00:C271: AE 86 70             ldx     fcbone+1        ;see if there
   644 00:C274: E0 20                cpx     #' '
   645 00:C276: F0 0A                beq     nosadr          ;it is not
   646 00:C278: 8D DE 70             sta     sadr            ;and set address
   647 00:C27B: 8C DF 70             sty     sadr+1
   648 00:C27E: C0 02                cpy     #2              ;make sure is high enough
   649 00:C280: 90 53                bcc     saverr          ;error if not
   650 00:C282: 20 B0 C6     nosadr  jsr     secfrs          ;move name back
   651 00:C285: 20 6A C6             jsr     clrslt          ;clear auto and select
   652 00:C288: 20 CB C4             jsr     dlt1            ;delete
   653 00:C28B: 20 60 C5             jsr     setone          ;then create
   654 00:C28E: 20 DA C4             jsr     cratfl          ;new file
   655 00:C291: 30 44                bmi     noroom          ;say no room if error
   656 00:C293: 20 00 C5             jsr     open1           ;open file
   657 00:C296: 30 43                bmi     noopen          ;if error
   658 00:C298: 18                   clc                     ;now find end page
   659 00:C299: AD DF 70             lda     sadr+1
   660 00:C29C: 6D D4 70             adc     length
   661 00:C29F: 8D D4 70             sta     length
   662 00:C2A2: AD DE 70             lda     sadr            ;get start address
   663 00:C2A5: AC DF 70             ldy     sadr+1
   664 00:C2A8: 8D D6 70     wrtmre  sta     dskbuf          ;set
   665 00:C2AB: 8C D7 70             sty     dskbuf+1        ;buffer
   666 00:C2AE: 20 4F D2             jsr     mv128           ;move data to buffer
   667 00:C2B1: 20 60 C5             jsr     setone          ;point to fcb
   668 00:C2B4: 20 D6 C4             jsr     wrrcrd          ;write record
   669 00:C2B7: D0 26                bne     wrterr          ;exit if error
   670 00:C2B9: 18                   clc                     ;else
   671 00:C2BA: AD D6 70             lda     dskbuf          ;get old
   672 00:C2BD: AC D7 70             ldy     dskbuf+1        ;buffer
   673 00:C2C0: 69 80                adc     #128            ;add 128
   674 00:C2C2: 90 03                bcc     donotc          ;if carry
   675 00:C2C4: C8                   iny                     ;bump upper
   676 00:C2C5: F0 05                beq     clssav          ;done if page zero
   677 00:C2C7: CC D4 70     donotc  cpy     length          ;loop if upper
   678 00:C2CA: D0 DC                bne     wrtmre          ;not at limit
   679 00:C2CC: 20 60 C5     clssav  jsr     setone          ;else point to
   680 00:C2CF: 20 BF C4             jsr     clsefl          ;and close file
   681 00:C2D2: 30 0F                bmi     cantcl          ;say so if error
   682 00:C2D4: 60           extera  rts
   683                        ;save error handler
   684 00:C2D5: 80 64        saverr  bra     typafn          ;do error
   685                        ;save no room error handler
   686 00:C2D7: A0 00        noroom  ldy     #nospms         ;point to
  Thu Apr 29 2021  3:45                                                                                                    Page 12


   687 00:C2D9: 80 69                bra     temsg           ;and send
   688                        ;save can not open error handler
   689 00:C2DB: A0 54        noopen  ldy     #cnnoms         ;point to
   690 00:C2DD: 80 65                bra     temsg           ;and send
   691                        ;save write error handler
   692 00:C2DF: A0 61        wrterr  ldy     #wrerms         ;point
   693 00:C2E1: 80 61                bra     temsg           ;to and send
   694                        ;save can not close error
   695 00:C2E3: A0 09        cantcl  ldy     #ntclms         ;point to
   696 00:C2E5: 80 5D                bra     temsg           ;and send
   697                        ;execute era command
   698                        ; era <afn>
   699 00:C2E7: 20 6C C5     era     jsr     prslin          ;get file name
   700 00:C2EA: C9 0B                cmp     #11             ;if not all ?
   701 00:C2EC: D0 13                bne     nteral          ;then skip verify
   702 00:C2EE: A0 17                ldy     #alflms         ;else point to
   703 00:C2F0: 20 7D C6             jsr     sndmsg          ;and send all files
   704 00:C2F3: 20 A1 C4             jsr     cnsrde          ;get an input
   705 00:C2F6: 48                   pha                     ;and save
   706 00:C2F7: 20 94 C4             jsr     ccrlf           ;do a cr lf
   707 00:C2FA: 68                   pla                     ;restore char
   708 00:C2FB: 29 5F                and     #$5f            ;convert to upper case
   709 00:C2FD: C9 59                cmp     #'Y'            ;if not y
   710 00:C2FF: D0 D3                bne     extera          ;then quit
   711 00:C301: 20 6A C6     nteral  jsr     clrslt          ;clear auto and select
   712 00:C304: 4C CB C4             jmp     dlt1            ;delete first
   713                        ;execute type command
   714                        ; type d:ufn
   715 00:C307: 20 6C C5     type    jsr     prslin          ;get file
   716 00:C30A: D0 2F                bne     typafn          ;error if afn
   717 00:C30C: 20 FD C4             jsr     casdo1          ;clear - select - open file 1
   718 00:C30F: 30 31                bmi     notype          ;error if not found
   719 00:C311: 20 94 C4             jsr     ccrlf           ;else do cr lf
   720 00:C314: 20 0D C5     typmre  jsr     read1           ;read record
   721 00:C317: F0 04                beq     okread          ;if ok continue
   722 00:C319: 10 B9                bpl     extera          ;exit if just end
   723 00:C31B: 30 21                bmi     typerr          ;else error
   724 00:C31D: A2 00        okread  ldx     #0              ;clear index
   725 00:C31F: BD 28 01     typlpe  lda     dflbuf,x        ;get char
   726 00:C322: C9 1A                cmp     #eof            ;if eof
   727 00:C324: F0 AE                beq     extera          ;then exit
   728 00:C326: 20 3B C5             jsr     cotsxy          ;else send
   729 00:C329: 20 AF C4             jsr     chkcst          ;if key down
   730 00:C32C: D0 08                bne     exttok          ;then exit
   731 00:C32E: AE D2 70             ldx     savx            ;else get index
   732 00:C331: E8                   inx                     ;bump it
   733 00:C332: 10 EB                bpl     typlpe          ;and loop if < 128
   734 00:C334: 30 DE                bmi     typmre          ;else read more
   735 00:C336: A2 06        exttok  ldx     #6              ;clear console
   736 00:C338: 4C 03 01             jmp     pemjmp          ;with no echo
   737                        ;exttyp  rts
   738                        ;type syntax error handler
   739 00:C33B: 4C 56 C1     typafn  jmp     cmderr          ;error return
   740                        ;type read error handler
   741 00:C33E: A0 28        typerr  ldy     #rderms         ;point to
   742 00:C340: 80 02                bra     temsg           ;and send
   743                        ;type not found error handler
   744 00:C342: A0 33        notype  ldy     #ntfnms         ;point to
   745 00:C344: 4C 7D C6     temsg   jmp     sndmsg          ;and send
   746                        ;execute load command
   747                        ; load <ufn> (<address>)
   748 00:C347: 20 92 C6     load    jsr     setddb          ;set load start to tea start
   749 00:C34A: 20 6C C5             jsr     prslin          ;build fcb
  Thu Apr 29 2021  3:45                                                                                                    Page 13


   750 00:C34D: D0 EC                bne     typafn          ;error if afn
   751 00:C34F: 20 9D C6             jsr     frssec          ;save in second half
   752 00:C352: 20 65 C5             jsr     tmpold          ;save file
   753 00:C355: 20 C2 C6             jsr     bldnum          ;find start address
   754 00:C358: AE 86 70             ldx     fcbone+1        ;see if number
   755 00:C35B: E0 20                cpx     #' '
   756 00:C35D: F0 03                beq     usedfl          ;if none use default
   757 00:C35F: 20 96 C6             jsr     setdb           ;and set
   758 00:C362: 20 B0 C6     usedfl  jsr     secfrs          ;move name back
   759 00:C365: 20 FD C4             jsr     casdo1          ;clear - select - open file 1
   760 00:C368: 30 D8                bmi     notype          ;exit if not found
   761 00:C36A: AD D6 70             lda     dskbuf          ;get load start
   762 00:C36D: AC D7 70             ldy     dskbuf+1
   763 00:C370: 20 E6 C4     lcmdlp  jsr     setbuf          ;set as disk buffer
   764 00:C373: 20 0D C5             jsr     read1           ;read record
   765 00:C376: D0 05                bne     loadnd          ;done if not zero
   766 00:C378: 20 3C D2             jsr     adjdb           ;bump address
   767 00:C37B: 80 F3                bra     lcmdlp          ;and loop
   768 00:C37D: 30 BF        loadnd  bmi     typerr          ;if error say so
   769 00:C37F: 4C 63 C6             jmp     stdflb          ;back to default buffer
   770                        ;execute GO command
   771                        ; go (<address>)
   772 00:C382: 20 C2 C6     go      jsr     bldnum          ;get address
   773 00:C385: AE 86 70             ldx     fcbone+1        ;get first char
   774 00:C388: E0 20                cpx     #' '            ;see if nothing
   775 00:C38A: F0 03                beq     nolnum          ;nothing so use tea
   776 00:C38C: 4C 25 C4             jmp     godoit          ;then execute
   777 00:C38F: 4C 21 C4     nolnum  jmp     gotea
   778                        ;execute USER command
   779                        ; user (<number>)
   780 00:C392: 20 C2 C6     user    jsr     bldnum          ;build number
   781 00:C395: AE 86 70             ldx     fcbone+1        ;get first character
   782 00:C398: E0 20                cpx     #' '            ;see if nothing
   783 00:C39A: F0 0E                beq     usrext          ;done if nothing
   784 00:C39C: AD DB 70             lda     num+1           ;check high
   785 00:C39F: D0 0A                bne     usrerr          ;error if too big
   786 00:C3A1: AD DA 70             lda     num             ;get low
   787 00:C3A4: C9 10                cmp     #16             ;see if too big
   788 00:C3A6: B0 03                bcs     usrerr          ;error if is
   789 00:C3A8: 80 07                bra     setusr          ;set if 0-15
   790 00:C3AA: 60           usrext  rts
   791                        ;bad user number entered
   792 00:C3AB: A0 6D        usrerr  ldy     #userms         ;get error message
   793 00:C3AD: 80 95                bra     temsg
   794                        ;user code (usrcde) related routines
   795                        ;get user code from PEM
   796 00:C3AF: A9 FF        getusr  lda     #255            ;query parameter
   797                        ;set user code to A
   798 00:C3B1: A2 24        setusr  ldx     #36             ;37th function
   799 00:C3B3: 4C 03 01             jmp     pemjmp          ;execute
   800                        ;Save user code in A in case of action that may
   801                        ;destroy or alter it.
   802 00:C3B6: 20 AF C3     savusr  jsr     getusr          ;get usrcde from PEM
   803 00:C3B9: 0A                   asl     a               ;shift code to high nibble
   804 00:C3BA: 0A                   asl     a
   805 00:C3BB: 0A                   asl     a
   806 00:C3BC: 0A                   asl     a
   807 00:C3BD: 0D CC 70             ora     dfldsk          ;paste default disk into
   808 00:C3C0: 8D 06 01             sta     iostat          ;iostat and save
   809 00:C3C3: 60                   rts
   810                        ;execute trns (transient) command
   811                        ; <ufn> (<fn>) (<fn>)
   812 00:C3C4: AD 86 70     trns    lda     fcbone+1        ;get first char
  Thu Apr 29 2021  3:45                                                                                                    Page 14


   813 00:C3C7: C9 20                cmp     #' '            ;if not space
   814 00:C3C9: D0 11                bne     chktyp          ;check type
   815 00:C3CB: AD CD 70             lda     tmpdsk          ;else test temp
   816 00:C3CE: F0 09                beq     skpdrv          ;if none skip
   817 00:C3D0: 38                   sec                     ;else convert
   818 00:C3D1: E9 01                sbc     #1              ;to number
   819 00:C3D3: 8D CC 70             sta     dfldsk          ;set default
   820 00:C3D6: 20 B7 C4             jsr     slctds          ;and select
   821 00:C3D9: 4C 42 C1     skpdrv  jmp     extwod          ;return
   822 00:C3DC: AD 8E 70     chktyp  lda     fcbone+9        ;get type
   823 00:C3DF: C9 20                cmp     #' '            ;if space
   824 00:C3E1: F0 03                beq     typemp          ;then ok
   825 00:C3E3: 4C 8C C4             jmp     trnerr          ;else error
   826 00:C3E6: A2 02        typemp  ldx     #2              ;make
   827 00:C3E8: BD C8 70     setcom  lda     typcom,x        ;type
   828 00:C3EB: 9D 8E 70             sta     fcbone+9,x      ;com
   829 00:C3EE: CA                   dex                     ;then
   830 00:C3EF: 10 F7                bpl     setcom          ;continue
   831 00:C3F1: 20 FD C4             jsr     casdo1          ;clear - select - open file one
   832 00:C3F4: 10 03                bpl     gottrn          ;jump if ok
   833 00:C3F6: 4C 89 C4             jmp     topner          ;else do error
   834 00:C3F9: 20 92 C6     gottrn  jsr     setddb          ;set start to tea
   835 00:C3FC: 20 E6 C4     nxtrcr  jsr     setbuf          ;set address
   836 00:C3FF: 20 0D C5             jsr     read1           ;read fcb 1
   837 00:C402: D0 1B                bne     endlde          ;branch if error or eof
   838 00:C404: 20 3C D2             jsr     adjdb           ;adjust address up by 128
   839 00:C407: C9 00                cmp     #<ccmram        ;if new low
   840 00:C409: 90 06                bcc     tryhig          ;ok try high
   841 00:C40B: C0 70                cpy     #>ccmram        ;else if high
   842 00:C40D: 90 ED                bcc     nxtrcr          ;ok do more
   843 00:C40F: B0 06                bcs     chklnd          ;else check for end
   844 00:C411: C0 70        tryhig  cpy     #>ccmram        ;if high less
   845 00:C413: 90 E7                bcc     nxtrcr          ;then ok
   846 00:C415: F0 E5                beq     nxtrcr          ;or ok if same
   847 00:C417: 20 63 C6     chklnd  jsr     stdflb          ;set buffer to default
   848 00:C41A: 20 0D C5             jsr     read1           ;read (should be eof)
   849 00:C41D: F0 70                beq     tlderr          ;error if more
   850 00:C41F: 30 6E        endlde  bmi     tlderr          ;do error
   851 00:C421: A9 00        gotea   lda     #<tea           ;set go address to tea start
   852 00:C423: A0 08                ldy     #>tea
   853 00:C425: 8D E0 70     godoit  sta     DoLoc           ;set to ay
   854 00:C428: 8C E1 70             sty     DoLoc+1
   855 00:C42B: 20 EB C4             jsr     rstddr          ;else restore default
   856 00:C42E: 20 6C C5             jsr     prslin          ;parse file
   857 00:C431: AD CD 70             lda     tmpdsk          ;set auto
   858 00:C434: 8D 85 70             sta     fcbone          ;select position
   859 00:C437: A2 10                ldx     #16             ;do a second
   860 00:C439: 20 6E C5             jsr     prsmre          ;fcb if there
   861 00:C43C: AD CD 70             lda     tmpdsk          ;set auto select
   862 00:C43F: 8D 95 70             sta     fcbone+16       ;again
   863 00:C442: A0 00                ldy     #0              ;clear record
   864 00:C444: 8C A5 70             sty     fcbone+32       ;counter
   865 00:C447: A2 20                ldx     #32             ;move
   866 00:C449: BD 85 70     movfcb  lda     fcbone,x        ;all
   867 00:C44C: 9D 07 01             sta     dflfcb,x        ;to
   868 00:C44F: CA                   dex                     ;default
   869 00:C450: 10 F7                bpl     movfcb          ;fcb
   870 00:C452: E8                   inx                     ;set x to zero
   871 00:C453: B9 05 70     tstbuf  lda     cnstxt,y        ;get char
   872 00:C456: F0 07                beq     isnull          ;if null jump
   873 00:C458: C9 20                cmp     #' '            ;or if space
   874 00:C45A: F0 03                beq     isnull          ;jump
   875 00:C45C: C8                   iny                     ;else bump pointer
  Thu Apr 29 2021  3:45                                                                                                    Page 15


   876 00:C45D: D0 F4                bne     tstbuf          ;and loop
   877 00:C45F: 9C 28 01     isnull  stz     dflbuf          ;clear count
   878 00:C462: B9 05 70     movbuf  lda     cnstxt,y        ;get char
   879 00:C465: 9D 29 01             sta     dflbuf+1,x      ;and move
   880 00:C468: F0 07                beq     fillov          ;exit if null
   881 00:C46A: E8                   inx                     ;increment
   882 00:C46B: C8                   iny                     ;counters
   883 00:C46C: EE 28 01             inc     dflbuf          ;and length
   884 00:C46F: D0 F1                bne     movbuf          ;and loop
   885 00:C471: 20 94 C4     fillov  jsr     ccrlf           ;do a cr lf
   886 00:C474: 20 63 C6             jsr     stdflb          ;set default
   887 00:C477: 20 B6 C3             jsr     savusr          ;save user code
   888 00:C47A: 20 86 C4             jsr     jmp_dlc         ;call execute jmp
   889 00:C47D: AD CC 70     DoRet   lda     dfldsk          ;get default
   890 00:C480: 20 B7 C4             jsr     slctds          ;and set
   891 00:C483: 4C 5E C0             jmp     ccmlpe          ;then loop
   892 00:C486: 6C E0 70     jmp_dlc jmp     (DoLoc)         ;execute
   893                        ;trns syntax error handler
   894 00:C489: 20 EB C4     topner  jsr     rstddr          ;restore default
   895 00:C48C: 4C 56 C1     trnerr  jmp     cmderr          ;do error
   896                        ;trns load error
   897 00:C48F: A0 49        tlderr  ldy     #lderms         ;point to
   898 00:C491: 4C 7D C6             jmp     sndmsg          ;and send
   899                        ;carriage return and linefeed
   900 00:C494: A9 0D        ccrlf   lda     #cr             ;get a cr
   901 00:C496: 20 A7 C4             jsr     chrout          ;send
   902 00:C499: A9 0A                lda     #lf             ;get a lf
   903 00:C49B: 80 0A                bra     chrout          ;and send
   904                        ;general PEM calls
   905 00:C49D: A2 06        cnsrdx  ldx     #6              ;console read without echo
   906 00:C49F: 80 47                bra     pemgo
   907 00:C4A1: A2 01        cnsrde  ldx     #1              ;console read
   908 00:C4A3: 80 43                bra     pemgo
   909 00:C4A5: A9 20        spcout  lda     #' '            ;output space
   910 00:C4A7: A2 02        chrout  ldx     #2              ;console output
   911 00:C4A9: 80 3D                bra     pemgo
   912 00:C4AB: A2 0A        rdebuf  ldx     #10             ;buffered input
   913 00:C4AD: 80 39                bra     pemgo
   914 00:C4AF: A2 0B        chkcst  ldx     #11             ;check console
   915 00:C4B1: 80 35                bra     pemgo
   916 00:C4B3: A2 0D        rstdsk  ldx     #13             ;initialize system
   917 00:C4B5: 80 31                bra     pemgo
   918 00:C4B7: A2 0E        slctds  ldx     #14             ;select drive
   919 00:C4B9: 80 2D                bra     pemgo
   920 00:C4BB: A2 0F        openfl  ldx     #15             ;open file
   921 00:C4BD: 80 29                bra     pemgo
   922 00:C4BF: A2 10        clsefl  ldx     #16             ;close file
   923 00:C4C1: 80 25                bra     pemgo
   924 00:C4C3: A2 11        srchfr  ldx     #17             ;first match
   925 00:C4C5: 80 21                bra     pemgo
   926 00:C4C7: A2 12        srchnx  ldx     #18             ;next match
   927 00:C4C9: 80 1D                bra     pemgo
   928                        ;delete file one
   929 00:C4CB: 20 60 C5     dlt1    jsr     setone          ;point to fcb
   930 00:C4CE: A2 13        dltfil  ldx     #19             ;delete file
   931 00:C4D0: 80 16                bra     pemgo
   932 00:C4D2: A2 14        rdrcrd  ldx     #20             ;read record
   933 00:C4D4: 80 12                bra     pemgo
   934 00:C4D6: A2 15        wrrcrd  ldx     #21             ;write record
   935 00:C4D8: 80 0E                bra     pemgo
   936 00:C4DA: A2 16        cratfl  ldx     #22             ;create file
   937 00:C4DC: 80 0A                bra     pemgo
   938 00:C4DE: A2 17        renmfl  ldx     #23             ;rename file
  Thu Apr 29 2021  3:45                                                                                                    Page 16


   939 00:C4E0: 80 06                bra     pemgo
   940 00:C4E2: A2 19        intdsk  ldx     #25             ;read drive num
   941 00:C4E4: 80 02                bra     pemgo
   942 00:C4E6: A2 1A        setbuf  ldx     #26             ;set buffer add
   943 00:C4E8: 4C 03 01     pemgo   jmp     pemjmp          ;go to pem
   944                        ;restore default drive
   945 00:C4EB: AD CD 70     rstddr  lda     tmpdsk          ;if temp drive
   946 00:C4EE: F0 1C                beq     extddr          ;zero then exit
   947 00:C4F0: 38                   sec                     ;else
   948 00:C4F1: E9 01                sbc     #1              ;subtract one
   949 00:C4F3: CD CC 70             cmp     dfldsk          ;compare to default
   950 00:C4F6: F0 14                beq     extddr          ;exit if same
   951 00:C4F8: AD CC 70     seldfl  lda     dfldsk          ;else get default
   952 00:C4FB: 80 BA                bra     slctds          ;select
   953                        ;clear auto - select disk - open file at fcbone
   954 00:C4FD: 20 6A C6     casdo1  jsr     clrslt          ;clear auto and select
   955                        ;open file one
   956                        ; returns:n=1 if not found
   957 00:C500: 9C A5 70     open1   stz     fcbone+32       ;clear record number
   958 00:C503: 20 60 C5             jsr     setone          ;point to fcb
   959 00:C506: 20 BB C4             jsr     openfl          ;open it
   960 00:C509: 8D D1 70             sta     diradd          ;save number
   961 00:C50C: 60           extddr  rts
   962                        ;read file one
   963 00:C50D: 20 60 C5     read1   jsr     setone          ;point to fcb
   964 00:C510: 80 C0                bra     rdrcrd          ;do read
   965                        ;search for first file one
   966                        ; returns:n=1 if not found
   967 00:C512: 20 60 C5     srchf1  jsr     setone          ;point to fcb
   968 00:C515: 20 C3 C4             jsr     srchfr          ;search for first
   969 00:C518: 8D D1 70             sta     diradd          ;save number
   970 00:C51B: 60                   rts
   971                        ;header output
   972 00:C51C: 20 94 C4     hdrout  jsr     ccrlf           ;do cr lf
   973 00:C51F: 20 E2 C4     hdr     jsr     intdsk          ;get drive number
   974 00:C522: 18                   clc                     ;make
   975 00:C523: 69 41                adc     #'A'            ;a letter
   976 00:C525: 20 3B C5             jsr     cotsxy          ;send drive letter
   977                        ;drive letter is written now do user
   978 00:C528: 20 AF C3             jsr     getusr          ;get number
   979 00:C52B: C9 0A                cmp     #10             ;see if < 10
   980 00:C52D: 90 0A                bcc     usr09           ;if so use as is
   981 00:C52F: 48                   pha                     ;save number
   982 00:C530: A9 31                lda     #'1'            ;else send an ASCII 1
   983 00:C532: 20 3B C5             jsr     cotsxy          ;to console
   984 00:C535: 68                   pla                     ;get number back
   985 00:C536: 38                   sec                     ;drop by 10
   986 00:C537: E9 0A                sbc     #10             ;and get remainder
   987 00:C539: 09 30        usr09   ora     #'0'            ;make ASCII
   988                        ;
   989                        ;drop in to cotsxy
   990                        ;
   991                        ;output with save of x and y
   992                        ;this routine calls the pem resident routine
   993                        ;tstchr to see if a char is a printing char.
   994                        ;if it is then c=1 upon return from tstchr.
   995 00:C53B: 8E D2 70     cotsxy  stx     savx            ;save x
   996 00:C53E: 8C D3 70             sty     savy            ;and y
   997 00:C541: 20 52 D0             jsr     tstchr          ;see if printing
   998 00:C544: B0 10                bcs     isprnt          ;jump if is
   999 00:C546: 48                   pha                     ;else save
  1000 00:C547: AD BB 71             lda     sysdef+4        ;get invert
  1001 00:C54A: 20 A7 C4             jsr     chrout          ;send it
  Thu Apr 29 2021  3:45                                                                                                    Page 17


  1002 00:C54D: 68                   pla                     ;get char
  1003 00:C54E: 09 40                ora     #'@'            ;make printing
  1004 00:C550: 20 A7 C4             jsr     chrout          ;send it
  1005 00:C553: AD BA 71             lda     sysdef+3        ;get normal
  1006 00:C556: 20 A7 C4     isprnt  jsr     chrout          ;do output
  1007 00:C559: AC D3 70             ldy     savy            ;get y
  1008 00:C55C: AE D2 70             ldx     savx            ;and x
  1009 00:C55F: 60                   rts
  1010                        ;set up fcb one pointer
  1011 00:C560: A9 85        setone  lda     #<fcbone        ;low
  1012 00:C562: A0 70                ldy     #>fcbone        ;and high
  1013 00:C564: 60                   rts
  1014                        ;save tmpdsk in oldtmp
  1015 00:C565: AD CD 70     tmpold  lda     tmpdsk
  1016 00:C568: 8D D5 70             sta     oldtmp
  1017 00:C56B: 60                   rts
  1018                        ;parse command line
  1019 00:C56C: A2 00        prslin  ldx     #0              ;clear index
  1020 00:C56E: DA           prsmre  phx                     ;save index
  1021 00:C56F: 9C CD 70             stz     tmpdsk          ;clear temp drive flag
  1022 00:C572: AC CB 70             ldy     cnbfpt          ;get buffer pointer
  1023 00:C575: 20 31 C6             jsr     skpspc          ;find first non-space
  1024 00:C578: 8C D0 70             sty     curpnt          ;save index
  1025 00:C57B: F0 0D                beq     nulchr          ;jump if null
  1026 00:C57D: 29 0F                and     #%00001111      ;else look at 4 lsbs
  1027 00:C57F: 48                   pha                     ;and save
  1028 00:C580: C8                   iny                     ;point to next char
  1029 00:C581: B9 05 70             lda     cnstxt,y        ;and get it
  1030 00:C584: C9 3A                cmp     #':'            ;if a colon
  1031 00:C586: F0 0A                beq     drvinp          ;jump and set drive
  1032 00:C588: 68                   pla                     ;else clear stack
  1033 00:C589: 88                   dey                     ;backup index
  1034 00:C58A: AD CC 70     nulchr  lda     dfldsk          ;set automatic
  1035 00:C58D: 9D 85 70             sta     fcbone,x        ;to default
  1036 00:C590: 10 08                bpl     trynme          ;then parse name
  1037 00:C592: 68           drvinp  pla                     ;get number
  1038 00:C593: 8D CD 70             sta     tmpdsk          ;set temp flag
  1039 00:C596: 9D 85 70             sta     fcbone,x        ;and fcb
  1040 00:C599: C8                   iny                     ;point past colon
  1041 00:C59A: A9 08        trynme  lda     #8              ;set name count
  1042 00:C59C: 8D CF 70             sta     count           ;to eight
  1043 00:C59F: 20 3E C6     tstnme  jsr     tstlgl          ;test for illegal
  1044 00:C5A2: F0 1D                beq     flnmsp          ;if illegal jump
  1045 00:C5A4: E8                   inx                     ;bump pointer
  1046 00:C5A5: C9 2A                cmp     #'*'            ;if not *
  1047 00:C5A7: D0 07                bne     notafn          ;skip ? fill
  1048 00:C5A9: A9 3F                lda     #'?'            ;get a ?
  1049 00:C5AB: 9D 85 70             sta     fcbone,x        ;store
  1050 00:C5AE: 80 04                bra     nxtout          ;and jump
  1051 00:C5B0: 9D 85 70     notafn  sta     fcbone,x        ;store char
  1052 00:C5B3: C8                   iny                     ;bump source
  1053 00:C5B4: CE CF 70     nxtout  dec     count           ;drop counter down
  1054 00:C5B7: D0 E6                bne     tstnme          ;and loop
  1055 00:C5B9: 20 3E C6     skpmre  jsr     tstlgl          ;if illegal
  1056 00:C5BC: F0 11                beq     trytyp          ;try type
  1057 00:C5BE: C8                   iny                     ;else bump index
  1058 00:C5BF: D0 F8                bne     skpmre          ;and loop
  1059 00:C5C1: E8           flnmsp  inx                     ;next position
  1060 00:C5C2: A9 20                lda     #' '            ;get a space
  1061 00:C5C4: 9D 85 70             sta     fcbone,x        ;store
  1062 00:C5C7: CE CF 70             dec     count           ;count down
  1063 00:C5CA: D0 F5                bne     flnmsp          ;and loop
  1064 00:C5CC: B9 05 70             lda     cnstxt,y        ;get char again
  Thu Apr 29 2021  3:45                                                                                                    Page 18


  1065 00:C5CF: 48           trytyp  pha                     ;save char
  1066 00:C5D0: A9 03                lda     #3              ;set count
  1067 00:C5D2: 8D CF 70             sta     count           ;to three
  1068 00:C5D5: 68                   pla                     ;get char
  1069 00:C5D6: C9 2E                cmp     #'.'            ;if not .
  1070 00:C5D8: D0 23                bne     fltysp          ;then fill spaces
  1071 00:C5DA: C8                   iny                     ;else bump source
  1072 00:C5DB: 20 3E C6     tsttyp  jsr     tstlgl          ;if not legal
  1073 00:C5DE: F0 1D                beq     fltysp          ;then fill spaces
  1074 00:C5E0: E8                   inx                     ;else bump index
  1075 00:C5E1: C9 2A                cmp     #'*'            ;if not *
  1076 00:C5E3: D0 07                bne     notaft          ;then skip fill
  1077 00:C5E5: A9 3F                lda     #'?'            ;else get ?
  1078 00:C5E7: 9D 85 70             sta     fcbone,x        ;move to fcb
  1079 00:C5EA: D0 04                bne     mrtyfl          ;and loop
  1080 00:C5EC: 9D 85 70     notaft  sta     fcbone,x        ;move char to fcb
  1081 00:C5EF: C8                   iny                     ;bump source
  1082 00:C5F0: CE CF 70     mrtyfl  dec     count           ;count down
  1083 00:C5F3: D0 E6                bne     tsttyp          ;and loop
  1084 00:C5F5: 20 3E C6     nttype  jsr     tstlgl          ;if illegal
  1085 00:C5F8: F0 0E                beq     filnul          ;fill out nulls
  1086 00:C5FA: C8                   iny                     ;else bump source
  1087 00:C5FB: D0 F8                bne     nttype          ;and loop
  1088 00:C5FD: E8           fltysp  inx                     ;bump fcb pointer
  1089 00:C5FE: A9 20                lda     #' '            ;get space
  1090 00:C600: 9D 85 70             sta     fcbone,x        ;put in fcb
  1091 00:C603: CE CF 70             dec     count           ;count down
  1092 00:C606: D0 F5                bne     fltysp          ;and continue
  1093 00:C608: A9 03        filnul  lda     #3              ;clear
  1094 00:C60A: 8D CF 70             sta     count           ;three
  1095 00:C60D: E8           mrnlty  inx                     ;bump fcb pointer
  1096 00:C60E: 9E 85 70             stz     fcbone,x        ;clear fcb
  1097 00:C611: CE CF 70             dec     count           ;count down
  1098 00:C614: D0 F7                bne     mrnlty          ;loop until done
  1099 00:C616: 8C CB 70             sty     cnbfpt          ;update start pointer
  1100 00:C619: 9C CF 70             stz     count           ;clear count
  1101 00:C61C: 7A                   ply                     ;restore stack
  1102 00:C61D: A2 0B                ldx     #11             ;counter to 11
  1103 00:C61F: C8           tstqus  iny                     ;point to
  1104 00:C620: B9 85 70             lda     fcbone,y        ;and get char
  1105 00:C623: C9 3F                cmp     #'?'            ;if not a ?
  1106 00:C625: D0 03                bne     nxtqus          ;then jump
  1107 00:C627: EE CF 70             inc     count           ;else bump count
  1108 00:C62A: CA           nxtqus  dex                     ;loop until
  1109 00:C62B: D0 F2                bne     tstqus          ;11 tested
  1110 00:C62D: AD CF 70             lda     count           ;get count
  1111 00:C630: 60                   rts                     ;and return
  1112                        ;skip space
  1113 00:C631: B9 05 70     skpspc  lda     cnstxt,y        ;get char
  1114 00:C634: F0 07                beq     extskp          ;jump if null
  1115 00:C636: C9 20                cmp     #' '            ;if not space
  1116 00:C638: D0 03                bne     extskp          ;then exit
  1117 00:C63A: C8                   iny                     ;else go to next
  1118 00:C63B: D0 F4                bne     skpspc          ;and test
  1119 00:C63D: 60           extskp  rts
  1120                        ;test legal
  1121 00:C63E: B9 05 70     tstlgl  lda     cnstxt,y        ;get char
  1122 00:C641: F0 1C                beq     extlgl
  1123 00:C643: C9 20                cmp     #' '            ;if space
  1124 00:C645: 90 19                bcc     badinp          ;ok - less is error
  1125 00:C647: F0 16                beq     extlgl
  1126 00:C649: C9 3D                cmp     #'='
  1127 00:C64B: F0 12                beq     extlgl
  Thu Apr 29 2021  3:45                                                                                                    Page 19


  1128 00:C64D: C9 2E                cmp     #'.'
  1129 00:C64F: F0 0E                beq     extlgl
  1130 00:C651: C9 3A                cmp     #':'
  1131 00:C653: F0 0A                beq     extlgl
  1132 00:C655: C9 3B                cmp     #semico
  1133 00:C657: F0 06                beq     extlgl
  1134 00:C659: C9 3C                cmp     #'<'
  1135 00:C65B: F0 02                beq     extlgl
  1136 00:C65D: C9 3E                cmp     #'>'
  1137 00:C65F: 60           extlgl  rts
  1138 00:C660: 4C 56 C1     badinp  jmp     cmderr
  1139                        ;set default buffer address
  1140 00:C663: A9 28        stdflb  lda     #<dflbuf        ;point to
  1141 00:C665: A0 01                ldy     #>dflbuf        ;location
  1142 00:C667: 4C E6 C4             jmp     setbuf          ;and set
  1143                        ;clear automatic and select
  1144 00:C66A: 9C 85 70     clrslt  stz     fcbone          ;clear auto select
  1145 00:C66D: AD CD 70     slttmp  lda     tmpdsk          ;get temp
  1146 00:C670: F0 1F                beq     extsnd          ;if zero exit
  1147 00:C672: 38                   sec                     ;else subtract
  1148 00:C673: E9 01                sbc     #1              ;one
  1149 00:C675: CD CC 70             cmp     dfldsk          ;if same as default
  1150 00:C678: F0 17                beq     extsnd          ;then quit
  1151 00:C67A: 4C B7 C4             jmp     slctds          ;else set
  1152                        ;send message
  1153 00:C67D: 8C D3 70     sndmsg  sty     savy            ;save index
  1154 00:C680: 20 94 C4             jsr     ccrlf           ;do cr and lf
  1155 00:C683: AC D3 70             ldy     savy            ;get index
  1156 00:C686: B9 59 C7     lpesnd  lda     msgtbl,y        ;get char
  1157 00:C689: F0 06                beq     extsnd          ;if null quit
  1158 00:C68B: 20 3B C5             jsr     cotsxy          ;else send
  1159 00:C68E: C8                   iny                     ;point to next
  1160 00:C68F: D0 F5                bne     lpesnd          ;and loop
  1161 00:C691: 60           extsnd  rts
  1162                        ;set load start address
  1163 00:C692: A9 00        setddb  lda     #<tea           ;to tea start
  1164 00:C694: A0 08                ldy     #>tea
  1165 00:C696: 8D D6 70     setdb   sta     dskbuf          ;to ay
  1166 00:C699: 8C D7 70             sty     dskbuf+1
  1167 00:C69C: 60                   rts
  1168                        ;move first part of fcb to second half
  1169                        ;and move second part to first part.
  1170                        ;only ren depends upon this routine to actually
  1171                        ;swap fcb halves.
  1172                        ;alters:a,x,p
  1173                        ;returns:x=$ff
  1174 00:C69D: A2 0F        frssec  ldx     #15             ;set index to last
  1175 00:C69F: BD 85 70     frsclp  lda     fcbone,x        ;get byte
  1176 00:C6A2: BC 95 70             ldy     fcbone+16,x
  1177 00:C6A5: 9D 95 70             sta     fcbone+16,x     ;move it
  1178 00:C6A8: 98                   tya
  1179 00:C6A9: 9D 85 70             sta     fcbone,x
  1180 00:C6AC: CA                   dex
  1181 00:C6AD: 10 F0                bpl     frsclp          ;until 16 moved
  1182 00:C6AF: 60                   rts
  1183                        ;move second part of fcb to first half
  1184                        ;restore tmpdsk from save location
  1185                        ;alters:a,x,p
  1186                        ;returns:x=$ff
  1187 00:C6B0: A2 0F        secfrs  ldx     #15             ;set index to last
  1188 00:C6B2: BD 95 70     scfrlp  lda     fcbone+16,x     ;get byte
  1189 00:C6B5: 9D 85 70             sta     fcbone,x        ;move it
  1190 00:C6B8: CA                   dex
  Thu Apr 29 2021  3:45                                                                                                    Page 20


  1191 00:C6B9: 10 F7                bpl     scfrlp          ;loop until done
  1192 00:C6BB: AD D5 70             lda     oldtmp          ;get old flag
  1193 00:C6BE: 8D CD 70             sta     tmpdsk          ;and set
  1194 00:C6C1: 60                   rts
  1195                        ;build a number from command line and leave in num
  1196                        ;will handle either decimal (e.g., 578) or hexadecimal (e.g., $3f2)
  1197                        ;move parse index past number
  1198                        ;modifies:all
  1199                        ;returns:a,y set to low and high of number
  1200                        ;        flags set according to y which is high part of number
  1201 00:C6C2: A9 09        bldnum  lda     #9              ;preset to decimal
  1202 00:C6C4: 8D D9 70             sta     moduls
  1203 00:C6C7: 20 6C C5             jsr     prslin          ;put in fcb
  1204 00:C6CA: AD CD 70             lda     tmpdsk          ;if temp
  1205 00:C6CD: D0 67                bne     numerr          ;is error
  1206 00:C6CF: 8D DA 70             sta     num             ;else clear num
  1207 00:C6D2: 8D DB 70             sta     num+1
  1208 00:C6D5: A8                   tay                     ;and index
  1209 00:C6D6: B9 86 70             lda     fcbone+1,y      ;get first char
  1210 00:C6D9: C9 24                cmp     #'$'            ;see if hex signal
  1211 00:C6DB: D0 06                bne     bnumlp          ;skip if not
  1212 00:C6DD: A9 0F                lda     #15             ;set for modulus
  1213 00:C6DF: 8D D9 70             sta     moduls
  1214 00:C6E2: C8                   iny                     ;bump past $
  1215 00:C6E3: C8           bnumlp  iny                     ;next char
  1216 00:C6E4: B9 85 70             lda     fcbone,y        ;get digit
  1217 00:C6E7: C9 20                cmp     #' '            ;see if space
  1218 00:C6E9: F0 4E                beq     endnlp          ;done if is
  1219 00:C6EB: 20 26 D2             jsr     tstdec          ;see if decimal
  1220 00:C6EE: 90 0E                bcc     usedig          ;use if is
  1221 00:C6F0: 20 30 D2             jsr     tsthex          ;see if hex
  1222 00:C6F3: B0 41                bcs     numerr          ;error if not
  1223 00:C6F5: E9 06                sbc     #6              ;remove offset
  1224 00:C6F7: A2 0F                ldx     #15             ;test for hex modulus
  1225 00:C6F9: EC D9 70             cpx     moduls
  1226 00:C6FC: D0 38                bne     numerr          ;error if not
  1227 00:C6FE: 29 0F        usedig  and     #%00001111      ;eliminate ascii bias
  1228 00:C700: 48                   pha                     ;save result
  1229 00:C701: AD DA 70             lda     num             ;move number to temp
  1230 00:C704: 8D DC 70             sta     tnum
  1231 00:C707: AD DB 70             lda     num+1
  1232 00:C70A: 8D DD 70             sta     tnum+1
  1233 00:C70D: AE D9 70             ldx     moduls          ;get modulus
  1234 00:C710: 18                   clc
  1235 00:C711: AD DA 70     addlpe  lda     num             ;add number to itself
  1236 00:C714: 6D DC 70             adc     tnum
  1237 00:C717: 8D DA 70             sta     num
  1238 00:C71A: AD DB 70             lda     num+1           ;modulus times
  1239 00:C71D: 6D DD 70             adc     tnum+1
  1240 00:C720: 8D DB 70             sta     num+1
  1241 00:C723: B0 11                bcs     numerr          ;error if carry out
  1242 00:C725: CA                   dex
  1243 00:C726: D0 E9                bne     addlpe          ;loop if more
  1244 00:C728: 68                   pla                     ;get input back
  1245 00:C729: 6D DA 70             adc     num             ;add in
  1246 00:C72C: 8D DA 70             sta     num
  1247 00:C72F: 90 B2                bcc     bnumlp          ;loop if no carry
  1248 00:C731: EE DB 70             inc     num+1           ;else bump high
  1249 00:C734: D0 AD                bne     bnumlp          ;and loop for more
  1250                        ;error in bldnum - handle and quit
  1251 00:C736: 4C 56 C1     numerr  jmp     cmderr          ;do general error
  1252                        ;end of use of name part - check type
  1253 00:C739: AD 8E 70     endnlp  lda     fcbone+9        ;get first
  Thu Apr 29 2021  3:45                                                                                                    Page 21


  1254 00:C73C: C9 20                cmp     #' '            ;see if space
  1255 00:C73E: D0 F6                bne     numerr          ;error if not
  1256 00:C740: AD DA 70             lda     num             ;return with result
  1257 00:C743: AC DB 70             ldy     num+1
  1258 00:C746: 60                   rts
  1259                        ;function entry vector table
  1260 00:C747: 72 C1        xqfntb  .dw     dir
  1261 00:C749: 4C C2                .dw     save
  1262 00:C74B: E7 C2                .dw     era
  1263 00:C74D: 07 C3                .dw     type
  1264 00:C74F: EA C1                .dw     ren
  1265 00:C751: 82 C3                .dw     go
  1266 00:C753: 47 C3                .dw     load
  1267 00:C755: 92 C3                .dw     user
  1268 00:C757: C4 C3                .dw     trns
  1269                        ;Messages
  1270                        msgtbl
  1271                        ;
  1272             00000000   nospms  equ     *-msgtbl
  1273 00:C759: 4E 4F 20 53          byte    "NO SPACE",0
       00:C75D: 50 41 43 45 
       00:C761: 00 
  1274             00000009   ntclms  equ     *-msgtbl
  1275 00:C762: 43 41 4E 20          byte    "CAN NOT CLOSE",0
       00:C766: 4E 4F 54 20 
       00:C76A: 43 4C 4F 53 
       00:C76E: 45 00 
  1276             00000017   alflms  equ     *-msgtbl
  1277 00:C770: 41 4C 4C 20          byte    "ALL FILES (Y/N)?",0
       00:C774: 46 49 4C 45 
       00:C778: 53 20 28 59 
       00:C77C: 2F 4E 29 3F 
       00:C780: 00 
  1278             00000028   rderms  equ     *-msgtbl
  1279 00:C781: 52 45 41 44          byte    "READ ERROR",0
       00:C785: 20 45 52 52 
       00:C789: 4F 52 00 
  1280             00000033   ntfnms  equ     *-msgtbl
  1281 00:C78C: 4E 4F 54 20          byte    "NOT FOUND",0
       00:C790: 46 4F 55 4E 
       00:C794: 44 00 
  1282             0000003D   flexms  equ     *-msgtbl
  1283 00:C796: 46 49 4C 45          byte    "FILE EXISTS",0
       00:C79A: 20 45 58 49 
       00:C79E: 53 54 53 00 
  1284             00000049   lderms  equ     *-msgtbl
  1285 00:C7A2: 4C 4F 41 44          byte    "LOAD ERROR",0
       00:C7A6: 20 45 52 52 
       00:C7AA: 4F 52 00 
  1286             00000054   cnnoms  equ     *-msgtbl
  1287 00:C7AD: 43 41 4E 20          byte    "CAN NOT OPEN",0
       00:C7B1: 4E 4F 54 20 
       00:C7B5: 4F 50 45 4E 
       00:C7B9: 00 
  1288             00000061   wrerms  equ     *-msgtbl
  1289 00:C7BA: 57 52 49 54          byte    "WRITE ERROR",0
       00:C7BE: 45 20 45 52 
       00:C7C2: 52 4F 52 00 
  1290             0000006D   userms  equ     *-msgtbl
  1291 00:C7C6: 49 4E 56 41          byte    "INVALID USER",0
       00:C7CA: 4C 49 44 20 
       00:C7CE: 55 53 45 52 
       00:C7D2: 00 
  Thu Apr 29 2021  3:45                                                                                                    Page 22


  1292                        ;Function name table
  1293                        fnctbl
  1294 00:C7D3: 44 49 52 20          byte    "DIR ",0
       00:C7D7: 00 
  1295 00:C7D8: 53 41 56 45          byte    "SAVE ",0
       00:C7DC: 20 00 
  1296 00:C7DE: 45 52 41 20          byte    "ERA ",0
       00:C7E2: 00 
  1297 00:C7E3: 54 59 50 45          byte    "TYPE ",0
       00:C7E7: 20 00 
  1298 00:C7E9: 52 45 4E 20          byte    "REN ",0
       00:C7ED: 00 
  1299 00:C7EE: 47 4F 20 00          byte    "GO ",0
  1300 00:C7F2: 4C 4F 41 44          byte    "LOAD ",0
       00:C7F6: 20 00 
  1301 00:C7F8: 55 53 45 52          byte    "USER ",0
       00:C7FC: 20 00 
  1302                        
  1303                                org     $/256*256+256
  1304                        ;---------------------------------------
  1305                        ;DOS/65 Primitive Execution Module (pem)
  1306                        ;---------------------------------------
  1307                        ;main program
  1308                        ; input:x=command,a=value,a&y=address
  1309                        ; returns:a=value,a&y=address
  1310                        ; alters:all
  1311 00:C800: D8           pem     cld                     ;set binary mode
  1312 00:C801: 85 80                sta     addinp          ;value and
  1313 00:C803: 84 81                sty     addinp+1        ;address
  1314 00:C805: 8E 0D 71             stx     cmdinp          ;and command
  1315 00:C808: E0 25                cpx     #numcmd         ;if invalid
  1316 00:C80A: B0 35                bcs     noswot          ;then exit without switch
  1317 00:C80C: 9C 12 71             stz     tmpdrv          ;clear switch flag
  1318 00:C80F: AD 0D 71             lda     cmdinp          ;get command
  1319 00:C812: 0A                   asl     a               ;multiply by two
  1320 00:C813: AA                   tax                     ;and make a pointer
  1321 00:C814: A5 80                lda     addinp          ;get input value
  1322 00:C816: A4 81                ldy     addinp+1
  1323 00:C818: 20 48 C8             jsr     cmd_exe         ;call execute command
  1324                        ;The next line is the exit entry location for
  1325                        ;all PEM function calls.
  1326 00:C81B: 8D 0E 71     extexq  sta     bytout          ;save value
  1327 00:C81E: 8C 0F 71             sty     addout+1        ;and address
  1328                        ;First step is to restore original drive
  1329 00:C821: AD 12 71             lda     tmpdrv          ;see if temp drive flag set
  1330 00:C824: F0 09                beq     notmpd          ;no so skip following
  1331 00:C826: AD 1A 71             lda     olddrv          ;get original number
  1332 00:C829: 8D 03 71             sta     drvcmd          ;set up like input
  1333 00:C82C: 20 DB CA             jsr     chgdrv          ;change drive back
  1334                        ;At this point OLDDRV is mapped with USRCDE in
  1335                        ;byte 0 of FCB. Now clear that byte and restore
  1336                        ;original drive designator.
  1337 00:C82F: AD 04 71     notmpd  lda     drvflg          ;get drive flag
  1338 00:C832: F0 0D                beq     skptmp          ;skip ahead if zero
  1339 00:C834: A0 00                ldy     #0              ;clear index
  1340 00:C836: 9C 04 71             stz     drvflg          ;clear flag
  1341 00:C839: AD 12 71             lda     tmpdrv          ;get temp drive
  1342 00:C83C: 91 80                sta     (addinp),y      ;put back in fcb
  1343 00:C83E: 9C 12 71             stz     tmpdrv          ;clear flag
  1344                        skptmp
  1345 00:C841: AC 0F 71     noswot  ldy     addout+1        ;get address
  1346 00:C844: AD 0E 71             lda     bytout          ;and value (address low)
  1347 00:C847: 60                   rts
  Thu Apr 29 2021  3:45                                                                                                    Page 23


  1348 00:C848: 7C 4B C8     cmd_exe jmp     (cmdtbl,x)      ;execute command
  1349                        ;command vector table
  1350 00:C84B: A8 C8        cmdtbl  .dw     xwboot          ;warm boot (x=0)
  1351 00:C84D: 96 CA                .dw     xcnsin          ;console input with echo (x=1)
  1352 00:C84F: A6 D0                .dw     sndchr          ;console output (x=2)
  1353 00:C851: 95 71                .dw     simram+21       ;tape reader (x=3)
  1354 00:C853: 92 71                .dw     simram+18       ;tape punch (x=4)
  1355 00:C855: 8F 71                .dw     simram+15       ;printer output (x=5)
  1356 00:C857: 21 D0                .dw     getcon          ;console input w/o echo (x=6)
  1357 00:C859: DB C8                .dw     xgtios          ;read i/o status (x=7)
  1358 00:C85B: E6 C8                .dw     xstios          ;set i/o status (x=8)
  1359 00:C85D: 61 D0                .dw     sndstr          ;print buffer (x=9)
  1360 00:C85F: 0F D1                .dw     bufinp          ;read buffer (x=10)
  1361 00:C861: 2C D0                .dw     kbdsts          ;test console ready (x=11)
  1362 00:C863: AD 71                .dw     simram+45       ;read list status (x=12)
  1363 00:C865: E8 CA                .dw     xintds          ;initialize system (x=13)
  1364 00:C867: D6 CA                .dw     xchgdr          ;log in drive (x=14)
  1365 00:C869: 56 CD                .dw     xopen           ;open file (x=15)
  1366 00:C86B: 91 CD                .dw     xclose          ;close file (x=16)
  1367 00:C86D: B5 CD                .dw     xfndfr          ;find first match (x=17)
  1368 00:C86F: F6 C8                .dw     xfndnx          ;find next match (x=18)
  1369 00:C871: 60 C9                .dw     xdltfl          ;delete file (x=19)
  1370 00:C873: FE C8                .dw     xread           ;read record (x=20)
  1371 00:C875: 85 C9                .dw     xwrite          ;write record (x=21)
  1372 00:C877: 58 CE                .dw     xmake           ;create file (x=22)
  1373 00:C879: 3C C9                .dw     xrenme          ;rename file (x=23)
  1374 00:C87B: EE C8                .dw     xintlg          ;interrogate log in status (x=24)
  1375 00:C87D: EA C8                .dw     xintdr          ;interrogate current drive (x=25)
  1376 00:C87F: A4 CA                .dw     chgdma          ;set buffer address (x=26)
  1377 00:C881: DF C8                .dw     xrdalv          ;read allocation map start (x=27)
  1378 00:C883: 14 CD                .dw     setron          ;set r/w status (x=28)
  1379 00:C885: F2 C8                .dw     xrdros          ;read r/w status (x=29)
  1380 00:C887: 95 C8                .dw     setlst          ;set list echo status (x=30)
  1381 00:C889: 99 C8                .dw     lststs          ;read list echo status (x=31)
  1382 00:C88B: B8 C8                .dw     xrtclo          ;read low clock (x=32)
  1383 00:C88D: CC C8                .dw     xrtchi          ;read high clock (x=33)
  1384 00:C88F: D6 C8                .dw     xrddcb          ;read dcb address (x=34)
  1385 00:C891: B3 71                .dw     simram+51       ;translate sector ((x=35)
  1386 00:C893: 9D C8                .dw     xgsusr          ; get or set user code (x=36)
  1387                        ;set list echo status
  1388 00:C895: 8D 0B 71     setlst  sta     lstflg          ;set flag
  1389 00:C898: 60                   rts
  1390                        ;read list echo status
  1391 00:C899: AD 0B 71     lststs  lda     lstflg          ;read flag
  1392 00:C89C: 60                   rts
  1393                        ;execute get or set user code
  1394 00:C89D: C9 FF        xgsusr  cmp     #255            ;see if request
  1395 00:C89F: F0 03                beq     rtnusr          ;is so get
  1396 00:C8A1: 8D 05 71             sta     usrcde          ;is set so
  1397 00:C8A4: AD 05 71     rtnusr  lda     usrcde          ;get code
  1398 00:C8A7: 60                   rts
  1399                        ;execute warm boot
  1400                        ; ***this command does not return to pem***
  1401                        ; ***instead it jumps to sim, resets    ***
  1402                        ; ***system and stack and jumps to ccm. ***
  1403 00:C8A8: AD 05 71     xwboot  lda     usrcde          ;get user code
  1404 00:C8AB: 0A                   asl     a               ;shift to high nibble
  1405 00:C8AC: 0A                   asl     a
  1406 00:C8AD: 0A                   asl     a
  1407 00:C8AE: 0A                   asl     a
  1408 00:C8AF: 0D 1B 71             ora     curdrv          ;add current drive
  1409 00:C8B2: 8D 06 01             sta     iostat          ;save for SIM
  1410 00:C8B5: 4C 83 71             jmp     simram+3        ;go to sim
  Thu Apr 29 2021  3:45                                                                                                    Page 24


  1411                        ;execute read real time clock
  1412 00:C8B8: 20 B0 71     xrtclo  jsr     simram+48       ;read clock
  1413 00:C8BB: 8D 36 71             sta     rtclk           ;save low
  1414 00:C8BE: 8C 37 71             sty     rtclk+1         ;middle
  1415 00:C8C1: 8E 38 71             stx     rtclk+2         ;high
  1416 00:C8C4: 8A                   txa
  1417 00:C8C5: 29 80                and     #%10000000      ;test for valid
  1418 00:C8C7: A8                   tay
  1419 00:C8C8: AD 36 71             lda     rtclk           ;get low
  1420 00:C8CB: 60                   rts
  1421                        ;execute read real time clock high
  1422 00:C8CC: AD 38 71     xrtchi  lda     rtclk+2         ;get high
  1423 00:C8CF: 29 7F                and     #%01111111      ;clear status
  1424 00:C8D1: A8                   tay
  1425 00:C8D2: AD 37 71             lda     rtclk+1         ;get middle
  1426 00:C8D5: 60                   rts
  1427                        ;execute read dcb address
  1428 00:C8D6: A5 8A        xrddcb  lda     dcbloc          ;get address
  1429 00:C8D8: A4 8B                ldy     dcbloc+1
  1430 00:C8DA: 60                   rts
  1431                        ;execute read i/o status
  1432 00:C8DB: AD 06 01     xgtios  lda     iostat          ;get status byte
  1433 00:C8DE: 60                   rts
  1434                        ;execute read allocation map starting address
  1435 00:C8DF: AD 45 71     xrdalv  lda     alcmap          ;get
  1436 00:C8E2: AC 46 71             ldy     alcmap+1        ;starting address
  1437 00:C8E5: 60                   rts                     ;then return
  1438                        ;execute set i/o status
  1439 00:C8E6: 8D 06 01     xstios  sta     iostat          ;set status
  1440 00:C8E9: 60                   rts
  1441                        ;execute interrogate current drive
  1442 00:C8EA: AD 1B 71     xintdr  lda     curdrv          ;get number
  1443 00:C8ED: 60                   rts
  1444                        ;execute read log in status
  1445 00:C8EE: AD 1C 71     xintlg  lda     lginvc          ;get status
  1446 00:C8F1: 60                   rts
  1447                        ;execute read read/write status
  1448 00:C8F2: AD 1D 71     xrdros  lda     ronlst          ;get status
  1449 00:C8F5: 60                   rts
  1450                        ;execute find next match
  1451 00:C8F6: 20 AF CA     xfndnx  jsr     autodr          ;auto drive select
  1452 00:C8F9: A9 0D                lda     #13             ;match including
  1453 00:C8FB: 4C C2 CD             jmp     search          ;extent
  1454                        ;execute read next record
  1455 00:C8FE: 20 AF CA     xread   jsr     autodr          ;auto drive select
  1456 00:C901: 20 36 CD             jsr     inrcct          ;initialize record counters
  1457 00:C904: AD 26 71             lda     nxtrec          ;if next record less
  1458 00:C907: CD 27 71             cmp     numrec          ;then number records
  1459 00:C90A: 90 13                bcc     tryrde          ;then try to read
  1460 00:C90C: C9 80                cmp     #128            ;but if not and
  1461 00:C90E: F0 03                beq     tryext          ;is max try to extend
  1462 00:C910: A9 01        rdeeof  lda     #1              ;else set eof
  1463 00:C912: 60                   rts                     ;code and return
  1464 00:C913: A2 01        tryext  ldx     #1              ;try for a read
  1465 00:C915: 20 92 CE             jsr     extend          ;file extension
  1466 00:C918: C9 00                cmp     #0              ;if not ok exit eof
  1467 00:C91A: D0 F4                bne     rdeeof          ;with jump back
  1468 00:C91C: 8D 26 71             sta     nxtrec          ;clear next record
  1469 00:C91F: 20 20 CF     tryrde  jsr     getblk          ;and get block
  1470 00:C922: AD 21 71             lda     blknum          ;if block not zero
  1471 00:C925: 0D 22 71             ora     blknum+1
  1472 00:C928: D0 03                bne     dorde           ;do the read
  1473 00:C92A: A9 02                lda     #2              ;else set unwritten
  Thu Apr 29 2021  3:45                                                                                                    Page 25


  1474 00:C92C: 60                   rts                     ;code and exit
  1475 00:C92D: 20 07 CE     dorde   jsr     calrcn          ;calculate record number
  1476 00:C930: 20 54 CC             jsr     sttrsc          ;set track and sector
  1477 00:C933: 20 D5 CF             jsr     rdesec          ;do sector read
  1478 00:C936: 20 45 CD             jsr     updtrc          ;update counters
  1479 00:C939: A9 00                lda     #0              ;return w/o error
  1480 00:C93B: 60           extrde  rts
  1481                        ;execute file rename
  1482 00:C93C: 20 AF CA     xrenme  jsr     autodr          ;automatic drive select
  1483 00:C93F: 20 B4 CF             jsr     tstron          ;test for r/o
  1484 00:C942: A9 0C                lda     #12             ;match name
  1485 00:C944: 20 BA CD             jsr     frstsr          ;and type
  1486 00:C947: 30 16                bmi     extren          ;exit if not found
  1487 00:C949: A0 00        doren   ldy     #0              ;copy user code from 0 to 16
  1488 00:C94B: B1 80                lda     (addinp),y
  1489 00:C94D: A0 10                ldy     #16             ;in new name
  1490 00:C94F: 91 80                sta     (addinp),y      ;part of fcb
  1491 00:C951: A9 0C                lda     #12             ;then move
  1492 00:C953: A2 10                ldx     #16             ;new name
  1493 00:C955: 20 27 CE             jsr     dirchg          ;to directory
  1494 00:C958: A9 0C                lda     #12             ;see if
  1495 00:C95A: 20 C2 CD             jsr     search          ;another match
  1496 00:C95D: 10 EA                bpl     doren           ;loop if found
  1497 00:C95F: 60           extren  rts                     ;number
  1498                        ;execute delete file
  1499 00:C960: 20 AF CA     xdltfl  jsr     autodr          ;automatic drive select
  1500 00:C963: 20 B4 CF             jsr     tstron          ;test for r/o
  1501 00:C966: A9 0C                lda     #12             ;match name
  1502 00:C968: 20 BA CD             jsr     frstsr          ;and type
  1503 00:C96B: 30 17                bmi     extdlt          ;done if not found
  1504 00:C96D: A2 00        dodlt   ldx     #0              ;else do a
  1505 00:C96F: 20 86 CF             jsr     mapdir          ;delete
  1506 00:C972: AC 20 71             ldy     subrec          ;then change
  1507 00:C975: AD BF D2             lda     empty           ;byte zero to
  1508 00:C978: 91 82                sta     (bufadd),y      ;empty code
  1509 00:C97A: 20 DA CF             jsr     updtck          ;then update directory
  1510 00:C97D: A9 0C                lda     #12             ;search
  1511 00:C97F: 20 C2 CD             jsr     search          ;for next
  1512 00:C982: 10 E9                bpl     dodlt           ;loop if found
  1513 00:C984: 60           extdlt  rts                     ;exit
  1514                        ;execute write next record
  1515 00:C985: 20 AF CA     xwrite  jsr     autodr          ;automatic drive select
  1516 00:C988: 20 B4 CF             jsr     tstron          ;test for r/o
  1517 00:C98B: 20 36 CD             jsr     inrcct          ;initialize counters
  1518 00:C98E: AD 26 71             lda     nxtrec          ;get next record
  1519 00:C991: C9 80                cmp     #128            ;compare to max
  1520 00:C993: 90 03                bcc     ntexte          ;continue if less
  1521 00:C995: A9 01                lda     #1              ;else flag as extend
  1522 00:C997: 60                   rts                     ;error and exit
  1523 00:C998: 20 20 CF     ntexte  jsr     getblk          ;calculate block num
  1524 00:C99B: 9C 4A 71             stz     wrtype          ;set normal write for now
  1525 00:C99E: AD 21 71             lda     blknum          ;get it and if
  1526 00:C9A1: 0D 22 71             ora     blknum+1
  1527 00:C9A4: F0 03                beq     ?E2             ;zero then get number
  1528 00:C9A6: 4C 65 CA             jmp     blkopn          ;else go write
  1529 00:C9A9: A9 02        ?E2     lda     #2              ;say unalloc write
  1530 00:C9AB: 8D 4A 71             sta     wrtype
  1531 00:C9AE: AD 07 71             lda     fcbind          ;get index from prior
  1532 00:C9B1: 48                   pha                     ;and save
  1533 00:C9B2: C9 10                cmp     #16             ;if first block
  1534 00:C9B4: F0 1A                beq     isfrst          ;then don't change
  1535 00:C9B6: A8                   tay                     ;else make an index
  1536 00:C9B7: 88                   dey                     ;point to last
  Thu Apr 29 2021  3:45                                                                                                    Page 26


  1537 00:C9B8: 2C 31 71             bit     blmode          ;test mode
  1538 00:C9BB: 10 01                bpl     ?P2             ;done if byte
  1539 00:C9BD: 88                   dey                     ;else drop for word
  1540 00:C9BE: B1 80        ?P2     lda     (addinp),y      ;and get that number
  1541 00:C9C0: 8D 21 71             sta     blknum          ;store as starting
  1542 00:C9C3: C8                   iny                     ;bump for word
  1543 00:C9C4: A9 00                lda     #0              ;preset for byte
  1544 00:C9C6: 2C 31 71             bit     blmode          ;test mode
  1545 00:C9C9: 10 02                bpl     ?P3             ;done if byte
  1546 00:C9CB: B1 80                lda     (addinp),y      ;else get high
  1547 00:C9CD: 8D 22 71     ?P3     sta     blknum+1        ;then set high
  1548 00:C9D0: AD 21 71     isfrst  lda     blknum          ;get block
  1549 00:C9D3: 8D 16 71             sta     lkdown          ;set lower and
  1550 00:C9D6: 8D 18 71             sta     lookup          ;upper pointers
  1551 00:C9D9: AD 22 71             lda     blknum+1        ;now set high part
  1552 00:C9DC: 8D 17 71             sta     lkdown+1
  1553 00:C9DF: 8D 19 71             sta     lookup+1
  1554 00:C9E2: AD 18 71     srblag  lda     lookup          ;if upper pointer
  1555 00:C9E5: CD 3C 71             cmp     maxblk          ;not at max
  1556 00:C9E8: D0 08                bne     upnemx          ;then keep going
  1557 00:C9EA: AC 19 71             ldy     lookup+1        ;now check high
  1558 00:C9ED: CC 3D 71             cpy     maxblk+1
  1559 00:C9F0: F0 12                beq     tstdwn          ;go test down
  1560 00:C9F2: EE 18 71     upnemx  inc     lookup          ;else bump upper
  1561 00:C9F5: D0 03                bne     ?N2
  1562 00:C9F7: EE 19 71             inc     lookup+1
  1563 00:C9FA: AD 16 71     ?N2     lda     lkdown          ;then if lower
  1564 00:C9FD: 0D 17 71             ora     lkdown+1
  1565 00:CA00: F0 18                beq     dotest          ;is zero start test
  1566 00:CA02: D0 0B                bne     dcdown          ;else drop lower
  1567 00:CA04: AD 16 71     tstdwn  lda     lkdown          ;if upper & lower at
  1568 00:CA07: 0D 17 71             ora     lkdown+1
  1569 00:CA0A: D0 03                bne     dcdown          ;drop if not zero
  1570 00:CA0C: A8                   tay                     ;also set y
  1571 00:CA0D: F0 2F                beq     extsbl          ;then exit
  1572 00:CA0F: AD 16 71     dcdown  lda     lkdown          ;drop lower
  1573 00:CA12: D0 03                bne     ?N2
  1574 00:CA14: CE 17 71             dec     lkdown+1
  1575 00:CA17: CE 16 71     ?N2     dec     lkdown
  1576 00:CA1A: AD 16 71     dotest  lda     lkdown          ;get lower
  1577 00:CA1D: AC 17 71             ldy     lkdown+1
  1578 00:CA20: 20 F8 CC             jsr     tstblk          ;and test
  1579 00:CA23: D0 08                bne     trylup          ;if full try upper
  1580 00:CA25: AD 16 71             lda     lkdown          ;else use lower
  1581 00:CA28: AC 17 71             ldy     lkdown+1
  1582 00:CA2B: 80 11                bra     extsbl          ;as result
  1583 00:CA2D: AD 18 71     trylup  lda     lookup          ;get upper
  1584 00:CA30: AC 19 71             ldy     lookup+1
  1585 00:CA33: 20 F8 CC             jsr     tstblk          ;if full
  1586 00:CA36: D0 AA                bne     srblag          ;then loop
  1587 00:CA38: AD 18 71             lda     lookup          ;else use upper
  1588 00:CA3B: AC 19 71             ldy     lookup+1
  1589 00:CA3E: 8D 21 71     extsbl  sta     blknum          ;then save number
  1590 00:CA41: 8C 22 71             sty     blknum+1
  1591 00:CA44: 0D 22 71             ora     blknum+1        ;see if zero
  1592 00:CA47: D0 04                bne     gtgood          ;then proceed
  1593 00:CA49: 68                   pla                     ;clear stack
  1594 00:CA4A: A9 02                lda     #2              ;set end
  1595 00:CA4C: 60                   rts                     ;of data return
  1596 00:CA4D: AD 21 71     gtgood  lda     blknum          ;get low again
  1597 00:CA50: 20 0C CD             jsr     setblk          ;set allocation map
  1598 00:CA53: 68                   pla                     ;get block
  1599 00:CA54: A8                   tay                     ;pointer back
  Thu Apr 29 2021  3:45                                                                                                    Page 27


  1600 00:CA55: AD 21 71             lda     blknum          ;get number
  1601 00:CA58: 91 80                sta     (addinp),y      ;and put in fcb
  1602 00:CA5A: AD 22 71             lda     blknum+1        ;get high
  1603 00:CA5D: C8                   iny
  1604 00:CA5E: 2C 31 71             bit     blmode          ;test mode
  1605 00:CA61: 10 02                bpl     blkopn          ;done if byte
  1606 00:CA63: 91 80                sta     (addinp),y      ;else set high
  1607 00:CA65: 20 07 CE     blkopn  jsr     calrcn          ;calculate record num
  1608 00:CA68: 20 54 CC             jsr     sttrsc          ;set track and sector
  1609 00:CA6B: 20 E3 CF             jsr     wrtsec          ;do write
  1610 00:CA6E: AE 26 71             ldx     nxtrec          ;get next record
  1611 00:CA71: EC 27 71             cpx     numrec          ;if less than max
  1612 00:CA74: 90 05                bcc     notful          ;then ok
  1613 00:CA76: E8                   inx                     ;else bump count
  1614 00:CA77: 8E 27 71             stx     numrec          ;and save
  1615 00:CA7A: CA                   dex                     ;back down
  1616 00:CA7B: E0 7F        notful  cpx     #127            ;if not at max
  1617 00:CA7D: D0 11                bne     noawex          ;skip extending
  1618 00:CA7F: 20 45 CD             jsr     updtrc          ;update record counters
  1619 00:CA82: A2 00                ldx     #0              ;do write
  1620 00:CA84: 20 92 CE             jsr     extend          ;file extension
  1621 00:CA87: C9 00                cmp     #0              ;if not ok
  1622 00:CA89: D0 0A                bne     extwrt          ;exit
  1623 00:CA8B: A9 FF                lda     #255            ;else start counter
  1624 00:CA8D: 8D 26 71             sta     nxtrec          ;at one short
  1625 00:CA90: 20 45 CD     noawex  jsr     updtrc          ;then update counters
  1626 00:CA93: A9 00                lda     #0              ;good return
  1627 00:CA95: 60           extwrt  rts                     ;exit
  1628                        ;execute console input
  1629 00:CA96: 20 21 D0     xcnsin  jsr     getcon          ;get input
  1630 00:CA99: 20 52 D0             jsr     tstchr          ;test it and
  1631 00:CA9C: 90 05                bcc     extxci          ;if control exit
  1632 00:CA9E: 48                   pha                     ;else save
  1633 00:CA9F: 20 A6 D0             jsr     sndchr          ;echo
  1634 00:CAA2: 68                   pla                     ;restore
  1635 00:CAA3: 60           extxci  rts                     ;return
  1636                        ;change dma address
  1637                        ; input:addinp=address
  1638                        ; returns:none
  1639                        ; alters:all
  1640 00:CAA4: A5 80        chgdma  lda     addinp          ;get low
  1641 00:CAA6: A4 81                ldy     addinp+1        ;and high address
  1642 00:CAA8: 85 82                sta     bufadd          ;then store
  1643 00:CAAA: 84 83                sty     bufadd+1        ;in address
  1644 00:CAAC: 4C A4 71             jmp     simram+36       ;then go to sim
  1645                        ;automatic drive select
  1646                        ; input:(addinp) 0=no change
  1647                        ; 1-8 or 'A'-'H' = change
  1648                        ; returns:none
  1649                        ; alters:all
  1650 00:CAAF: A0 00        autodr  ldy     #0              ;get
  1651 00:CAB1: B1 80                lda     (addinp),y      ;first byte of fcb
  1652 00:CAB3: F0 13                beq     qtatdr          ;if 0 skip drive set
  1653 00:CAB5: 38                   sec                     ;set carry for
  1654 00:CAB6: E9 01                sbc     #1              ;subtract one
  1655 00:CAB8: 29 07                and     #%00000111      ;look at three lsbs
  1656 00:CABA: 8D 03 71             sta     drvcmd          ;make parameter for CHGDRV
  1657 00:CABD: AD 1B 71             lda     curdrv          ;get current
  1658 00:CAC0: 8D 1A 71             sta     olddrv          ;and save
  1659 00:CAC3: B1 80                lda     (addinp),y      ;get fcb entry
  1660 00:CAC5: 8D 12 71             sta     tmpdrv          ;and save as flag
  1661 00:CAC8: AD 05 71     qtatdr  lda     usrcde          lget user code
  1662 00:CACB: 91 80                sta     (addinp),y      ;save in byte zero in fcb
  Thu Apr 29 2021  3:45                                                                                                    Page 28


  1663 00:CACD: 20 DB CA             jsr     chgdrv          ;change the drive
  1664 00:CAD0: A9 FF                lda     #255            ;set flag
  1665 00:CAD2: 8D 04 71             sta     drvflg
  1666 00:CAD5: 60           drvsme  rts
  1667                        ;change drive
  1668                        ; input:addinp
  1669                        ; returns:none
  1670                        ; alters:all
  1671 00:CAD6: A5 80        xchgdr  lda     addinp          ;get inout
  1672 00:CAD8: 8D 03 71             sta     drvcmd          ;and save
  1673 00:CADB: AD 03 71     chgdrv  lda     drvcmd          ;get input
  1674 00:CADE: CD 1B 71             cmp     curdrv          ;if same as current
  1675 00:CAE1: F0 F2                beq     drvsme          ;do nothing
  1676 00:CAE3: 8D 1B 71             sta     curdrv          ;else change current
  1677 00:CAE6: 80 0E                bra     mapdrv          ;then log it in
  1678                        ;drvsme  rts
  1679                        ;execute initialize system
  1680                        ; input:none
  1681                        ; returns:none
  1682                        ; alters:all,lginvc,bufadd
  1683 00:CAE8: 9C 1C 71     xintds  stz     lginvc          ;clear log in status
  1684 00:CAEB: A9 28                lda     #<dflbuf        ;get default buffer
  1685 00:CAED: A0 01                ldy     #>dflbuf        ;address
  1686 00:CAEF: 85 80                sta     addinp          ;and set up
  1687 00:CAF1: 84 81                sty     addinp+1        ;parameters
  1688 00:CAF3: 20 A4 CA             jsr     chgdma          ;change address
  1689                        ;log in drive and set pointers and maps
  1690                        ; input:curdrv
  1691                        ; returns:none
  1692                        ; alters:all
  1693                        ; patch fix - 11/03/2021
  1694                        ; a fix for invalid drive - loops endlessly showing
  1695                        ; PEM error. Fix is to load "crudrv" to "0" before
  1696                        ; jumping to xwboot. - KM
  1697 00:CAF6: AD 1B 71     mapdrv  lda     curdrv          ;if current drive
  1698 00:CAF9: C9 08                cmp     #8              ;is 0 to 7
  1699 00:CAFB: 90 10                bcc     vlddrv          ;then log it in
  1700 00:CAFD: 20 04 D0     drserr  jsr     errout          ;send error message
  1701 00:CB00: A9 AE                lda     #<sltmsg        ;point to
  1702 00:CB02: A0 D2                ldy     #>sltmsg        ;select message
  1703 00:CB04: 20 61 D0             jsr     sndstr          ;and send it
  1704 00:CB07: 9C 1B 71             stz     curdrv          ;reset current drive (*fix)
  1705 00:CB0A: 4C A8 C8             jmp     xwboot          ;and abort
  1706 00:CB0D: 20 9B 71     vlddrv  jsr     simram+27       ;go to sim to set
  1707 00:CB10: 85 8A                sta     dcbloc          ;save
  1708 00:CB12: 84 8B                sty     dcbloc+1
  1709 00:CB14: 05 8B                ora     dcbloc+1        ;see if invalid
  1710 00:CB16: F0 E5                beq     drserr          ;error if is
  1711                        ;capture dcb
  1712 00:CB18: A0 0D                ldy     #14-1           ;do 14 bytes
  1713 00:CB1A: B1 8A        cptdcb  lda     (dcbloc),y      ;get value from sim
  1714 00:CB1C: 99 3C 71             sta     dcb,y           ;store it
  1715 00:CB1F: 88                   dey
  1716 00:CB20: 10 F8                bpl     cptdcb          ;loop for more
  1717 00:CB22: AD 42 71             lda     blkscd          ;get block size code
  1718 00:CB25: A8                   tay                     ;save in y
  1719 00:CB26: 18                   clc
  1720 00:CB27: 69 03                adc     #3              ;convert to sxb
  1721 00:CB29: 8D 35 71             sta     sxb             ;and save
  1722 00:CB2C: B9 D3 D2             lda     sabtbl,y        ;get sab
  1723 00:CB2F: 8D 34 71             sta     sab             ;and set
  1724 00:CB32: AD 43 71             lda     maxdir          ;get max dir
  1725 00:CB35: 8D 32 71             sta     maxdrc          ;set max dir record
  Thu Apr 29 2021  3:45                                                                                                    Page 29


  1726 00:CB38: AD 44 71             lda     maxdir+1
  1727 00:CB3B: 4A                   lsr     a               ;divide by 4
  1728 00:CB3C: 6E 32 71             ror     maxdrc
  1729 00:CB3F: 4A                   lsr     a
  1730 00:CB40: 6E 32 71             ror     maxdrc
  1731 00:CB43: 8D 33 71             sta     maxdrc+1        ;then save high
  1732 00:CB46: 9C 31 71             stz     blmode          ;set byte mode
  1733 00:CB49: AD 3D 71             lda     maxblk+1        ;branch if max block
  1734 00:CB4C: F0 05                beq     ntm255          ;not over 255
  1735                        ;if y=0 when the following line is executed it means
  1736                        ;that the user has put an illegal combination into
  1737                        ;the disk definition table. may want to consider
  1738                        ;putting some error checking here in the future if
  1739                        ;there is space in pem.
  1740 00:CB4E: 88                   dey                     ;back up index
  1741 00:CB4F: 38                   sec                     ;else set mode to word
  1742 00:CB50: 6E 31 71             ror     blmode
  1743 00:CB53: B9 D0 D2     ntm255  lda     exmtbl,y        ;get extent mask
  1744 00:CB56: 8D 4B 71             sta     exm
  1745 00:CB59: 38                   sec                     ;now calculate cexm1f
  1746 00:CB5A: A9 1F                lda     #31
  1747 00:CB5C: F9 D0 D2             sbc     exmtbl,y
  1748 00:CB5F: 8D 4C 71             sta     cexm1f
  1749 00:CB62: AE 1B 71             ldx     curdrv          ;get drive as pointer
  1750 00:CB65: BD C8 D2             lda     bitmap,x        ;get bit
  1751 00:CB68: 2D 1C 71             and     lginvc          ;if logged in
  1752 00:CB6B: D0 0B                bne     extstm          ;then exit
  1753 00:CB6D: BD C8 D2             lda     bitmap,x        ;get bit back
  1754 00:CB70: 0D 1C 71             ora     lginvc          ;set in log-in
  1755 00:CB73: 8D 1C 71             sta     lginvc          ;and update
  1756 00:CB76: 80 01                bra     flinal          ;then fill in maps
  1757 00:CB78: 60           extstm  rts                     ;and return
  1758                        ;fill in allocation map
  1759 00:CB79: 20 C6 CF     flinal  jsr     setrw           ;set to read/write
  1760 00:CB7C: AD 3C 71             lda     maxblk          ;divide max block by
  1761 00:CB7F: 8D 39 71             sta     gpcnt           ;eight to get max
  1762 00:CB82: AD 3D 71             lda     maxblk+1
  1763 00:CB85: A2 03                ldx     #3
  1764 00:CB87: 4A           clcnab  lsr     a               ;use a for speed
  1765 00:CB88: 6E 39 71             ror     gpcnt
  1766 00:CB8B: CA                   dex
  1767 00:CB8C: D0 F9                bne     clcnab          ;loop if more
  1768 00:CB8E: 8D 3A 71             sta     gpcnt+1         ;save high
  1769 00:CB91: EE 39 71             inc     gpcnt           ;bump by one
  1770 00:CB94: D0 03                bne     *+5
  1771 00:CB96: EE 3A 71             inc     gpcnt+1         ;with carry
  1772 00:CB99: AD 45 71             lda     alcmap          ;get map start
  1773 00:CB9C: AC 46 71             ldy     alcmap+1
  1774 00:CB9F: 85 84                sta     alcpnt          ;set pointer to start
  1775 00:CBA1: 84 85                sty     alcpnt+1
  1776 00:CBA3: A0 00                ldy     #0              ;clear index
  1777 00:CBA5: A9 00        clraml  lda     #0              ;clear byte
  1778 00:CBA7: 91 84                sta     (alcpnt),y      ;put in map
  1779 00:CBA9: E6 84                inc     alcpnt          ;bump pointer
  1780 00:CBAB: D0 02                bne     *+4
  1781 00:CBAD: E6 85                inc     alcpnt+1        ;with carry
  1782 00:CBAF: AD 39 71             lda     gpcnt           ;get low of count
  1783 00:CBB2: D0 03                bne     *+5             ;skip if not zero
  1784 00:CBB4: CE 3A 71             dec     gpcnt+1         ;else drop high
  1785 00:CBB7: CE 39 71             dec     gpcnt           ;always drop low
  1786 00:CBBA: AD 39 71             lda     gpcnt           ;test for zero
  1787 00:CBBD: 0D 3A 71             ora     gpcnt+1
  1788 00:CBC0: D0 E3                bne     clraml          ;loop if more
  Thu Apr 29 2021  3:45                                                                                                    Page 30


  1789                        ;at this point complete map is cleared
  1790 00:CBC2: AD 32 71             lda     maxdrc          ;get low of max dir record
  1791 00:CBC5: 8D 39 71             sta     gpcnt
  1792 00:CBC8: AD 33 71             lda     maxdrc+1        ;high in a
  1793 00:CBCB: AE 35 71             ldx     sxb             ;set x according to block size
  1794 00:CBCE: 4A           clcmdb  lsr     a               ;do division
  1795 00:CBCF: 6E 39 71             ror     gpcnt
  1796 00:CBD2: CA                   dex
  1797 00:CBD3: D0 F9                bne     clcmdb          ;until x is zero
  1798 00:CBD5: 8D 3A 71             sta     gpcnt+1         ;set high
  1799 00:CBD8: EE 39 71             inc     gpcnt           ;then bump by one
  1800 00:CBDB: D0 03                bne     *+5
  1801 00:CBDD: EE 3A 71             inc     gpcnt+1
  1802 00:CBE0: 8E 21 71             stx     blknum          ;clear block number
  1803 00:CBE3: 8E 22 71             stx     blknum+1
  1804 00:CBE6: AD 21 71     fildal  lda     blknum          ;get block number
  1805 00:CBE9: AC 22 71             ldy     blknum+1
  1806 00:CBEC: 20 0C CD             jsr     setblk          ;set bit
  1807 00:CBEF: EE 21 71             inc     blknum          ;bump block number
  1808 00:CBF2: D0 03                bne     *+5
  1809 00:CBF4: EE 22 71             inc     blknum+1
  1810 00:CBF7: AD 39 71             lda     gpcnt           ;get low of count
  1811 00:CBFA: D0 03                bne     *+5             ;skip if not zero
  1812 00:CBFC: CE 3A 71             dec     gpcnt+1         ;else drop high
  1813 00:CBFF: CE 39 71             dec     gpcnt           ;always do low
  1814 00:CC02: AD 39 71             lda     gpcnt           ;test for zero
  1815 00:CC05: 0D 3A 71             ora     gpcnt+1
  1816 00:CC08: D0 DC                bne     fildal          ;loop if more
  1817                        ;at this point directory space is mapped
  1818 00:CC0A: 20 28 CC             jsr     intdrv          ;initialize drive
  1819 00:CC0D: 20 7A CF             jsr     cldrnm          ;clear directory number
  1820 00:CC10: A2 01        fillpe  ldx     #1              ;parameter for fill
  1821 00:CC12: 20 C4 CE             jsr     nxtdir          ;execute for next directory
  1822 00:CC15: 30 10                bmi     extfil          ;done if invalid
  1823 00:CC17: AC 20 71             ldy     subrec          ;get offset
  1824 00:CC1A: B1 82                lda     (bufadd),y      ;get empty/valid flag
  1825 00:CC1C: C9 E5                cmp     #$e5            ;if empty
  1826 00:CC1E: F0 F0                beq     fillpe          ;try next
  1827 00:CC20: A2 01                ldx     #1              ;parameter for fill in
  1828 00:CC22: 20 86 CF             jsr     mapdir          ;do directory map
  1829 00:CC25: 80 E9                bra     fillpe          ;then loop
  1830 00:CC27: 60           extfil  rts                     ;return
  1831                        ;initialize drive
  1832                        ; input:nsystr
  1833                        ; returns:none
  1834                        ; alters:all
  1835 00:CC28: 20 98 71     intdrv  jsr     simram+24       ;home then
  1836 00:CC2B: AD 40 71             lda     nsystr          ;get number of system tracks
  1837 00:CC2E: AC 41 71             ldy     nsystr+1
  1838 00:CC31: 4C 9E 71             jmp     simram+30       ;and set in sim
  1839                        ;directory record set up
  1840                        ; input:dirnum
  1841                        ; returns:none
  1842                        ; alters:all,recnum,dirrec
  1843 00:CC34: AD 1F 71     drrcsu  lda     dirnum+1        ;move high dir number
  1844 00:CC37: 8D 22 71             sta     recnum+1        ;to record number
  1845 00:CC3A: AD 1E 71             lda     dirnum          ;divide
  1846 00:CC3D: 4E 22 71             lsr     recnum+1        ;directory by four
  1847 00:CC40: 6A                   ror     a
  1848 00:CC41: 4E 22 71             lsr     recnum+1
  1849 00:CC44: 6A                   ror     a
  1850 00:CC45: 8D 28 71             sta     dirrec          ;and save
  1851 00:CC48: 8D 21 71             sta     recnum          ;set low record number
  Thu Apr 29 2021  3:45                                                                                                    Page 31


  1852 00:CC4B: AD 22 71             lda     recnum+1        ;get high
  1853 00:CC4E: 8D 29 71             sta     dirrec+1        ;and set
  1854 00:CC51: 9C 23 71             stz     recnum+2        ;clear top byte
  1855                        ;set track and sector
  1856                        ; input:recnum
  1857                        ; returns:none
  1858                        ; alters:all,countr,trkctr
  1859 00:CC54: A2 00        sttrsc  ldx     #0              ;clear track counter
  1860 00:CC56: 8E 3B 71             stx     trkctr
  1861 00:CC59: 8E 13 71             stx     countr          ;and record
  1862 00:CC5C: 8E 14 71             stx     countr+1        ;counter
  1863 00:CC5F: 8E 15 71             stx     countr+2
  1864 00:CC62: AD 21 71     trnxtr  lda     recnum          ;from
  1865 00:CC65: CD 13 71             cmp     countr          ;record number
  1866 00:CC68: AD 22 71             lda     recnum+1        ;and if a
  1867 00:CC6B: ED 14 71             sbc     countr+1        ;borrow then
  1868 00:CC6E: AD 23 71             lda     recnum+2
  1869 00:CC71: ED 15 71             sbc     countr+2
  1870 00:CC74: 90 20                bcc     higher          ;gone too far
  1871 00:CC76: 18                   clc                     ;else
  1872 00:CC77: AD 13 71             lda     countr          ;get counter
  1873 00:CC7A: 6D 3E 71             adc     sectrk          ;add sectors per track
  1874 00:CC7D: 8D 13 71             sta     countr          ;sectors per track
  1875 00:CC80: AD 14 71             lda     countr+1
  1876 00:CC83: 6D 3F 71             adc     sectrk+1
  1877 00:CC86: 8D 14 71             sta     countr+1
  1878 00:CC89: 90 03                bcc     bumptr          ;done if no carry
  1879 00:CC8B: EE 15 71             inc     countr+2        ;else bump high
  1880 00:CC8E: E8           bumptr  inx                     ;increase track count
  1881 00:CC8F: D0 D1                bne     trnxtr          ;with carry
  1882 00:CC91: EE 3B 71             inc     trkctr
  1883 00:CC94: 80 CC                bra     trnxtr          ;then loop
  1884 00:CC96: CA           higher  dex                     ;back up track
  1885 00:CC97: E0 FF                cpx     #$ff            ;see if wrap around
  1886 00:CC99: D0 03                bne     *+5             ;wasn't
  1887 00:CC9B: CE 3B 71             dec     trkctr          ;else drop high
  1888 00:CC9E: 8A                   txa                     ;move to a
  1889 00:CC9F: 18                   clc                     ;add starting track
  1890 00:CCA0: 6D 40 71             adc     nsystr
  1891 00:CCA3: AA                   tax                     ;save in x
  1892 00:CCA4: AD 3B 71             lda     trkctr
  1893 00:CCA7: 6D 41 71             adc     nsystr+1
  1894 00:CCAA: A8                   tay                     ;move to correct registers
  1895 00:CCAB: 8A                   txa
  1896 00:CCAC: 20 9E 71             jsr     simram+30       ;then set in sim
  1897 00:CCAF: 38                   sec                     ;back
  1898 00:CCB0: AD 13 71             lda     countr          ;counter down
  1899 00:CCB3: ED 3E 71             sbc     sectrk          ;by sectors per track
  1900 00:CCB6: 8D 13 71             sta     countr          ;and save
  1901 00:CCB9: AD 14 71             lda     countr+1
  1902 00:CCBC: ED 3F 71             sbc     sectrk+1
  1903 00:CCBF: 8D 14 71             sta     countr+1
  1904 00:CCC2: 38                   sec                     ;now
  1905 00:CCC3: AD 21 71             lda     recnum          ;find difference
  1906 00:CCC6: ED 13 71             sbc     countr          ;as sector
  1907 00:CCC9: AA                   tax                     ;save in x
  1908 00:CCCA: AD 22 71             lda     recnum+1
  1909 00:CCCD: ED 14 71             sbc     countr+1
  1910 00:CCD0: A8                   tay                     ;move to correct registers
  1911 00:CCD1: 8A                   txa
  1912 00:CCD2: 20 B3 71             jsr     simram+51       ;translate
  1913 00:CCD5: 4C A1 71             jmp     simram+33       ;and set through sim
  1914                        ;get block bit mask and index
  Thu Apr 29 2021  3:45                                                                                                    Page 32


  1915                        ; input:a&y=block number
  1916                        ; returns:a=bit mask and y=0
  1917                        ; alters:all and alcpnt
  1918 00:CCD8: 48           blkmsk  pha                     ;save block number
  1919 00:CCD9: 84 85                sty     alcpnt+1        ;including high
  1920 00:CCDB: A0 03                ldy     #3              ;divide by eight
  1921 00:CCDD: 46 85        blkmlp  lsr     alcpnt+1        ;shift high
  1922 00:CCDF: 6A                   ror     a
  1923 00:CCE0: 88                   dey                     ;loop until done
  1924 00:CCE1: D0 FA                bne     blkmlp
  1925 00:CCE3: 18                   clc                     ;now add map start
  1926 00:CCE4: 6D 45 71             adc     alcmap
  1927 00:CCE7: 85 84                sta     alcpnt
  1928 00:CCE9: A5 85                lda     alcpnt+1
  1929 00:CCEB: 6D 46 71             adc     alcmap+1
  1930 00:CCEE: 85 85                sta     alcpnt+1
  1931 00:CCF0: 68                   pla                     ;get number back
  1932 00:CCF1: 29 07                and     #%00000111      ;look at 3 lsbs
  1933 00:CCF3: AA                   tax                     ;get
  1934 00:CCF4: BD C0 D2             lda     bitmsk,x        ;mask
  1935 00:CCF7: 60                   rts                     ;and return
  1936                        ;test block
  1937                        ; input:a&y=block number
  1938                        ; returns:z=1 if unassigned
  1939                        ;          =0 if assigned and bit in a is set
  1940                        ; alters:all
  1941 00:CCF8: 20 D8 CC     tstblk  jsr     blkmsk          ;get mask and index
  1942 00:CCFB: 31 84                and     (alcpnt),y      ;mask with map entry
  1943 00:CCFD: 60                   rts                     ;then return
  1944                        ;alter block status
  1945                        ; input:a&y=block number,x=1 if set
  1946                        ;                         =0 if reset
  1947                        ; returns:none
  1948                        ; alters:all and allocation map
  1949 00:CCFE: E0 01        altalc  cpx     #1              ;if set
  1950 00:CD00: F0 0A                beq     setblk          ;go do it
  1951 00:CD02: 20 D8 CC     clrblk  jsr     blkmsk          ;else get mask
  1952 00:CD05: 49 FF                eor     #$ff            ;and complement
  1953 00:CD07: 31 84                and     (alcpnt),y      ;preserve others
  1954 00:CD09: 91 84                sta     (alcpnt),y      ;and save
  1955 00:CD0B: 60                   rts                     ;then return
  1956 00:CD0C: 20 D8 CC     setblk  jsr     blkmsk          ;get mask
  1957 00:CD0F: 11 84                ora     (alcpnt),y      ;set bit
  1958 00:CD11: 91 84                sta     (alcpnt),y      ;and put back
  1959 00:CD13: 60                   rts                     ;then return
  1960                        ;set current drive to read only
  1961                        ; input:curdrv,ronlst,bitmap
  1962                        ; returns:none
  1963                        ; alters:a,x,p and ronlst
  1964 00:CD14: AE 1B 71     setron  ldx     curdrv          ;get number
  1965 00:CD17: BD C8 D2             lda     bitmap,x        ;and get mask
  1966 00:CD1A: 0D 1D 71             ora     ronlst          ;or with status
  1967 00:CD1D: 8D 1D 71             sta     ronlst          ;and put back
  1968 00:CD20: 60                   rts                     ;then return
  1969                        ;calculate checksum of buffer @ bufadd
  1970                        ; input: buffer@(bufadd)
  1971                        ; returns:a=checksum
  1972                        ; alters:a,y,p
  1973 00:CD21: A9 00        clcchk  lda     #0              ;clear accumulator
  1974 00:CD23: A0 7F                ldy     #127            ;start at end
  1975 00:CD25: 18           chkmre  clc                     ;no carry
  1976 00:CD26: 71 82                adc     (bufadd),y      ;add byte
  1977 00:CD28: 88                   dey                     ;count down
  Thu Apr 29 2021  3:45                                                                                                    Page 33


  1978 00:CD29: 10 FA                bpl     chkmre          ;and loop until done
  1979 00:CD2B: 60                   rts                     ;then return
  1980                        ;check read/write status
  1981                        ; input:curdrv,ronlst
  1982                        ; returns:z=0 if r/o or z=1 if r/w
  1983                        ; alters:a,x,p
  1984 00:CD2C: AE 1B 71     chkron  ldx     curdrv          ;get current drive
  1985 00:CD2F: BD C8 D2             lda     bitmap,x        ;get mask
  1986 00:CD32: 2D 1D 71             and     ronlst          ;and test status
  1987 00:CD35: 60                   rts
  1988                        ;initialize record counters from fcb
  1989                        ; input:fcb@(addinp)
  1990                        ; returns:none
  1991                        ; alters:a,y,p,nxtrec,numrec
  1992 00:CD36: A0 20        inrcct  ldy     #32             ;next record offset
  1993 00:CD38: B1 80                lda     (addinp),y      ;get next record
  1994 00:CD3A: 8D 26 71             sta     nxtrec          ;and save
  1995 00:CD3D: A0 0F                ldy     #15             ;number records offset
  1996 00:CD3F: B1 80                lda     (addinp),y      ;get number
  1997 00:CD41: 8D 27 71             sta     numrec          ;and save
  1998 00:CD44: 60                   rts                     ;and return
  1999                        ;update record counters in fcb
  2000                        ; input:nxtrec,numrec
  2001                        ; returns:none
  2002                        ; alters:all,fcb@(addinp)
  2003 00:CD45: AE 26 71     updtrc  ldx     nxtrec          ;get next record
  2004 00:CD48: E8                   inx                     ;bump it
  2005 00:CD49: 8A                   txa                     ;transfer
  2006 00:CD4A: A0 20                ldy     #32             ;set offset
  2007 00:CD4C: 91 80                sta     (addinp),y      ;and store in fcb
  2008 00:CD4E: AD 27 71             lda     numrec          ;get number
  2009 00:CD51: A0 0F                ldy     #15             ;and its offset
  2010 00:CD53: 91 80                sta     (addinp),y      ;and store
  2011 00:CD55: 60                   rts                     ;then return
  2012                        ;execute open file
  2013 00:CD56: 20 AF CA     xopen   jsr     autodr          ;auto drive select
  2014                        ;open file
  2015                        ; input:fcb @ (addinp)
  2016                        ; returns:n=1 if not found,a=dirmod (255 if not found)
  2017                        ; alters:all
  2018 00:CD59: 20 B8 CD     opnfle  jsr     fndf13          ;match all including extent
  2019 00:CD5C: 30 32                bmi     extopn          ;done if not found
  2020 00:CD5E: A9 0C                lda     #12             ;point to first char
  2021 00:CD60: 0D 20 71             ora     subrec          ;add offset
  2022 00:CD63: A8                   tay                     ;make it a pointer
  2023 00:CD64: B1 82        nxopmv  lda     (bufadd),y      ;get buffer contents
  2024 00:CD66: AA                   tax                     ;and save
  2025 00:CD67: 98                   tya                     ;save index
  2026 00:CD68: 29 1F                and     #%00011111      ;remove offset
  2027 00:CD6A: A8                   tay                     ;back to index
  2028 00:CD6B: 8A                   txa                     ;get byte back
  2029 00:CD6C: 91 80                sta     (addinp),y      ;and store in fcb
  2030 00:CD6E: 98                   tya                     ;get index
  2031 00:CD6F: 0D 20 71             ora     subrec          ;add offset back
  2032 00:CD72: A8                   tay                     ;and make index again
  2033 00:CD73: C8                   iny                     ;next position
  2034 00:CD74: 98                   tya                     ;if index
  2035 00:CD75: 29 1F                and     #%00011111      ;not gone past
  2036 00:CD77: D0 EB                bne     nxopmv          ;end then loop
  2037                        ;now correct extent and max records
  2038 00:CD79: A0 0C                ldy     #12             ;point at extent in fcb
  2039 00:CD7B: AD 08 71             lda     savext          ;get save from search
  2040 00:CD7E: D1 80                cmp     (addinp),y      ;compare
  Thu Apr 29 2021  3:45                                                                                                    Page 34


  2041 00:CD80: F0 0B                beq     extsme          ;jump ahead if same
  2042 00:CD82: 91 80                sta     (addinp),y      ;else change extent
  2043 00:CD84: A9 80                lda     #128            ;assume fcb ext < dir ext
  2044 00:CD86: 90 01                bcc     fcbxls          ;jump ahead if true
  2045 00:CD88: 0A                   asl     a               ;clear a
  2046 00:CD89: A0 0F        fcbxls  ldy     #15             ;point to max
  2047 00:CD8B: 91 80                sta     (addinp),y      ;and set
  2048 00:CD8D: AD 2A 71     extsme  lda     dirmod          ;else get number
  2049 00:CD90: 60           extopn  rts                     ;and return
  2050                        ;execute close file
  2051 00:CD91: 20 AF CA     xclose  jsr     autodr          ;auto drive select
  2052                        ;close file
  2053                        ;if file is r/o then no actual close
  2054                        ;operation is performed.
  2055                        ; input:fcb @ (addinp)
  2056                        ; returns:n=1 if not valid,a=dirmod (255 if invalid)
  2057                        ; alters:all
  2058 00:CD94: 20 B8 CD     clsfle  jsr     fndf13          ;match including extent
  2059 00:CD97: 30 1B                bmi     extcls          ;exit if not found
  2060 00:CD99: 20 2C CD             jsr     chkron          ;see if r/o
  2061 00:CD9C: D0 13                bne     noclse          ;branch if is
  2062                        ;now set flag to ensure directory extent and number of
  2063                        ;records fields are only changed if necessary.
  2064                        ;The decision to change is determined by whether or
  2065                        ;not the system is closing an extent less than the
  2066                        ;maximum extent in the directory entry. If that is
  2067                        ;the case, the directory extent and number of record
  2068                        ;fields are not changed.
  2069 00:CD9E: A0 0C                ldy     #12             ;get extent
  2070 00:CDA0: B1 80                lda     (addinp),y
  2071 00:CDA2: 48                   pha                     ;save it
  2072 00:CDA3: 98                   tya                     ;now look in directory
  2073 00:CDA4: 0D 20 71             ora     subrec
  2074 00:CDA7: A8                   tay
  2075 00:CDA8: 68                   pla                     ;get extent back
  2076 00:CDA9: D1 82                cmp     (bufadd),y
  2077 00:CDAB: 6E 06 71             ror     skpdir          ;save result
  2078                        ;now go do it
  2079 00:CDAE: 20 23 CE             jsr     updtdr          ;update directory
  2080 00:CDB1: AD 2A 71     noclse  lda     dirmod          ;get directory number
  2081 00:CDB4: 60           extcls  rts                     ;and return
  2082                        ;execute find first match
  2083 00:CDB5: 20 AF CA     xfndfr  jsr     autodr          ;auto drive select
  2084 00:CDB8: A9 0D        fndf13  lda     #13             ;match including extent
  2085                        ;search for first match
  2086                        ; input:a=number char to match
  2087                        ; returns:n=1 if invalid,a=dirmod (255 if invalid)
  2088                        ; alters:all
  2089 00:CDBA: 48           frstsr  pha                     ;save number to match
  2090 00:CDBB: 20 7A CF             jsr     cldrnm          ;clear directory number to -1
  2091 00:CDBE: 20 28 CC             jsr     intdrv          ;and drive
  2092 00:CDC1: 68                   pla                     ;get number to match
  2093                        ;search for directory match
  2094                        ; input:a=number char to match
  2095                        ; returns:n=1 if not found,a=dirmod (255 if invalid)
  2096                        ; alters:all
  2097 00:CDC2: 8D 24 71     search  sta     chrcnt          ;save number
  2098 00:CDC5: A2 00        newtry  ldx     #0              ;set for search - ??
  2099 00:CDC7: 8E 25 71             stx     cmppnt          ;clear pointer
  2100 00:CDCA: 20 C4 CE             jsr     nxtdir          ;get next entry
  2101 00:CDCD: 30 37                bmi     exitsr          ;exit if not found
  2102 00:CDCF: AE 24 71             ldx     chrcnt          ;get count
  2103 00:CDD2: AC 25 71     mremch  ldy     cmppnt          ;get pointer
  Thu Apr 29 2021  3:45                                                                                                    Page 35


  2104 00:CDD5: EE 25 71             inc     cmppnt          ;and bump
  2105 00:CDD8: B1 80                lda     (addinp),y      ;get fcb entry
  2106 00:CDDA: C0 0C                cpy     #12             ;see if at extent
  2107 00:CDDC: D0 13                bne     notaex          ;jump if not
  2108 00:CDDE: 8D 08 71             sta     savext          ;save for later use
  2109 00:CDE1: 48                   pha                     ;save extent
  2110 00:CDE2: 98                   tya                     ;change to directory
  2111 00:CDE3: 0D 20 71             ora     subrec          ;coordinates
  2112 00:CDE6: A8                   tay
  2113 00:CDE7: 68                   pla                     ;get extent back
  2114 00:CDE8: 51 82                eor     (bufadd),y      ;exclusive or with dir
  2115 00:CDEA: 2D 4C 71             and     cexm1f          ;and with exm complement + 1f
  2116 00:CDED: F0 11                beq     trynxt          ;ok if zero
  2117 00:CDEF: D0 D4                bne     newtry          ;else get next directory
  2118 00:CDF1: C9 3F        notaex  cmp     #'?'            ;if a ? then
  2119 00:CDF3: F0 0B                beq     trynxt          ;is a match
  2120 00:CDF5: 48                   pha                     ;save char
  2121 00:CDF6: 98                   tya                     ;then add
  2122 00:CDF7: 0D 20 71             ora     subrec          ;offset to
  2123 00:CDFA: A8                   tay                     ;make pointer
  2124 00:CDFB: 68                   pla                     ;get char back
  2125 00:CDFC: D1 82                cmp     (bufadd),y      ;if not same
  2126 00:CDFE: D0 C5                bne     newtry          ;try next directory
  2127 00:CE00: CA           trynxt  dex                     ;else count number down
  2128 00:CE01: D0 CF                bne     mremch          ;and loop if more
  2129 00:CE03: AD 2A 71             lda     dirmod          ;return with directory
  2130 00:CE06: 60           exitsr  rts                     ;number mod 4
  2131                        ;calculate logical record number
  2132                        ; input:blknum
  2133                        ; returns:none
  2134                        ; alters:a,x,p,recnum
  2135 00:CE07: AE 35 71     calrcn  ldx     sxb             ;set x according to blkscd
  2136 00:CE0A: 0E 21 71     mulmre  asl     blknum          ;multiply block
  2137 00:CE0D: 2E 22 71             rol     blknum+1        ;number
  2138 00:CE10: 2E 23 71             rol     blknum+2
  2139 00:CE13: CA                   dex                     ;by code
  2140 00:CE14: D0 F4                bne     mulmre
  2141 00:CE16: AD 34 71             lda     sab             ;set mask in a
  2142 00:CE19: 2D 26 71             and     nxtrec          ;and with next record
  2143 00:CE1C: 0D 21 71             ora     recnum          ;or with number
  2144 00:CE1F: 8D 21 71             sta     recnum          ;and save
  2145 00:CE22: 60                   rts
  2146                        ;update directory
  2147 00:CE23: A9 20        updtdr  lda     #32             ;change all
  2148 00:CE25: A2 00                ldx     #0              ;from start
  2149                        ;change directory entry
  2150                        ; input:a=number char to change,x=starting position,fcb@(addinp)
  2151                        ; returns:none
  2152                        ; alters:all,directory,checksums
  2153 00:CE27: 8D 24 71     dirchg  sta     chrcnt          ;save count
  2154 00:CE2A: CE 24 71             dec     chrcnt          ;back up
  2155 00:CE2D: 18           mrechg  clc                     ;clear carry
  2156 00:CE2E: 8A                   txa                     ;get offset
  2157 00:CE2F: 6D 24 71             adc     chrcnt          ;compute index
  2158 00:CE32: A8                   tay                     ;and set
  2159 00:CE33: C0 0C                cpy     #12             ;see if at extent
  2160 00:CE35: F0 04                beq     docare          ;if so do special
  2161 00:CE37: C0 0F                cpy     #15             ;see if at number rec
  2162 00:CE39: D0 05                bne     dntcar          ;if not skip
  2163 00:CE3B: 2C 06 71     docare  bit     skpdir          ;check flag
  2164 00:CE3E: 10 0D                bpl     nochng          ;skip if ok
  2165 00:CE40: B1 80        dntcar  lda     (addinp),y      ;get char
  2166 00:CE42: 48                   pha                     ;save it
  Thu Apr 29 2021  3:45                                                                                                    Page 36


  2167 00:CE43: AD 24 71             lda     chrcnt          ;get count
  2168 00:CE46: 0D 20 71             ora     subrec          ;add offset
  2169 00:CE49: A8                   tay                     ;make an index
  2170 00:CE4A: 68                   pla                     ;get char back
  2171 00:CE4B: 91 82                sta     (bufadd),y      ;and put in buffer
  2172 00:CE4D: CE 24 71     nochng  dec     chrcnt          ;count down
  2173 00:CE50: 10 DB                bpl     mrechg          ;and loop
  2174 00:CE52: 20 34 CC             jsr     drrcsu          ;set it up
  2175 00:CE55: 4C DA CF             jmp     updtck          ;and do change
  2176                        ;execute create file
  2177 00:CE58: 20 AF CA     xmake   jsr     autodr          ;auto drive select
  2178                        ;create file
  2179                        ; input:fcb@(addinp)
  2180                        ; returns:n=1 if not valid,a=dirmod (255 if not valid)
  2181                        ; alters:dirnum,dirmod,fcb@(addinp)
  2182 00:CE5B: 20 B4 CF     mkefle  jsr     tstron          ;test for r/o
  2183 00:CE5E: A5 80                lda     addinp          ;save fcb
  2184 00:CE60: 48                   pha                     ;address
  2185 00:CE61: A5 81                lda     addinp+1        ;on
  2186 00:CE63: 48                   pha                     ;stack
  2187 00:CE64: A9 BF                lda     #<empty         ;then point
  2188 00:CE66: A0 D2                ldy     #>empty         ;to empty
  2189 00:CE68: 85 80                sta     addinp          ;dummy
  2190 00:CE6A: 84 81                sty     addinp+1        ;fcb
  2191 00:CE6C: A9 01                lda     #1              ;match only
  2192 00:CE6E: 20 BA CD             jsr     frstsr          ;first char
  2193 00:CE71: 68                   pla                     ;restore
  2194 00:CE72: 85 81                sta     addinp+1        ;fcb
  2195 00:CE74: 68                   pla                     ;address
  2196 00:CE75: 85 80                sta     addinp          ;from stack
  2197 00:CE77: AD 2A 71             lda     dirmod          ;get number mod 4
  2198 00:CE7A: 30 15                bmi     extmke          ;quit if not found
  2199 00:CE7C: A0 0D                ldy     #13             ;else set up
  2200 00:CE7E: A9 00                lda     #0              ;to clear
  2201 00:CE80: 91 80        mkeagn  sta     (addinp),y      ;rest of
  2202 00:CE82: C8                   iny                     ;fcb
  2203 00:CE83: C0 21                cpy     #33             ;including next
  2204 00:CE85: D0 F9                bne     mkeagn          ;record
  2205                        ;the next two lines ensure that the extent and
  2206                        ;number of records fields are updated
  2207 00:CE87: 38                   sec
  2208 00:CE88: 6E 06 71             ror     skpdir
  2209 00:CE8B: 20 23 CE             jsr     updtdr          ;update directory
  2210 00:CE8E: AD 2A 71             lda     dirmod          ;get number
  2211 00:CE91: 60           extmke  rts                     ;and quit
  2212                        ;extend file
  2213                        ; input:fcb@(addinp), x=1 read
  2214                        ;                       0 write
  2215 00:CE92: 8E 11 71     extend  stx     exrwfl          ;save parameter
  2216 00:CE95: 20 94 CD             jsr     clsfle          ;close current extent
  2217 00:CE98: 30 29                bmi     extext          ;exit if not found
  2218 00:CE9A: A0 0C                ldy     #12             ;else
  2219 00:CE9C: B1 80                lda     (addinp),y      ;get extent
  2220 00:CE9E: 18                   clc                     ;and
  2221 00:CE9F: 69 01                adc     #1              ;add one
  2222 00:CEA1: 29 1F                and     #%00011111      ;see if overflow
  2223 00:CEA3: F0 16                beq     exteof          ;eof if so
  2224 00:CEA5: 91 80                sta     (addinp),y      ;and save
  2225 00:CEA7: 20 B8 CD             jsr     fndf13          ;see if next extent exists
  2226 00:CEAA: 10 0A                bpl     opnext          ;if so open
  2227 00:CEAC: AD 11 71             lda     exrwfl          ;if not and is write then create
  2228 00:CEAF: D0 12                bne     extext          ;else return as eof
  2229 00:CEB1: 20 5B CE     dwrtex  jsr     mkefle          ;create file
  Thu Apr 29 2021  3:45                                                                                                    Page 37


  2230 00:CEB4: 80 03                bra     tstext          ;and test
  2231 00:CEB6: 20 59 CD     opnext  jsr     opnfle          ;open
  2232 00:CEB9: 10 03        tstext  bpl     extnok          ;continue if ok
  2233 00:CEBB: A9 01        exteof  lda     #1              ;else set eof
  2234 00:CEBD: 60                   rts                     ;and return
  2235 00:CEBE: 20 36 CD     extnok  jsr     inrcct          ;initialize counters
  2236 00:CEC1: A9 00                lda     #0              ;good
  2237 00:CEC3: 60           extext  rts                     ;return
  2238                        ;set up next directory block
  2239                        ; input:dirnum,x=1 for update checksum
  2240                        ; returns:a=dirmod (255 if invalid),n=1 if invalid
  2241                        ; alters:alll,dirnum,dirmod
  2242 00:CEC4: DA           nxtdir  phx                     ;save operation on stack
  2243 00:CEC5: EE 1E 71             inc     dirnum          ;bump directory
  2244 00:CEC8: D0 03                bne     *+5
  2245 00:CECA: EE 1F 71             inc     dirnum+1
  2246 00:CECD: AD 43 71             lda     maxdir          ;if not at limit continue
  2247 00:CED0: CD 1E 71             cmp     dirnum
  2248 00:CED3: AD 44 71             lda     maxdir+1
  2249 00:CED6: ED 1F 71             sbc     dirnum+1
  2250 00:CED9: B0 04                bcs     gtnxdr          ;then continue
  2251 00:CEDB: FA                   plx                     ;else clear stack/set x
  2252 00:CEDC: 4C 7A CF             jmp     cldrnm          ;set to invalid
  2253 00:CEDF: AD 1E 71     gtnxdr  lda     dirnum          ;get low again
  2254 00:CEE2: 29 03                and     #%00000011      ;look at 2 lsbs
  2255 00:CEE4: 8D 2A 71             sta     dirmod          ;save mod 4
  2256 00:CEE7: 0A                   asl     a               ;multiply
  2257 00:CEE8: 0A                   asl     a               ;by
  2258 00:CEE9: 0A                   asl     a               ;32 to
  2259 00:CEEA: 0A                   asl     a               ;get pointer
  2260 00:CEEB: 0A                   asl     a               ;offset
  2261 00:CEEC: 8D 20 71             sta     subrec          ;and save
  2262 00:CEEF: F0 03                beq     getdir          ;if zero read new
  2263 00:CEF1: FA                   plx                     ;else clear stack/set x
  2264 00:CEF2: 80 0A                bra     gotdir          ;and exit
  2265 00:CEF4: 20 34 CC     getdir  jsr     drrcsu          ;set up to read
  2266 00:CEF7: 20 D5 CF             jsr     rdesec          ;do read
  2267 00:CEFA: FA                   plx                     ;get operation code
  2268 00:CEFB: 20 02 CF             jsr     chksop          ;do it
  2269 00:CEFE: AD 2A 71     gotdir  lda     dirmod          ;and return
  2270 00:CF01: 60           exnxdr  rts                     ;with number
  2271                        ;checksum operation
  2272                        ;this routine assumes calling routine has checked for
  2273                        ;valid dirnum and hence valid dirrec
  2274                        ; input:chkflg,dirrec,x (1=update else check)
  2275                        ; returns:none
  2276                        ; alters:map@(chkmap)
  2277 00:CF02: 2C 47 71     chksop  bit     chkflg          ;check flag
  2278 00:CF05: 30 FA                bmi     exnxdr          ;done if set
  2279 00:CF07: CA                   dex                     ;dec code
  2280 00:CF08: D0 09                bne     tstchk          ;if not zero test
  2281 00:CF0A: 20 21 CD             jsr     clcchk          ;else calculate
  2282 00:CF0D: 20 64 CF             jsr     clcckp          ;calculate pointer
  2283 00:CF10: 91 86                sta     (chkpnt),y      ;and save
  2284 00:CF12: 60                   rts                     ;then return
  2285 00:CF13: 20 21 CD     tstchk  jsr     clcchk          ;do calculation
  2286 00:CF16: 20 64 CF             jsr     clcckp          ;calculate pointer
  2287 00:CF19: D1 86                cmp     (chkpnt),y      ;compare to old
  2288 00:CF1B: F0 E4                beq     exnxdr          ;if equal ok
  2289 00:CF1D: 4C 14 CD             jmp     setron          ;else set to r/o
  2290                        ;get block number
  2291                        ; input:nxtrec,blmode,fcb@(addinp),sxb,exm
  2292                        ; returns:none
  Thu Apr 29 2021  3:45                                                                                                    Page 38


  2293                        ; alters:all,blknum
  2294 00:CF20: AE 35 71     getblk  ldx     sxb             ;set x according to blkscd
  2295 00:CF23: AD 26 71             lda     nxtrec          ;get next record
  2296 00:CF26: 4A           gblp    lsr     a               ;divide by 2 x times
  2297 00:CF27: CA                   dex
  2298 00:CF28: D0 FC                bne     gblp
  2299 00:CF2A: 8D 21 71             sta     blknum          ;save previous as temp
  2300                        ;use extent as offset but first use sxb to create param
  2301 00:CF2D: 38                   sec
  2302 00:CF2E: A9 08                lda     #8
  2303 00:CF30: ED 35 71             sbc     sxb
  2304 00:CF33: AA                   tax
  2305                        ;now get extent from fcb
  2306 00:CF34: A0 0C                ldy     #12
  2307 00:CF36: B1 80                lda     (addinp),y
  2308 00:CF38: 2D 4B 71             and     exm             ;and with mask
  2309 00:CF3B: 4A                   lsr     a               ;shift with lsb to c
  2310 00:CF3C: 2A           gbxlp   rol     a               ;now go other way
  2311 00:CF3D: CA                   dex
  2312 00:CF3E: D0 FC                bne     gbxlp
  2313 00:CF40: 18                   clc                     ;now add saved value
  2314 00:CF41: 6D 21 71             adc     blknum          ;back
  2315 00:CF44: 2C 31 71             bit     blmode          ;test mode
  2316 00:CF47: 10 01                bpl     *+3             ;skip if byte
  2317 00:CF49: 0A                   asl     a               ;else times two
  2318 00:CF4A: 18                   clc                     ;then add
  2319 00:CF4B: 69 10                adc     #16             ;offset into fcb
  2320 00:CF4D: 8D 07 71             sta     fcbind          ;save for later
  2321 00:CF50: A8                   tay                     ;set index
  2322 00:CF51: B1 80                lda     (addinp),y      ;get number
  2323 00:CF53: 8D 21 71             sta     blknum          ;store
  2324 00:CF56: C8                   iny
  2325 00:CF57: A9 00                lda     #0              ;clear
  2326 00:CF59: 2C 31 71             bit     blmode          ;test mode
  2327 00:CF5C: 10 02                bpl     *+4             ;skip if byte
  2328 00:CF5E: B1 80                lda     (addinp),y      ;else get high
  2329 00:CF60: 8D 22 71             sta     blknum+1        ;high byte
  2330 00:CF63: 60                   rts                     ;and return
  2331                        ;calculate chkpnt as function of dirrec and chkmap
  2332                        ; input:dirrec,chkmap
  2333                        ; returns:y=0
  2334                        ; alters:y,p,chkpnt
  2335 00:CF64: 48           clcckp  pha                     ;save a
  2336 00:CF65: 18                   clc
  2337 00:CF66: AD 28 71             lda     dirrec          ;add record number
  2338 00:CF69: 6D 48 71             adc     chkmap          ;to start
  2339 00:CF6C: 85 86                sta     chkpnt
  2340 00:CF6E: AD 29 71             lda     dirrec+1
  2341 00:CF71: 6D 49 71             adc     chkmap+1
  2342 00:CF74: 85 87                sta     chkpnt+1
  2343 00:CF76: A0 00                ldy     #0
  2344 00:CF78: 68                   pla                     ;get a back
  2345 00:CF79: 60                   rts
  2346                        ;clear directory number to $ffff
  2347                        ; input:none
  2348                        ; returns:a=$ff,n=1,z=0
  2349                        ; alters:a,p,dirnum,dirmod
  2350 00:CF7A: A9 FF        cldrnm  lda     #$ff            ;set to $ff
  2351 00:CF7C: 8D 1E 71             sta     dirnum
  2352 00:CF7F: 8D 1F 71             sta     dirnum+1
  2353 00:CF82: 8D 2A 71             sta     dirmod
  2354 00:CF85: 60                   rts
  2355                        ;change allocation map
  Thu Apr 29 2021  3:45                                                                                                    Page 39


  2356                        ; input:subrec,directory record @ (bufadd)
  2357                        ; returns:none
  2358                        ; alters:all,allocation map
  2359 00:CF86: 18           mapdir  clc                     ;add 16 to
  2360 00:CF87: AD 20 71             lda     subrec          ;to subrec to point
  2361 00:CF8A: 69 10                adc     #16             ;to block number field
  2362 00:CF8C: A8                   tay                     ;make index
  2363 00:CF8D: 8C 2F 71     lpmpdr  sty     mpdrsy          ;save index
  2364 00:CF90: DA                   phx                     ;save operation
  2365 00:CF91: B1 82                lda     (bufadd),y      ;get block number
  2366 00:CF93: 8D 30 71             sta     mpdrtm          ;save in temp
  2367 00:CF96: C8                   iny                     ;bump index for word
  2368 00:CF97: 20 14 D0             jsr     gthibn          ;get high part of number
  2369 00:CF9A: 0D 30 71     mpdrnw  ora     mpdrtm          ;see if zero
  2370 00:CF9D: F0 0A                beq     skpedr          ;skip if zero
  2371 00:CF9F: 20 14 D0             jsr     gthibn          ;get high again
  2372 00:CFA2: A8                   tay                     ;move to y
  2373 00:CFA3: AD 30 71             lda     mpdrtm          ;get low again
  2374 00:CFA6: 20 FE CC             jsr     altalc          ;else alter map
  2375 00:CFA9: FA           skpedr  plx                     ;get operation back
  2376 00:CFAA: AC 2F 71             ldy     mpdrsy          ;get index back
  2377 00:CFAD: C8                   iny                     ;bump it
  2378 00:CFAE: 98                   tya                     ;if still
  2379 00:CFAF: 29 0F                and     #%00001111      ;in field
  2380 00:CFB1: D0 DA                bne     lpmpdr          ;then loop
  2381 00:CFB3: 60                   rts                     ;else quit
  2382                        ;test r/w status
  2383                        ;does warm boot if r/o
  2384                        ; input:curdrv,ronlst
  2385                        ; returns:none
  2386                        ; alters:a,x,p
  2387 00:CFB4: 20 2C CD     tstron  jsr     chkron          ;test bit
  2388 00:CFB7: F0 1B                beq     exttro          ;exit if r/w
  2389 00:CFB9: 20 04 D0             jsr     errout          ;else send error
  2390 00:CFBC: A9 64                lda     #<romsg         ;point to r/o
  2391 00:CFBE: A0 D2                ldy     #>romsg         ;message
  2392 00:CFC0: 20 61 D0             jsr     sndstr          ;send it
  2393 00:CFC3: 4C A8 C8             jmp     xwboot          ;then abort
  2394                        ;set current drive to r/w
  2395                        ; input:curdrv,ronlst
  2396                        ; returns:ronlst
  2397                        ; alters:a,x,p,ronlst
  2398 00:CFC6: AE 1B 71     setrw   ldx     curdrv          ;get drive
  2399 00:CFC9: BD C8 D2             lda     bitmap,x        ;and mask
  2400 00:CFCC: 49 FF                eor     #$ff            ;complement
  2401 00:CFCE: 2D 1D 71             and     ronlst          ;and with status
  2402 00:CFD1: 8D 1D 71             sta     ronlst          ;save
  2403 00:CFD4: 60           exttro  rts                     ;return
  2404                        ;read sector
  2405 00:CFD5: 20 A7 71     rdesec  jsr     simram+39       ;do read
  2406 00:CFD8: 80 0F                bra     chkrwe          ;check for error
  2407                        ;update checksum and directory
  2408 00:CFDA: A2 01        updtck  ldx     #1              ;set for update
  2409 00:CFDC: 20 02 CF             jsr     chksop          ;do it
  2410 00:CFDF: A9 01                lda     #1              ;say is directory op
  2411 00:CFE1: D0 03                bne     secwrt          ;do it
  2412                        ;write sector
  2413 00:CFE3: AD 4A 71     wrtsec  lda     wrtype          ;get write type
  2414 00:CFE6: 20 AA 71     secwrt  jsr     simram+42       ;do write
  2415 00:CFE9: C9 00        chkrwe  cmp     #0              ;if not ok
  2416 00:CFEB: F0 E7                beq     exttro          ;done if zero
  2417                        ;read/write error
  2418 00:CFED: 20 04 D0     rwerrt  jsr     errout          ;send error message
  Thu Apr 29 2021  3:45                                                                                                    Page 40


  2419 00:CFF0: A9 6B                lda     #<bdsmsg        ;point to
  2420 00:CFF2: A0 D2                ldy     #>bdsmsg        ;bad sector message
  2421 00:CFF4: 20 61 D0             jsr     sndstr          ;and send
  2422 00:CFF7: 20 21 D0             jsr     getcon          ;get input
  2423 00:CFFA: C9 0D                cmp     #cr             ;if a cr
  2424 00:CFFC: F0 03                beq     ignerr          ;then continue
  2425 00:CFFE: 4C A8 C8             jmp     xwboot          ;else abort
  2426 00:D001: 4C EE D1     ignerr  jmp     pcrlf           ;crlf and return
  2427                        ;error output routine
  2428                        ; input:curdrv
  2429                        ; returns:none
  2430                        ; alters:all
  2431 00:D004: A9 9E        errout  lda     #<pemmsg        ;point to
  2432 00:D006: A0 D2                ldy     #>pemmsg        ;error message
  2433 00:D008: 20 61 D0             jsr     sndstr          ;send it
  2434 00:D00B: AD 1B 71             lda     curdrv          ;get drive number
  2435 00:D00E: 18                   clc                     ;add
  2436 00:D00F: 69 41                adc     #'A'            ;ascii a
  2437 00:D011: 4C A6 D0             jmp     sndchr          ;and send it
  2438                        ;get high part of block number if word (zero if byte)
  2439                        ; input:y=index to high,blmode,directory@(bufadd)+subrec
  2440                        ; returns:a=high part of block number
  2441                        ; alters:a,p,mpdrsy iff word
  2442 00:D014: A9 00        gthibn  lda     #0              ;preset for byte
  2443 00:D016: 2C 31 71             bit     blmode          ;test mode
  2444 00:D019: 10 05                bpl     gthiex          ;done if byte
  2445 00:D01B: B1 82                lda     (bufadd),y      ;get high
  2446 00:D01D: 8C 2F 71             sty     mpdrsy          ;alter y
  2447 00:D020: 60           gthiex  rts                     ;return
  2448                        ;get console input
  2449                        ; input:pndkey
  2450                        ; returns:a=character
  2451                        ; alters:all,pndkey
  2452 00:D021: AD 0A 71     getcon  lda     pndkey          ;get pending
  2453 00:D024: 9C 0A 71             stz     pndkey          ;clear pending
  2454 00:D027: D0 F7                bne     gthiex          ;exit if not null (borrow rts)
  2455 00:D029: 4C 89 71             jmp     simram+9        ;else get new
  2456                        ;check keyboard status
  2457                        ;handles <ctl-s> for freeze and <ctl-c> for boot
  2458                        ; input:pndkey
  2459                        ; returns:a=0 if no input or <>0 if input
  2460                        ; alters:all,pndkey
  2461 00:D02C: AD 0A 71     kbdsts  lda     pndkey          ;get pending
  2462 00:D02F: D0 20                bne     extkbd          ;if there quit
  2463 00:D031: 20 86 71             jsr     simram+6        ;else test
  2464 00:D034: 29 FF                and     #$ff            ;if zero
  2465 00:D036: F0 19                beq     extkbd          ;exit
  2466 00:D038: 20 89 71             jsr     simram+9        ;else get input
  2467 00:D03B: C9 13                cmp     #ctls           ;if not freeze
  2468 00:D03D: D0 0D                bne     newpnd          ;save input
  2469 00:D03F: 20 89 71             jsr     simram+9        ;else wait for more
  2470 00:D042: C9 03                cmp     #ctlc           ;if not abort
  2471 00:D044: D0 03                bne     nowarm          ;then jump
  2472 00:D046: 4C A8 C8             jmp     xwboot          ;else do warm boot
  2473 00:D049: A9 00        nowarm  lda     #0              ;clear
  2474 00:D04B: 60                   rts                     ;and return
  2475 00:D04C: 8D 0A 71     newpnd  sta     pndkey          ;save
  2476 00:D04F: A9 FF                lda     #$ff            ;set ready
  2477 00:D051: 60           extkbd  rts                     ;and return
  2478                        ;test character
  2479                        ; input:a=character
  2480                        ; returns:c=0 if control or c=1 if printing
  2481                        ; alters:p
  Thu Apr 29 2021  3:45                                                                                                    Page 41


  2482 00:D052: C9 0D        tstchr  cmp     #cr             ;if cr
  2483 00:D054: F0 0A                beq     chtext          ;quit
  2484 00:D056: C9 0A                cmp     #lf             ;if linefeed
  2485 00:D058: F0 06                beq     chtext          ;quit
  2486 00:D05A: C9 09                cmp     #ctli           ;if tab
  2487 00:D05C: F0 02                beq     chtext          ;quit
  2488 00:D05E: C9 20                cmp     #' '            ;see if control
  2489 00:D060: 60           chtext  rts                     ;and return
  2490                        ;send string ending in $
  2491                        ; input:ay=string address
  2492                        ; returns:none
  2493                        ; alters:all,index,sndlpe+1 and +2
  2494 00:D061: 85 88        sndstr  sta     msgptr          ;set pointer
  2495 00:D063: 84 89                sty     msgptr+1
  2496 00:D065: A0 00                ldy     #0
  2497 00:D067: B1 88        sndlpe  lda     (msgptr),y      ;get char
  2498 00:D069: C9 24                cmp     #'$'            ;if terminator
  2499 00:D06B: F0 0C                beq     sndext          ;then exit
  2500 00:D06D: C8                   iny                     ;else bump
  2501 00:D06E: 8C 2B 71             sty     index           ;and save
  2502 00:D071: 20 A6 D0             jsr     sndchr          ;send char
  2503 00:D074: AC 2B 71             ldy     index           ;get index
  2504 00:D077: D0 EE                bne     sndlpe          ;and loop
  2505 00:D079: 60           sndext  rts                     ;return
  2506                        ;send char to printer if enabled
  2507                        ; input:a=character,lstflg
  2508                        ; returns:a=character
  2509                        ; alters:x,y,p
  2510 00:D07A: 2C 0B 71     lstout  bit     lstflg          ;test flag
  2511 00:D07D: 10 0A                bpl     extlst          ;exit if off
  2512 00:D07F: 2C 2D 71             bit     outflg          ;test output flag
  2513 00:D082: 30 05                bmi     extlst          ;done if set
  2514 00:D084: 48                   pha                     ;save char
  2515 00:D085: 20 8F 71             jsr     simram+15       ;send
  2516 00:D088: 68                   pla                     ;get char
  2517 00:D089: 60           extlst  rts                     ;and done
  2518                        ;output a character
  2519                        ; input:a=character,console definition block in sim
  2520                        ; returns:none
  2521                        ; alters:all,positn
  2522 00:D08A: 20 52 D0     output  jsr     tstchr          ;test it
  2523 00:D08D: B0 17                bcs     sndchr          ;if not control jump
  2524 00:D08F: 48                   pha                     ;else save
  2525 00:D090: AD BB 71             lda     sysdef+4        ;get invert
  2526 00:D093: 20 BF D0             jsr     nolist          ;send to console
  2527 00:D096: A9 5E                lda     #'^'            ;get arrow
  2528 00:D098: 20 7A D0             jsr     lstout          ;send to printer
  2529 00:D09B: 68                   pla                     ;get character
  2530 00:D09C: 09 40                ora     #'A'-1          ;convert to ascii
  2531 00:D09E: 20 B7 D0             jsr     pchrot          ;send to all
  2532 00:D0A1: AD BA 71             lda     sysdef+3        ;get normal
  2533 00:D0A4: 80 19                bra     nolist          ;to console
  2534 00:D0A6: C9 09        sndchr  cmp     #ctli           ;if not tab
  2535 00:D0A8: D0 0D                bne     pchrot          ;send
  2536 00:D0AA: A9 20        tabspc  lda     #' '            ;else get space
  2537 00:D0AC: 20 B7 D0             jsr     pchrot          ;send
  2538 00:D0AF: AD 0C 71             lda     positn          ;get count
  2539 00:D0B2: 29 07                and     #7              ;if not mod 8
  2540 00:D0B4: D0 F4                bne     tabspc          ;loop
  2541 00:D0B6: 60                   rts                     ;else exit
  2542 00:D0B7: 48           pchrot  pha                     ;save char
  2543 00:D0B8: 20 2C D0             jsr     kbdsts          ;test input
  2544 00:D0BB: 68                   pla                     ;restore
  Thu Apr 29 2021  3:45                                                                                                    Page 42


  2545 00:D0BC: 20 7A D0             jsr     lstout          ;to printer if on
  2546 00:D0BF: 48           nolist  pha                     ;save again
  2547 00:D0C0: 2C 2D 71             bit     outflg          ;test flag
  2548 00:D0C3: 30 03                bmi     *+5             ;done if set
  2549 00:D0C5: 20 8C 71             jsr     simram+12       ;to console
  2550 00:D0C8: 68                   pla                     ;restore
  2551 00:D0C9: EE 0C 71             inc     positn          ;bump col
  2552 00:D0CC: C9 20                cmp     #' '            ;if space or more
  2553 00:D0CE: B0 24                bcs     extchr          ;is ok
  2554 00:D0D0: CD B9 71             cmp     sysdef+2        ;also ok
  2555 00:D0D3: F0 1F                beq     extchr          ;if forward
  2556 00:D0D5: CE 0C 71             dec     positn          ;else drop back
  2557 00:D0D8: CD B7 71             cmp     sysdef+0        ;see if bs
  2558 00:D0DB: D0 06                bne     tryotr          ;branch if not
  2559 00:D0DD: CE 0C 71             dec     positn          ;else drop again
  2560 00:D0E0: 30 0F                bmi     zrocol          ;zero if <0
  2561 00:D0E2: 60                   rts                     ;else ok
  2562 00:D0E3: C9 0D        tryotr  cmp     #cr             ;if a cr
  2563 00:D0E5: F0 0A                beq     zrocol          ;clear col
  2564 00:D0E7: CD BE 71             cmp     sysdef+7        ;if a formfeed
  2565 00:D0EA: F0 05                beq     zrocol          ;also clear
  2566 00:D0EC: CD BF 71             cmp     sysdef+8        ;if not home
  2567 00:D0EF: D0 03                bne     extchr          ;then done
  2568 00:D0F1: 9C 0C 71     zrocol  stz     positn          ;column
  2569 00:D0F4: 60           extchr  rts                     ;and exit
  2570                        ;go to left and space past prompt
  2571                        ; input:frscol,positn
  2572                        ; returns:none
  2573                        ; alters:positn
  2574 00:D0F5: A9 0D        spcovr  lda     #cr             ;get cr
  2575 00:D0F7: 20 B7 D0             jsr     pchrot          ;send to all
  2576 00:D0FA: A9 0A                lda     #lf             ;send lf
  2577 00:D0FC: 20 7A D0             jsr     lstout          ;only to printer
  2578 00:D0FF: AD 09 71     mreovr  lda     frscol          ;get first
  2579 00:D102: CD 0C 71             cmp     positn          ;see if there
  2580 00:D105: F0 ED                beq     extchr          ;done if is
  2581 00:D107: AD B9 71             lda     sysdef+2        ;get forward
  2582 00:D10A: 20 BF D0             jsr     nolist          ;send it
  2583 00:D10D: 80 F0                bra     mreovr          ;and loop
  2584                        ;buffered read
  2585                        ; input:buffer@(addinp)
  2586                        ; returns:none
  2587                        ; alters:all,buffer@(addinp)
  2588 00:D10F: A9 00        bufinp  lda     #0              ;clear
  2589 00:D111: A0 01                ldy     #1              ;length
  2590 00:D113: 91 80                sta     (addinp),y      ;position in buffer
  2591 00:D115: 8C 10 71             sty     bufpsn          ;set point to 1
  2592 00:D118: AD 0C 71             lda     positn          ;get current
  2593 00:D11B: 8D 09 71             sta     frscol          ;and save
  2594 00:D11E: 20 21 D0     nxtinp  jsr     getcon          ;get input
  2595 00:D121: AC 10 71             ldy     bufpsn          ;get index
  2596 00:D124: C9 0D                cmp     #cr             ;if not a cr
  2597 00:D126: D0 03                bne     notcr           ;then jump
  2598 00:D128: 4C EB D1             jmp     endlin          ;else done
  2599 00:D12B: C9 7F        notcr   cmp     #delete         ;if not delete
  2600 00:D12D: D0 5C                bne     ntdelt          ;then jump
  2601 00:D12F: C0 01                cpy     #1              ;else if start
  2602 00:D131: F0 EB                beq     nxtinp          ;then loop
  2603 00:D133: B1 80                lda     (addinp),y      ;get last
  2604 00:D135: 48                   pha                     ;save char
  2605 00:D136: A0 01                ldy     #1              ;point to count
  2606 00:D138: 38                   sec                     ;set carry
  2607 00:D139: B1 80                lda     (addinp),y      ;get count
  Thu Apr 29 2021  3:45                                                                                                    Page 43


  2608 00:D13B: E9 01                sbc     #1              ;decrement
  2609 00:D13D: 91 80                sta     (addinp),y      ;then save
  2610 00:D13F: 68                   pla                     ;restore char
  2611 00:D140: CE 10 71             dec     bufpsn          ;backup pointer
  2612 00:D143: C9 20                cmp     #' '            ;if space or more
  2613 00:D145: B0 3F                bcs     nrmbs           ;just backspace
  2614 00:D147: C9 09                cmp     #ctli           ;see if tab
  2615 00:D149: D0 2F                bne     ctlbs           ;if not is control
  2616 00:D14B: 38                   sec                     ;set flag
  2617 00:D14C: 6E 2D 71             ror     outflg
  2618 00:D14F: AD 0C 71             lda     positn          ;get position and save
  2619 00:D152: 8D 2E 71             sta     lstcol
  2620 00:D155: 20 F5 D0             jsr     spcovr          ;else go back
  2621 00:D158: 20 F8 D1             jsr     rptlne          ;and retype
  2622 00:D15B: AD 0C 71             lda     positn          ;get new last position
  2623 00:D15E: 48                   pha                     ;save on stack
  2624 00:D15F: 38                   sec                     ;subtract to get delta
  2625 00:D160: AD 2E 71             lda     lstcol
  2626 00:D163: ED 0C 71             sbc     positn
  2627 00:D166: 8D 2E 71             sta     lstcol          ;and save
  2628 00:D169: 0E 2D 71             asl     outflg          ;clear flag
  2629 00:D16C: 20 16 D2     bstab   jsr     dobs            ;do one
  2630 00:D16F: CE 2E 71             dec     lstcol          ;drop count
  2631 00:D172: D0 F8                bne     bstab           ;loop if more
  2632 00:D174: 68                   pla                     ;get position
  2633 00:D175: 8D 0C 71             sta     positn          ;and set
  2634 00:D178: 80 A4                bra     nxtinp          ;then loop
  2635 00:D17A: AD BA 71     ctlbs   lda     sysdef+3        ;get normal
  2636 00:D17D: 20 12 D2             jsr     chkbs           ;bs if printing
  2637 00:D180: AD BB 71             lda     sysdef+4        ;same for invert
  2638 00:D183: 20 12 D2             jsr     chkbs           ;then delete char itself
  2639 00:D186: 20 16 D2     nrmbs   jsr     dobs            ;do a backspace
  2640 00:D189: 80 93                bra     nxtinp          ;and loop
  2641 00:D18B: C9 10        ntdelt  cmp     #ctlp           ;if not ctl-p
  2642 00:D18D: D0 0A                bne     ntctlp          ;then jump
  2643 00:D18F: AD 0B 71             lda     lstflg          ;else get printer flag
  2644 00:D192: 49 FF                eor     #$ff            ;complement
  2645 00:D194: 8D 0B 71             sta     lstflg          ;save
  2646 00:D197: 80 85                bra     nxtinp          ;and loop
  2647 00:D199: C9 18        ntctlp  cmp     #ctlx           ;if not ctl-x
  2648 00:D19B: D0 0C                bne     ntctlx          ;then jump
  2649 00:D19D: 20 F5 D0             jsr     spcovr          ;restart
  2650 00:D1A0: AD B8 71             lda     sysdef+1        ;get clear to eol
  2651 00:D1A3: 20 BF D0             jsr     nolist          ;send it
  2652 00:D1A6: 4C 0F D1             jmp     bufinp          ;and start over
  2653 00:D1A9: C9 12        ntctlx  cmp     #ctlr           ;if not ctl-r
  2654 00:D1AB: D0 09                bne     ntctlr          ;then jump
  2655 00:D1AD: 20 F5 D0             jsr     spcovr          ;restart
  2656 00:D1B0: 20 F8 D1             jsr     rptlne          ;retype line
  2657 00:D1B3: 4C 1E D1             jmp     nxtinp          ;and start over
  2658 00:D1B6: C8           ntctlr  iny                     ;next position
  2659 00:D1B7: 91 80                sta     (addinp),y      ;store char
  2660 00:D1B9: 48                   pha                     ;and save
  2661 00:D1BA: 8C 10 71             sty     bufpsn          ;index
  2662 00:D1BD: A0 01                ldy     #1              ;point to count
  2663 00:D1BF: 98                   tya                     ;set a to 1
  2664 00:D1C0: 18                   clc                     ;then
  2665 00:D1C1: 71 80                adc     (addinp),y      ;add count
  2666 00:D1C3: 91 80                sta     (addinp),y      ;and save
  2667 00:D1C5: 68                   pla                     ;restore char
  2668 00:D1C6: 20 8A D0     dontsv  jsr     output          ;send char
  2669 00:D1C9: AC 10 71             ldy     bufpsn          ;get index
  2670 00:D1CC: B1 80                lda     (addinp),y      ;get char
  Thu Apr 29 2021  3:45                                                                                                    Page 44


  2671 00:D1CE: C9 03                cmp     #ctlc           ;if not ctl-c
  2672 00:D1D0: D0 0B                bne     ignrcc          ;ignore
  2673 00:D1D2: A0 01                ldy     #1              ;get count
  2674 00:D1D4: B1 80                lda     (addinp),y      ;from buffer
  2675 00:D1D6: C9 01                cmp     #1              ;if not at start
  2676 00:D1D8: D0 03                bne     ignrcc          ;ignore
  2677 00:D1DA: 4C A8 C8             jmp     xwboot          ;else do warm boot
  2678 00:D1DD: A0 01        ignrcc  ldy     #1              ;get
  2679 00:D1DF: B1 80                lda     (addinp),y      ;count
  2680 00:D1E1: 88                   dey                     ;point to max
  2681 00:D1E2: D1 80                cmp     (addinp),y      ;if length
  2682 00:D1E4: B0 03                bcs     lineen          ;at max jump
  2683 00:D1E6: 4C 1E D1             jmp     nxtinp          ;else loop
  2684 00:D1E9: A9 0D        lineen  lda     #cr             ;get a cr
  2685 00:D1EB: 4C B7 D0     endlin  jmp     pchrot          ;and send
  2686                        ;cr and lf
  2687 00:D1EE: A9 0D        pcrlf   lda     #cr             ;then a
  2688 00:D1F0: 20 B7 D0             jsr     pchrot          ;cr
  2689 00:D1F3: A9 0A                lda     #lf             ;and a
  2690 00:D1F5: 4C B7 D0             jmp     pchrot          ;lf
  2691                        ;retype line
  2692 00:D1F8: AD 10 71     rptlne  lda     bufpsn          ;save point
  2693 00:D1FB: 8D 2C 71             sta     numcnt          ;as count
  2694 00:D1FE: A9 01                lda     #1              ;start position
  2695 00:D200: 48                   pha                     ;save
  2696 00:D201: 68           mrerpt  pla                     ;get position
  2697 00:D202: CE 2C 71             dec     numcnt          ;count down
  2698 00:D205: D0 01                bne     *+3             ;continue if more
  2699 00:D207: 60                   rts                     ;else done
  2700 00:D208: A8                   tay                     ;else make index
  2701 00:D209: C8                   iny                     ;and bump
  2702 00:D20A: 5A                   phy                     ;save index on stack
  2703 00:D20B: B1 80                lda     (addinp),y      ;get char
  2704 00:D20D: 20 8A D0             jsr     output          ;send
  2705 00:D210: 80 EF                bra     mrerpt          ;and loop
  2706                        ;check for printing and backspace if needed
  2707 00:D212: C9 20        chkbs   cmp     #' '            ;compare to space
  2708 00:D214: 90 19                bcc     extdec          ;not printing so done
  2709                        ;do a backspace
  2710 00:D216: AD B7 71     dobs    lda     sysdef+0        ;get backspace
  2711 00:D219: 48                   pha                     ;save it
  2712 00:D21A: 20 BF D0             jsr     nolist          ;send
  2713 00:D21D: A9 20                lda     #' '            ;get space
  2714 00:D21F: 20 BF D0             jsr     nolist          ;send
  2715 00:D222: 68                   pla                     ;get backspace
  2716 00:D223: 4C BF D0             jmp     nolist          ;send it
  2717                        ;test for decimal digit
  2718                        ;if decimal then c=0 else c=1
  2719 00:D226: C9 30        tstdec  cmp     #'0'            ;if under 0
  2720 00:D228: 90 04                bcc     notdec          ;then not decimal
  2721 00:D22A: C9 3A                cmp     #'9'+1          ;if 9 or under is ok
  2722 00:D22C: 90 01                bcc     extdec
  2723 00:D22E: 38           notdec  sec                     ;else not a match
  2724 00:D22F: 60           extdec  rts
  2725                        ;test for hexadecimal digit
  2726                        ;if hex then c=0 else c=1
  2727 00:D230: 20 26 D2     tsthex  jsr     tstdec          ;first try decimal
  2728 00:D233: 90 FA                bcc     extdec          ;ok if dec
  2729 00:D235: C9 41                cmp     #'A'            ;if under A
  2730 00:D237: 90 F5                bcc     notdec          ;then not hex
  2731 00:D239: C9 47                cmp     #'F'+1          ;set c in F compare
  2732 00:D23B: 60                   rts
  2733                        ;bump load address by 128 and return in ay
  Thu Apr 29 2021  3:45                                                                                                    Page 45


  2734 00:D23C: AD D6 70     adjdb   lda     dskbuf          ;get old
  2735 00:D23F: AC D7 70             ldy     dskbuf+1        ;address
  2736 00:D242: 18                   clc                     ;and bump
  2737 00:D243: 69 80                adc     #128            ;by 128
  2738 00:D245: 8D D6 70             sta     dskbuf          ;save low
  2739 00:D248: 90 04                bcc     *+6             ;then bump
  2740 00:D24A: C8                   iny                     ;and save
  2741 00:D24B: 8C D7 70             sty     dskbuf+1        ;high as needed
  2742 00:D24E: 60                   rts
  2743                        ;move record from disk buffer to default buffer
  2744 00:D24F: AD D6 70     mv128   lda     dskbuf          ;get address
  2745 00:D252: AC D7 70             ldy     dskbuf+1
  2746 00:D255: 85 88                sta     movptr          ;and set pointer
  2747 00:D257: 84 89                sty     movptr+1
  2748 00:D259: A0 00                ldy     #0              ;clear index
  2749 00:D25B: B1 88        mvfrom  lda     (movptr),y      ;get byte
  2750 00:D25D: 99 28 01             sta     dflbuf,y        ;move it
  2751 00:D260: C8                   iny
  2752 00:D261: 10 F8                bpl     mvfrom          ;loop until done
  2753 00:D263: 60                   rts
  2754                        ;messages
  2755 00:D264: 20 2D 20 52  romsg   byte    " - R/O$"
       00:D268: 2F 4F 24 
  2756 00:D26B: 20 2D 20 42  bdsmsg  byte    " - BAD SECTOR"
       00:D26F: 41 44 20 53 
       00:D273: 45 43 54 4F 
       00:D277: 52 
  2757 00:D278: 0D 0A 3C 52          byte    cr,lf,"<RET> TO IGNORE -- <OTHER> "
       00:D27C: 45 54 3E 20 
       00:D280: 54 4F 20 49 
       00:D284: 47 4E 4F 52 
       00:D288: 45 20 2D 2D 
       00:D28C: 20 3C 4F 54 
       00:D290: 48 45 52 3E 
       00:D294: 20 
  2758 00:D295: 54 4F 20 41          byte    "TO ABORT$"
       00:D299: 42 4F 52 54 
       00:D29D: 24 
  2759 00:D29E: 0D 0A 50 45  pemmsg  byte    cr,lf,"PEM ERROR ON $"
       00:D2A2: 4D 20 45 52 
       00:D2A6: 52 4F 52 20 
       00:D2AA: 4F 4E 20 24 
  2760 00:D2AE: 20 2D 20 49  sltmsg  byte    " - INVALID DRIVE$"
       00:D2B2: 4E 56 41 4C 
       00:D2B6: 49 44 20 44 
       00:D2BA: 52 49 56 45 
       00:D2BE: 24 
  2761                        ;dummy fcb
  2762 00:D2BF: E5           empty   byte    $E5
  2763                        ;bit mask table
  2764 00:D2C0: 80 40 20 10  bitmsk  byte    128,64,32,16,8,4,2,1
       00:D2C4: 08 04 02 01 
  2765                        ;bit map table
  2766 00:D2C8: 01 02 04 08  bitmap  byte    1,2,4,8,16,32,64,128
       00:D2CC: 10 20 40 80 
  2767                        ;extent mask table (also uses 3 bytes in sabtbl
  2768 00:D2D0: 00 01 03     exmtbl  byte    0,1,3
  2769                        ;sab table
  2770 00:D2D3: 07 0F 1F 3F  sabtbl  byte    7,15,31,63,127
       00:D2D7: 7F 
  2771                        ;-------------------------------------
  2772                        ;DOS/65 System Interface Module (SIM)
  2773                        ;-------------------------------------
  Thu Apr 29 2021  3:45                                                                                                    Page 46


  2774                                org     $/256*256+256
  2775                        
  2776                                include sim123c02.asm
     1                                        globals on
     2                                        case    off
     3                        ;DOS/65 system interface module (SIM)
     4                        ;Version 1.23
     5                        ;
     6                        ;This is the WDC tools version derived from SIM415X.ASM.
     7                        ;This version is designed to work with the:
     8                        ;C02 Pocket SBC with RTC/CF-Card adapter.
     9                        ;
    10                        ;Disk configuration:
    11                        ; a CF 8MB (CF.0)
    12                        ; b CF 8MB (CF.1)
    13                        ; c CF 8MB (CF.2)
    14                        ; d CF 8MB (CF.3)
    15                        ; e CF 8MB (CF.4)
    16                        ; f CF 8MB (CF.5)
    17                        ; g CF 8MB (CF.6)
    18                        ;
    19                        ;Revision history:
    20                        ;       29 July 2017 (1.20W)
    21                        ;               baseline release
    22                        ;       30 August 2017 (1.21W
    23                        ;               updated version to match MON change
    24                        ;
    25                        ; Updated to 1.23 on 5th April 2021 - KM
    26                        ;  Three additional drives added, some 65C02 opcodes, etc.
    27                        ;  Streamline Code, Minor formatting changes.
    28                        ;
    29                        ; Note: This SIM version does not require a Monitor module!
    30                        ; All required code is part of this SIM version and interfaces
    31                        ; directly with calls to C02BIOS and C02Monitor.
    32                        ; This saves hundreds of bytes of ROM space and eliminates
    33                        ; additional JMPs and JSRs that the previous SIM version made.
    34                        ;
    35                        ;**************************************************************************************************
    36                                INCLUDE         C02Constants3.asm       ;Constants/Equates - C02 BIOS/Monitor/Hardware
     1                        ;**************************************************************************************************
     2                        ;*                                                                                                *
     3                        ;*              C02 Constants used for the 3.xx releases of C02BIOS3 and C02Monitor3              *
     4                        ;*                                                                                                *
     5                        ;*                                                                                                *
     6                        ;*                                  03/02/2021 (Day/Month/Year)                                   *
     7                        ;*                                                                                                *
     8                        ;**************************************************************************************************
     9                        ; C02BIOS Version 3.03                                                                            *
    10                        ; - All Constants and Variables are now defined in a single source file (this one) for assembling *
    11                        ; - both the C02BIOS3 and the C02Monitor3. It is also used for the Template for writing code to   *
    12                        ; - be used for the C02 Pocket SBC and Adapters.                                                  *
    13                        ;                                                                                                 *
    14                        ; - Be sure to include this file at the start of any source file that needs it.                   *
    15                        ;                                                                                                 *
    16                        ;**************************************************************************************************
    17                        ;
    18                        ;       - Page Zero definitions ($00 to $9F reserved for user routines)
    19             000000A0   PGZERO_ST       .EQU    $A0                     ;Start of Page Zero usage for C02 Monitor
    20                        ;
    21             000000A0   BUFF_PG0        .EQU    PGZERO_ST+00            ;Default Page zero location for Monitor buffers
    22                        ;
    23             000000A0   INBUFF          .EQU    BUFF_PG0+00             ;Input Buffer - 4 bytes ($A0-$A3)
    24             000000A4   DATABUFF        .EQU    BUFF_PG0+04             ;Data Buffer - 6 bytes ($A4-$A9)
  Thu Apr 29 2021  3:45                                                                                                    Page 47


    25                        ;
    26                        ;       - 16-bit variables:
    27             000000AA   HEXDATAH        .EQU    PGZERO_ST+10            ;Hexadecimal input
    28             000000AB   HEXDATAL        .EQU    PGZERO_ST+11
    29             000000AC   BINVALL         .EQU    PGZERO_ST+12            ;Binary Value for HEX2ASC
    30             000000AD   BINVALH         .EQU    PGZERO_ST+13
    31             000000AE   COMLO           .EQU    PGZERO_ST+14            ;User command address
    32             000000AF   COMHI           .EQU    PGZERO_ST+15
    33             000000B0   INDEXL          .EQU    PGZERO_ST+16            ;Index for address - multiple routines
    34             000000B1   INDEXH          .EQU    PGZERO_ST+17
    35             000000B2   TEMP1L          .EQU    PGZERO_ST+18            ;Index for word temp value used by Memdump
    36             000000B3   TEMP1H          .EQU    PGZERO_ST+19
    37             000000B4   TEMP2L          .EQU    PGZERO_ST+20            ;Index for Text entry
    38             000000B5   TEMP2H          .EQU    PGZERO_ST+21
    39             000000B6   PROMPTL         .EQU    PGZERO_ST+22            ;Prompt string address
    40             000000B7   PROMPTH         .EQU    PGZERO_ST+23
    41             000000B8   SRCL            .EQU    PGZERO_ST+24            ;Source address for memory operations
    42             000000B9   SRCH            .EQU    PGZERO_ST+25
    43             000000BA   TGTL            .EQU    PGZERO_ST+26            ;Target address for memory operations
    44             000000BB   TGTH            .EQU    PGZERO_ST+27
    45             000000BC   LENL            .EQU    PGZERO_ST+28            ;Length address for memory operations
    46             000000BD   LENH            .EQU    PGZERO_ST+29
    47                        ;
    48                        ;       - 8-bit variables and constants:
    49             000000BE   BUFIDX          .EQU    PGZERO_ST+30            ;Buffer index
    50             000000BF   BUFLEN          .EQU    PGZERO_ST+31            ;Buffer length
    51             000000C0   IDX             .EQU    PGZERO_ST+32            ;Temp Indexing
    52             000000C1   IDY             .EQU    PGZERO_ST+33            ;Temp Indexing
    53             000000C2   TEMP1           .EQU    PGZERO_ST+34            ;Temp - Code Conversion routines
    54             000000C3   TEMP2           .EQU    PGZERO_ST+35            ;Temp - Memory/EEPROM/SREC routines - Disassembler
    55             000000C4   TEMP3           .EQU    PGZERO_ST+36            ;Temp - EEPROM/SREC routines
    56             000000C5   CMDFLAG         .EQU    PGZERO_ST+37            ;Command Flag, bit specific, used by many routines
    57             000000C6   OPXMDM          .EQU    PGZERO_ST+38            ;Saved Opcode/Xmodem Flag variable
    58                        ;
    59                        ;       - Xmodem transfer variables
    60             000000C7   CRCHI           .EQU    PGZERO_ST+39            ;CRC hi byte  (two byte variable)
    61             000000C8   CRCLO           .EQU    PGZERO_ST+40            ;CRC lo byte - Operand in Disassembler
    62             000000C9   CRCCNT          .EQU    PGZERO_ST+41            ;CRC retry count - Operand in Disassembler
    63             000000CA   PTRL            .EQU    PGZERO_ST+42            ;Data pointer lo byte - Mnemonic in Disassembler
    64             000000CB   PTRH            .EQU    PGZERO_ST+43            ;Data pointer hi byte - Mnemonic in Disassembler
    65             000000CC   BLKNO           .EQU    PGZERO_ST+44            ;Block number
    66                        ;
    67                        ;        - Macro Loop Counter variables
    68             000000CD   LPCNTL          .EQU    PGZERO_ST+45            ;Loop Count low byte
    69             000000CE   LPCNTH          .EQU    PGZERO_ST+46            ;Loop Count high byte
    70                        ;
    71                        ;       - Spare Monitor byte for future use
    72             000000CF   SPARE_M0        .EQU    PGZERO_ST+47            ;Spare Monitor page zero byte
    73                        ;
    74             000000D0   IDE_STATUS_RAM  .EQU    PGZERO_ST+48            ;IDE RAM-Based Status
    75                        ;
    76             000000D1   IDE_LBA0        .EQU    PGZERO_ST+49            ;IDE LBA Variables for DOS/65
    77             000000D2   IDE_LBA1        .EQU    PGZERO_ST+50
    78             000000D3   IDE_LBA2        .EQU    PGZERO_ST+51
    79                        ;
    80             000000D4   MON_NXTDRV      .EQU    PGZERO_ST+52            ;IDE CHS Variables for DOS/65
    81             000000D5   MON_NXTTRK      .EQU    PGZERO_ST+53
    82             000000D6   MON_NXTSEC      .EQU    PGZERO_ST+54
    83             000000D7   MON_CURDRV      .EQU    PGZERO_ST+55
    84                        ;
    85                        ;       - BIOS variables, pointers, flags located at top of Page Zero
    86             000000D8   BIOS_PG0        .EQU    PGZERO_ST+56            ;Start of BIOS page 0 use ($D8-$FF, 40 bytes total)
    87                        ;
  Thu Apr 29 2021  3:45                                                                                                    Page 48


    88                        ;       - BRK handler routine
    89             000000D8   PCL             .EQU    BIOS_PG0+00             ;Program Counter Low index
    90             000000D9   PCH             .EQU    BIOS_PG0+01             ;Program Counter High index
    91             000000DA   PREG            .EQU    BIOS_PG0+02             ;Temp Status Reg
    92             000000DB   SREG            .EQU    BIOS_PG0+03             ;Temp Stack ptr
    93             000000DC   YREG            .EQU    BIOS_PG0+04             ;Temp Y Reg
    94             000000DD   XREG            .EQU    BIOS_PG0+05             ;Temp X Reg
    95             000000DE   AREG            .EQU    BIOS_PG0+06             ;Temp A Reg
    96                        ;
    97                        ;       - 2691 IRQ handler pointers and status
    98             000000DF   ICNT            .EQU    BIOS_PG0+07             ;Input buffer count
    99             000000E0   IHEAD           .EQU    BIOS_PG0+08             ;Input buffer head pointer
   100             000000E1   ITAIL           .EQU    BIOS_PG0+09             ;Input buffer tail pointer
   101             000000E2   OCNT            .EQU    BIOS_PG0+10             ;Output buffer count
   102             000000E3   OHEAD           .EQU    BIOS_PG0+11             ;Output buffer head pointer
   103             000000E4   OTAIL           .EQU    BIOS_PG0+12             ;Output buffer tail pointer
   104             000000E5   UART_IRT        .EQU    BIOS_PG0+13             ;2691 Interrupt Status byte
   105             000000E6   UART_SRT        .EQU    BIOS_PG0+14             ;2691 Status Register byte
   106                        ;
   107                        ;       - Real-Time Clock variables
   108                        ; These are repurposed for adding a Realtime clock chip DS1511Y
   109                        ; The Ticks, Seconds, Minutes and Hours remain the same in function.
   110                        ; The 16-bit Days variable is replaced however.
   111                        ; - The DAY_DATE is a new variable. To minimize Page Zero usage, it has two functions
   112                        ;       Bits 0-4 represent the days of the Month 1-31
   113                        ;       Bits 5-7 represent the Day of the Week, 1-7 (Saturday=1)
   114                        ; The Months are handled by the upper 4 bits of the MONTH_YEAR variable
   115                        ; The Century is handled by a the Year (0-255) and the lower 4 bits of the MONTH_YEAR variable
   116             000000E7   TICKS           .EQU    BIOS_PG0+15             ;Number of timer countdowns = 1 second (100)
   117             000000E8   SECS            .EQU    BIOS_PG0+16             ;Seconds: 0-59
   118             000000E9   MINS            .EQU    BIOS_PG0+17             ;Minutes: 0-59
   119             000000EA   HOURS           .EQU    BIOS_PG0+18             ;Hours: 0-23
   120             000000EB   DAY_DATE        .EQU    BIOS_PG0+19             ;Day: (bits 5-7) Date: (bits 0-4)
   121             000000EC   MONTH_CENTURY   .EQU    BIOS_PG0+20             ;Month: (bits 4-7) Century: (bits 0-3)
   122             000000ED   YEAR            .EQU    BIOS_PG0+21             ;Century 0-255 plus 4 bits as noted above
   123             000000EE   RTC_TEMP        .EQU    BIOS_PG0+22             ;Temp work byte for updating shared variables
   124                        ;
   125                        ;       - Delay Timer variables
   126             000000EF   MSDELAY         .EQU    BIOS_PG0+23             ;Timer delay countdown byte (255 > 0)
   127             000000F0   SETMS           .EQU    BIOS_PG0+24             ;Set timeout for delay routines - BIOS use only
   128             000000F1   DELLO           .EQU    BIOS_PG0+25             ;Delay value BIOS use only
   129             000000F2   DELHI           .EQU    BIOS_PG0+26             ;Delay value BIOS use only
   130             000000F3   XDL             .EQU    BIOS_PG0+27             ;XL Delay count
   131                        ;
   132                        ;       - Count variables for 10ms benchmark timing
   133             000000F4   MS10_CNT        .EQU    BIOS_PG0+28             ;10ms Count variable
   134             000000F5   SECL_CNT        .EQU    BIOS_PG0+29             ;Seconds Low byte count
   135             000000F6   SECH_CNT        .EQU    BIOS_PG0+30             ;Second High byte count
   136                        ;
   137                        ;       - Adddress and pointers for CF-Card IDE Interface
   138             000000F7   LBA_ADDR_LOW    .EQU    BIOS_PG0+31             ;LBA Transfer Address low byte
   139             000000F8   LBA_ADDR_HIGH   .EQU    BIOS_PG0+32             ;LBA Transfer Address high byte
   140             000000F9   LBA_XFER_CNT    .EQU    BIOS_PG0+33             ;LBA Transfer Count
   141                        
   142             000000FA   LBA_LOW_BYTE    .EQU    BIOS_PG0+34             ;LBA Block number 0-7
   143             000000FB   LBA_HIGH_BYTE   .EQU    BIOS_PG0+35             ;LBA Block number 8-15
   144             000000FC   LBA_EXT_BYTE    .EQU    BIOS_PG0+36             ;LBA Block number 16-23
   145                        ;
   146             000000FD   BIOS_XFERL      .EQU    BIOS_PG0+37             ;BIOS Move Routine low byte
   147             000000FE   BIOS_XFERH      .EQU    BIOS_PG0+38             ;BIOS Move Routine high byte
   148                        ;
   149                        ;       - Timer/Counter Match flag for Delay/Benchmark
   150             000000FF   MATCH           .EQU    BIOS_PG0+39             ;Bit7 used for Delay, Bit6 used for Benchmark
  Thu Apr 29 2021  3:45                                                                                                    Page 49


   151                                                                        ;Bits 4,5 used for BRG Test register status
   152                                                                        ;Bits 3,2,1 used for CF Card Interrupt Handler
   153                        ;
   154                        ;       - Default for RTC tick count - number of IRQs for 1 second
   155             00000064   DF_TICKS        .EQU    100                     ;Timer is 10 milliseconds (100 x 10ms = 1 second)
   156                        ;
   157                        ;**************************************************************************************************
   158             00000200   IBUF            .EQU    $0200                   ;Console Input Buffer - 128 bytes
   159             00000280   OBUF            .EQU    $0280                   ;Console Output Buffer - 128 bytes
   160                        ;**************************************************************************************************
   161             00000300   SOFTVEC         .EQU    $0300                   ;Start of soft vectors
   162                        ;The Interrupt structure is vector based. During startup, Page $03 is loaded from ROM.
   163                        ; The soft vectors are structured to allow inserting additional routines either before
   164                        ; or after the ROM based routines. This allows flexibility and changing of routine priority.
   165                        ;
   166                        ;The main set of vectors occupy the first 16 bytes of Page $03. The ROM handler for
   167                        ; NMI, BRK and IRQ jump to the first 3 vectors. The following 3 vectors are loaded with
   168                        ; return addresses to the ROM handler for each. The following 2 vectors are the cold and
   169                        ; warm entry points for the Monitor. After the basic initialization, the monitor is entered.
   170                        ;
   171                        ;The following vector set allows inserts, pre or post for NMI/BRK/IRQ. There a total of 8 inserts
   172                        ; which occupy 16 bytes. They can be used as required.
   173                        ; Currently, VECINSRT0 will be used if a CF-Card IDE Controller is detected.
   174                        ;
   175             00000300   NMIVEC0         .EQU    SOFTVEC+00              ;NMI Vector Entry 0
   176             00000302   BRKVEC0         .EQU    SOFTVEC+02              ;BRK Vector Entry 0
   177             00000304   IRQVEC0         .EQU    SOFTVEC+04              ;IRQ Vector Entry 0
   178                        ;
   179             00000306   NMIRTVEC0       .EQU    SOFTVEC+06              ;NMI Vector Return 0
   180             00000308   BRKRTVEC0       .EQU    SOFTVEC+08              ;BRK Vector Return 0
   181             0000030A   IRQRTVEC0       .EQU    SOFTVEC+10              ;IRQ Vector Return 0
   182                        ;
   183             0000030C   CLDMNVEC0       .EQU    SOFTVEC+12              ;Monitor Cold Entry Vector 0
   184             0000030E   WRMMNVEC0       .EQU    SOFTVEC+14              ;Monitor Warm Entry Vector 0
   185                        ;
   186             00000310   VECINSRT0       .EQU    SOFTVEC+16              ;1st Vector Insert
   187             00000312   VECINSRT1       .EQU    SOFTVEC+18              ;2nd Vector Insert
   188             00000314   VECINSRT2       .EQU    SOFTVEC+20              ;3rd Vector Insert
   189             00000316   VECINSRT3       .EQU    SOFTVEC+22              ;4th Vector Insert
   190             00000318   VECINSRT4       .EQU    SOFTVEC+24              ;5th Vector Insert
   191             0000031A   VECINSRT5       .EQU    SOFTVEC+26              ;6th Vector Insert
   192             0000031C   VECINSRT6       .EQU    SOFTVEC+28              ;7th Vector Insert
   193             0000031E   VECINSRT7       .EQU    SOFTVEC+30              ;8th Vector Insert
   194                        ;
   195                        ;**************************************************************************************************
   196             00000320   SOFTCFG         .EQU    SOFTVEC+32              ;Start of hardware config parameters
   197                        ;Soft Config values below are loaded from ROM and are the default I/O setup configuration data that
   198                        ; the INIT_x routines use. As a result, you can write a routine to change the I/O configuration
   199                        ; data and use the standard ROM routines to initialize the I/O without restarting or changing ROM
   200                        ; A Reset (HW or coded) will reinitialize the I/O with the ROM default I/O configuration.
   201                        ;
   202                        ;There are a total of 32 Bytes configuration data reserved starting at $0320
   203                        ;
   204             00000320   LOAD_2691       .EQU    SOFTCFG+00              ;SCC2691 Soft Config Data
   205                        ;
   206             00000330   LOAD_IDE        .EQU    SOFTCFG+16              ;IDE/CF-Card Soft Config Data
   207                        ;
   208                        ;Search Buffer is 16 bytes in length. Used to hold search string for text or hex data
   209             00000340   SRCHBUFF        .EQU    SOFTCFG+32              ;Located in Page $03 following Hardware config data
   210                        ;
   211                        ;Xmodem/CRC Loader also provides Motorola S19 Record sense and load. Designed to handle the S19
   212                        ; records from the WDC Assembler/Linker package. This requires a 44 byte buffer to parse each valid
   213                        ; S1 record, located just before the 132 Byte Xmodem frame buffer. Total Buffer space for the
  Thu Apr 29 2021  3:45                                                                                                    Page 50


   214                        ; Xmodem/CRC Loader is 176 bytes
   215                        ;
   216                        ;Valid S-record headers are "S1" and "S9". For S1, the maximum length is "$19" hex. The last S1
   217                        ; record can be less. S9 record is always the last record with no data. WDC Linker also appends
   218                        ; a CR/LF to the end of each record for a total of 44 bytes.
   219             00000350   SRBUFF          .EQU    SOFTCFG+48              ;S-Record buffer, up to 44 bytes in length
   220                        ;
   221                        ;Xmodem frame buffer. The entire Xmodem frame is buffered here and then checked for proper header
   222                        ; and frame number, CRC-16 on the data, then moved to user RAM.
   223             0000037C   RBUFF           .EQU    SOFTCFG+92              ;Xmodem temp 132 byte receive buffer
   224                        ;
   225                        ;Page $03 is completely allocated for Buffers, Config Data and Vector pointers.
   226                        ; Some of the buffer space can be used as needed, provided any required Monitor functions are NOT
   227                        ; being used concurrently.
   228                        ;
   229                        ;Page $04 is Reserved for a second UART Receive/Transmit buffer (future SC28L92)
   230             00000400   IBUF2           .EQU    $0400                   ;Alternate Input Buffer - 128 bytes
   231             00000480   OBUF2           .EQU    $0480                   ;Alternate Output Buffer - 128 bytes
   232                        ;
   233                        ;Page $05 is used for the Realtime Clock NVRAM read and write routines
   234             00000500   NVRAM_DATA      .EQU    $0500                   ;NVRAM Data Buffer address
   235                        ;
   236                        ;Pages $06 - $07 are used for the IDE device Block Buffer (512 bytes)
   237                        ;HSTBUF                                          ;Doubles as HSTBUF for DOS/65
   238             00000600   LBA_BUFFER      .EQU    $0600                   ;Default IDE Block Buffer address
   239                        ; 
   240                        ;XMODEM Control Character Constants
   241             00000001   SOH             .EQU    $01                     ;Start of Block Header
   242             00000004   EOT             .EQU    $04                     ;End of Text marker
   243             00000006   ACK             .EQU    $06                     ;Good Block Acknowledge
   244             00000015   NAK             .EQU    $15                     ;Bad Block acknowledged
   245             00000018   CAN             .EQU    $18                     ;Cancel character
   246                        ;
   247                        ;**************************************************************************************************
   248                        ;RAM location used for the EEPROM Byte Write routine
   249                        ; Note: location moved from $00 to $88 to avoid conflict with EhBasic Page 0 usage
   250                        ;
   251             00000088   BURN_BYTE       .EQU    $0088                   ;Page 0 RAM for EEPROM BYTE write routine
   252                        ;**************************************************************************************************
   253                        ;EnHanced Basic or DOS/65 can be called from the Monitor via the Ctrl-B comand.
   254                        ; The default is different for each of these optional software components.
   255                        ;
   256                        ;The start location is just added here for convienience, but should be changed as needed.
   257                        ;
   258             0000B000   EH_BASIC        .EQU    $B000                   ;Default location for EnHanced BASIC (optional)
   259             0000D680   DOS_65          .EQU    $D680                   ;Default location to Boot DOS/65 (optional)
   260                        ;**************************************************************************************************
   261             0000FE00   IOPAGE          .EQU    $FE00                   ;I/O Page Base Start Address
   262                        ;**************************************************************************************************
   263             0000FE80   SCC2691_BASE    .EQU    IOPAGE+$80              ;Beginning of Console UART address
   264                        ;
   265             0000FE80   UART_MODEREG    .EQU    SCC2691_BASE+$00        ;MR1/MR2 same address, sequential read/write
   266             0000FE81   UART_STATUS     .EQU    SCC2691_BASE+$01        ;UART Status Register (READ)
   267             0000FE81   UART_CLKSEL     .EQU    SCC2691_BASE+$01        ;UART Clock Select Register (WRITE)
   268             0000FE82   UART_BRGTST     .EQU    SCC2691_BASE+$02        ;UART BRG Test Register (READ)
   269             0000FE82   UART_COMMAND    .EQU    SCC2691_BASE+$02        ;UART Command Register (WRITE)
   270             0000FE83   UART_RECEIVE    .EQU    SCC2691_BASE+$03        ;UART Receive Register (READ)
   271             0000FE83   UART_TRANSMIT   .EQU    SCC2691_BASE+$03        ;UART Transmit Register (WRITE)
   272             0000FE84   UART_CLKTEST    .EQU    SCC2691_BASE+$04        ;X1/X16 Test Register (READ)
   273             0000FE84   UART_AUXCR      .EQU    SCC2691_BASE+$04        ;Aux Command Register (WRITE)
   274             0000FE85   UART_ISR        .EQU    SCC2691_BASE+$05        ;Interrupt Status Register (READ)
   275             0000FE85   UART_IMR        .EQU    SCC2691_BASE+$05        ;Interrupt Mask Register (WRITE)
   276             0000FE86   UART_CNTU       .EQU    SCC2691_BASE+$06        ;Counter/Timer Upper Register (READ)
  Thu Apr 29 2021  3:45                                                                                                    Page 51


   277             0000FE86   UART_CNTUP      .EQU    SCC2691_BASE+$06        ;Counter/Timer Upper Preset Register (WRITE)
   278             0000FE87   UART_CNTL       .EQU    SCC2691_BASE+$07        ;Counter/Timer Lower Register (READ)
   279             0000FE87   UART_CNTLP      .EQU    SCC2691_BASE+$07        ;Counter/Timer Lower Preset Register (WRITE)
   280                        ;
   281                        ;Additional Hardware
   282                        ; Adding BIOS definitions for Realtime Clock chip - DS1511Y
   283                        ; uses the first 16 addresses for RTC registers and basic operation
   284                        ; uses two addresses for extended RAM of 256 bytes
   285                        ;
   286                        ; upper addresses are used for a 16-bit IDE interface (below)
   287                        ; NOTE: offset $11 and $12 are unused (reserved per the datasheet).
   288                        ;
   289             0000FE60   RTC_IDE_BASE    .EQU    IOPAGE+$60              ;Beginning of Realtime Clock address
   290                        ;
   291             0000FE60   RTC_SECONDS     .EQU    RTC_IDE_BASE+$00        ;Seconds in BCD 00-59
   292             0000FE61   RTC_MINUTES     .EQU    RTC_IDE_BASE+$01        ;Minutes in BCD 00-59
   293             0000FE62   RTC_HOURS       .EQU    RTC_IDE_BASE+$02        ;Hours in BCD 00-23
   294             0000FE63   RTC_DAY         .EQU    RTC_IDE_BASE+$03        ;Day in BCD 1-7
   295             0000FE64   RTC_DATE        .EQU    RTC_IDE_BASE+$04        ;Date in BCD 1-31
   296             0000FE65   RTC_MONTH       .EQU    RTC_IDE_BASE+$05        ;Month in BCD 1-12
   297             0000FE66   RTC_YEAR        .EQU    RTC_IDE_BASE+$06        ;Year in BCD 00-99
   298             0000FE67   RTC_CENTURY     .EQU    RTC_IDE_BASE+$07        ;Century in BCD 00-39
   299             0000FE68   RTC_ALARM_SEC   .EQU    RTC_IDE_BASE+$08        ;Alarm Seconds in BCD 00-59
   300             0000FE69   RTC_ALARM_MIN   .EQU    RTC_IDE_BASE+$09        ;Alarm Minutes in BCD 00-59
   301             0000FE6A   RTC_ALARM_HRS   .EQU    RTC_IDE_BASE+$0A        ;Alarm Hours in BCD 00-23
   302             0000FE6B   RTC_ALARM_DYDT  .EQU    RTC_IDE_BASE+$0B        ;Alarm Day/Date in BCD 0-7 1-31
   303             0000FE6C   RTC_WTCHDOG_01  .EQU    RTC_IDE_BASE+$0C        ;Watchdog 0.1 / 0.01 Seconds in BCD 00-99
   304             0000FE6D   RTC_WTCHDOG_10  .EQU    RTC_IDE_BASE+$0D        ;Watchdog 10 / 1 Seconds in BCD 00-99
   305             0000FE6E   RTC_CONTROL_A   .EQU    RTC_IDE_BASE+$0E        ;Control A
   306             0000FE6F   RTC_CONTROL_B   .EQU    RTC_IDE_BASE+$0F        ;Control B
   307             0000FE70   RTC_RAM_ADDR    .EQU    RTC_IDE_BASE+$10        ;Extended RAM address
   308             0000FE73   RTC_RAM_DATA    .EQU    RTC_IDE_BASE+$13        ;Extended RAM data
   309                        ;
   310                        ; Adding BIOS definitions for 16-bit IDE interface
   311                        ; uses two addresses for Upper Byte Latch read / write
   312                        ; uses eight addresses for Command Block Registers
   313                        ; uses two addresses for Control Block Registers
   314                        ;
   315             0000FE74   IDE_16_READ     .EQU    RTC_IDE_BASE+$14        ;Upper byte Read address
   316             0000FE75   IDE_16_WRITE    .EQU    RTC_IDE_BASE+$15        ;Upper byte Write address
   317                        ;
   318                        ; Adding BIOS definitions for IDE Controller (HARD DISK, Flash Module, etc.)
   319                        ; Hardware Adapter provides a 16-bit IDE Port per:
   320                        ;        Seagate ATA Interface Reference Manual 36111-001, Rev. C (21st May 1993)
   321                        ;
   322                        ; Compact Flash Adapter BIOS is based on documentation from SanDisk:
   323                        ;       OEM Product Manual Version 12.0 Doc # 20-10-00038m 02/2007
   324                        ;
   325                        ; Control Block Registers
   326             0000FE76   IDE_ALT_STATUS  .EQU    RTC_IDE_BASE+$16        ;Alternate Status Register (READ)
   327             0000FE76   IDE_DEV_CTRL    .EQU    RTC_IDE_BASE+$16        ;Device Control Register (WRITE)
   328             0000FE77   IDE_DRV_ADDR    .EQU    RTC_IDE_BASE+$17        ;Drive Address Register (READ)
   329                        ;
   330                        ; Command Block Registers
   331             0000FE78   IDE_DATA        .EQU    RTC_IDE_BASE+$18        ;Data Register (R/W)
   332             0000FE79   IDE_ERROR       .EQU    RTC_IDE_BASE+$19        ;Error Register (READ)
   333             0000FE79   IDE_FEATURE     .EQU    RTC_IDE_BASE+$19        ;Feature Register (WRITE)
   334             0000FE7A   IDE_SCT_CNT     .EQU    RTC_IDE_BASE+$1A        ;Sector Count Register
   335             0000FE7B   IDE_SCT_NUM     .EQU    RTC_IDE_BASE+$1B        ;Sector Number Register
   336             0000FE7C   IDE_CYL_LOW     .EQU    RTC_IDE_BASE+$1C        ;Cylinder Low Register
   337             0000FE7D   IDE_CYL_HIGH    .EQU    RTC_IDE_BASE+$1D        ;Cylinder High Register
   338             0000FE7E   IDE_DRV_HEAD    .EQU    RTC_IDE_BASE+$1E        ;Drive/Head Register
   339             0000FE7F   IDE_STATUS      .EQU    RTC_IDE_BASE+$1F        ;Status Register (READ)
  Thu Apr 29 2021  3:45                                                                                                    Page 52


   340             0000FE7F   IDE_COMMAND     .EQU    RTC_IDE_BASE+$1F        ;Command Register (WRITE)
   341                        ;
   342                        ;**************************************************************************************************
   343                        ;
   344                        ;**************************************************************************************************
   345                        ;Monitor JUMP table: 32 JUMP calls are available.
   346                        ; Calls 02-04 are currently Reserved
   347                        ;
   348             0000E000   M_COLD_MON              .EQU    $E000           ;Call 00   Monitor Cold Start
   349             0000E003   M_WARM_MON              .EQU    $E003           ;Call 01   Monitor Warm Start
   350                        ;
   351             0000E009   M_MOVE_RAM              .EQU    $E009           ;Call 03   Move Memory (variables previously set)
   352             0000E00C   M_FILL_RAM              .EQU    $E00C           ;Call 04   Fill Memory (variables previously set)
   353             0000E00F   M_BSOUT                 .EQU    $E00F           ;Call 05   Send Backspace
   354             0000E012   M_XMDM_SAVE             .EQU    $E012           ;Call 06   Xmodem Save Entry
   355             0000E015   M_XMDM_LOAD             .EQU    $E015           ;Call 07   Xmodem Load Entry
   356             0000E018   M_BENCH                 .EQU    $E018           ;Call 08   Benchmark Start
   357             0000E01B   M_QUITB                 .EQU    $E01B           ;Call 09   Benchmark Stop/End
   358             0000E01E   M_UPTIME                .EQU    $E01E           ;Call 10   Monitor Uptime
   359             0000E021   M_PRSTAT1               .EQU    $E021           ;Call 11   CPU Status Display
   360             0000E024   M_DIS_LINE              .EQU    $E024           ;Call 12   Disassemble Line of Code
   361             0000E027   M_INCINDEX              .EQU    $E027           ;Call 13   Increment Index by 1
   362             0000E02A   M_DECINDEX              .EQU    $E02A           ;Call 14   Decrement Index by 1
   363             0000E02D   M_RDLINE                .EQU    $E02D           ;Call 15   Read Line from Terminal
   364             0000E030   M_RDCHAR                .EQU    $E030           ;Call 16   Read Character from Terminal
   365             0000E033   M_HEXIN2                .EQU    $E033           ;Call 17   Hex input 2 characters
   366             0000E036   M_HEXIN4                .EQU    $E036           ;Call 18   Hex input 4 characters
   367             0000E039   M_HEX2ASC               .EQU    $E039           ;Call 19   Convert Hex to ASCII
   368             0000E03C   M_BIN2ASC               .EQU    $E03C           ;Call 20   Convert Binary to ASCII
   369             0000E03F   M_ASC2BIN               .EQU    $E03F           ;Call 21   Convert ASCII to Binary
   370             0000E042   M_BEEP                  .EQU    $E042           ;Call 22   Send BEEP to Terminal
   371             0000E045   M_DOLLAR                .EQU    $E045           ;Call 23   Send $ to Terminal
   372             0000E048   M_CROUT                 .EQU    $E048           ;Call 24   Send C/R to Terminal
   373             0000E04B   M_SPC                   .EQU    $E04B           ;Call 25   Send ASCII Space to Terminal
   374             0000E04E   M_PRBYTE                .EQU    $E04E           ;Call 26   Print Byte to Terminal
   375             0000E051   M_PRWORD                .EQU    $E051           ;Call 27   Print Word to Terminal
   376             0000E054   M_PRASC                 .EQU    $E054           ;Call 28   Print ASCII to Terminal
   377             0000E057   M_PROMPT                .EQU    $E057           ;Call 29   Send Message by number to Terminal
   378             0000E05A   M_PROMPTR               .EQU    $E05A           ;Call 30   Send Message by address to Terminal
   379             0000E05D   M_CONTINUE              .EQU    $E05D           ;Call 31   Y/N Prompt to Continue Command
   380                        ;
   381                        ;**************************************************************************************************
   382                        ;BIOS JUMP Table starts here:
   383                        ;       - BIOS calls are listed below - total of 32
   384                        ;       - Reserved calls are for future hardware support
   385                        ;
   386             0000FF00   B_IDE_RESET             .EQU    $FF00           ;Call 00   Reset IDE controller
   387             0000FF03   B_IDE_GET_STAT          .EQU    $FF03           ;Call 01   Get extended status from IDE
   388             0000FF06   B_IDE_IDENTIFY          .EQU    $FF06           ;Call 02   Execute/Load identity data
   389             0000FF09   B_IDE_READ_LBA          .EQU    $FF09           ;Call 03   Read a LBA from IDE
   390             0000FF0C   B_IDE_WRITE_LBA         .EQU    $FF0C           ;Call 04   Write a LBA to IDE
   391             0000FF0F   B_IDE_VERFY_LBA         .EQU    $FF0F           ;Call 05   Verify LBA to IDE
   392             0000FF12   B_IDE_SET_LBA           .EQU    $FF12           ;Call 06   Set the requested LBA
   393             0000FF15   B_IDE_SET_ADDR          .EQU    $FF15           ;Call 07   Set the data transfer address
   394                        ;
   395             0000FF18   B_RTC_NVRD              .EQU    $FF18           ;Call 08   Read RTC NVRAM data (256 bytes)
   396             0000FF1B   B_RTC_NVWR              .EQU    $FF1B           ;Call 09   Write RTC NVRAM data (256 bytes)
   397             0000FF1E   B_RTC_INIT              .EQU    $FF1E           ;Call 10   Initialize software RTC from HW RTC
   398                        ;
   399             0000FF21   B_Reserve11             .EQU    $FF21           ;Call 11
   400             0000FF24   B_Reserve12             .EQU    $FF24           ;Call 12
   401             0000FF27   B_Reserve13             .EQU    $FF27           ;Call 13
   402             0000FF2A   B_Reserve14             .EQU    $FF2A           ;Call 14
  Thu Apr 29 2021  3:45                                                                                                    Page 53


   403                        ;
   404             0000FF2D   B_CNT_INIT              .EQU    $FF2D           ;Call 15   Initalize Benchmark Counter
   405             0000FF30   B_CNT_STRT              .EQU    $FF30           ;Call 16   Start Benchmark Counter
   406             0000FF33   B_CNT_STOP              .EQU    $FF33           ;Call 17   Stop Benchmark Counter
   407                        ;
   408             0000FF36   B_CHRIN_NW              .EQU    $FF36           ;Call 18   Console character in, no waiting
   409             0000FF39   B_CHRIN                 .EQU    $FF39           ;Call 19   Console console in, waits for data
   410             0000FF3C   B_CHROUT                .EQU    $FF3C           ;Call 20   Console character out
   411                        ;
   412             0000FF3F   B_SET_DLY               .EQU    $FF3F           ;Call 21   Sets timer driven delay (16-bit)
   413             0000FF42   B_EXE_MSDLY             .EQU    $FF42           ;Call 22   Execute 10 millisecond delay count
   414             0000FF45   B_EXE_LGDLY             .EQU    $FF45           ;Call 23   Execute 16-bit delay count
   415             0000FF48   B_EXE_XLDLY             .EQU    $FF48           ;Call 24   Extended period delay (1-256 times above)
   416                        ;
   417             0000FF4B   B_INIT_VEC              .EQU    $FF4B           ;Call 25   Initialize System Soft Vectors ($0300)
   418             0000FF4E   B_INIT_CFG              .EQU    $FF4E           ;Call 26   Initialize Soft Configuration Data ($0320)
   419             0000FF51   B_INIT_2691             .EQU    $FF51           ;Call 27   Initalize the 2691 UART (console/timer)
   420             0000FF54   B_RESET_2691            .EQU    $FF54           ;Call 28   Reset the 2691 UART
   421                        ;
   422             0000FF57   B_WRMMNVEC0             .EQU    $FF57           ;Call 29   Warm Monitor Vector entry
   423             0000FF5A   B_CLDMNVEC0             .EQU    $FF5A           ;Call 30   Cold Monitor Vector entry
   424             0000FF5D   B_COLDSTRT              .EQU    $FF5D           ;Call 31   Cold Start/Boot system (enters Monitor)
   425                        ;
   426                        ;**************************************************************************************************
   427                        ;
   428                                .END
    37                        ;**************************************************************************************************
    38                        ;
    39                        ;**************************************************************************************************
    40                        ;Fixed parameters
    41             00000001   CLREOL                  .EQU     1              ;clear to eol (ctl-a)
    42             00000002   CLREOS                  .EQU     2              ;clear to eos (ctl-b)
    43             00000008   BS                      .EQU     8              ;backspace (ctl-h)
    44             0000001B   ESC                     .EQU     $1B            ;escape char
    45                        ;
    46                        ;**************************************************************************************************
    47                        ;
    48                        ;pem constants on entry to write
    49             00000000   wrall           .EQU    0               ;write to allocated
    50             00000001   wrdir           .EQU    1               ;write to directory
    51             00000002   wrual           .EQU    2               ;write to unallocated
    52                        ;main program
    53                        ;start of sim
    54                        sim
    55                        ;opening id message
    56 00:D300: 0D 0A 53 49  sim_opnmsg      .DB     CR,LF,"SIM V1.23 for C02 Pocket SBC"
       00:D304: 4D 20 56 31 
       00:D308: 2E 32 33 20 
       00:D30C: 66 6F 72 20 
       00:D310: 43 30 32 20 
       00:D314: 50 6F 63 6B 
       00:D318: 65 74 20 53 
       00:D31C: 42 43 
    57 00:D31E: 0D 0A 33 32                  .DB     CR,LF,"32K ROM DOS/65 V3.03",0
       00:D322: 4B 20 52 4F 
       00:D326: 4D 20 44 4F 
       00:D32A: 53 2F 36 35 
       00:D32E: 20 56 33 2E 
       00:D332: 30 33 00 
    58                        ;
    59 00:D335: 0D 0A 44 69  IO_ERR_MSG      .DB     CR,LF,"Disk I/O Error!",0
       00:D339: 73 6B 20 49 
       00:D33D: 2F 4F 20 45 
  Thu Apr 29 2021  3:45                                                                                                    Page 54


       00:D341: 72 72 6F 72 
       00:D345: 21 00 
    60                        ;
    61                        ;Cold entry from DOS/65 Boot code below
    62 00:D347: A9 00        sim_boot        lda     #<sim_opnmsg    ;point to message
    63 00:D349: A0 D3                        ldy     #>sim_opnmsg
    64 00:D34B: 20 03 D6                     jsr     mon_txtout      ;send it
    65                        ;Initialize iostat
    66 00:D34E: 9C 06 01                     stz     iostat          ;clear I/O status
    67                        ;set up jumps into dos/65 in page one
    68                        ; NOTE: changed to absolute indexed using Y register.
    69                        ;       WDC Tools has a bug using X register when the
    70                        ;       operand is $0100-1 (should be $00FF, but becomes $FF)
    71                        sim_setup
    72                        ;first clear key de-blocking variables
    73 00:D351: 9C C3 71                     stz     sim_hstact      ;set host buffer inactive
    74 00:D354: 9C C4 71                     stz     sim_unacnt      ;clear unalloc count
    75                        ;
    76 00:D357: A0 06                        ldy     #6              ;set index to 6
    77 00:D359: B9 6B D3     simset_lp       lda     sim_inttbl-1,y  ;get SIM table data
    78 00:D35C: 99 FF 00                     sta     $0100-1,y       ;store into page $01 PEM area
    79 00:D35F: 88                           dey                     ;decrement index
    80 00:D360: D0 F7                        bne     simset_lp       ;loop until done
    81 00:D362: A9 28                        lda     #<dflbuf        ;get low buffer
    82 00:D364: A0 01                        ldy     #>dflbuf        ;and high buffer
    83 00:D366: 20 B9 D5                     jsr     sim_setdma      ;and set DMA
    84 00:D369: 4C 00 70                     jmp     ccmram          ;then go to CCM
    85                        ;initialization table
    86 00:D36C: 4C           sim_inttbl      .DB     $4C
    87 00:D36D: 83 71                        .DW     sim_wboote
    88 00:D36F: 4C                           .DB     $4C
    89 00:D370: 00 71                        .DW     pemram
    90                        ;warm boot-read DOS/65 back except SIM and then
    91                        ;jump to CCM. IOSTAT and hence the default drive
    92                        ;and user are not altered by warm boot.
    93                        ; note: WARM BOOT does not read from any drive
    94                        ; as it is ROM based, so it's only a refresh of
    95                        ; ROM data to RAM and set the default drive.
    96 00:D372: A2 FF        sim_wboot       ldx     #$FF            ;set stack
    97 00:D374: 9A                           txs                     ;pointer
    98 00:D375: 20 96 D6                     jsr     mon_warm        ;reresh RAM data from ROM
    99 00:D378: AD 06 01                     lda     iostat          ;set default drive
   100 00:D37B: 20 80 D3                     jsr     sim_seldsk
   101 00:D37E: 80 D1                        bra     sim_setup       ;go set up
   102                        
   103                        ;select disk
   104 00:D380: 29 07        sim_seldsk      and     #%00000111      ;eight drives only
   105 00:D382: 85 D4                        sta     mon_nxtdrv      ;Save active Drive number
   106 00:D384: 8D C1 71                     sta     sim_sekdsk      ;save for later
   107 00:D387: 0A                           asl     a               ;multiply by two
   108 00:D388: AA                           tax                     ;make an index
   109 00:D389: BD 90 D3                     lda     sim_dcbtbl,x    ;get address
   110 00:D38C: BC 91 D3                     ldy     sim_dcbtbl+1,x
   111 00:D38F: 60                           rts
   112                        ;table of dcb addresses.
   113                        ; - first seven drives are in use, all eight require entries! - KM
   114                        ; added a "_" in dcb definitions, as dcbh causes assembly error - KM
   115 00:D390: DB D6        sim_dcbtbl      .DW     dcb_a
   116 00:D392: E9 D6                        .DW     dcb_b
   117 00:D394: F7 D6                        .DW     dcb_c
   118 00:D396: 05 D7                        .DW     dcb_d
   119 00:D398: 13 D7                        .DW     dcb_e
   120 00:D39A: 21 D7                        .DW     dcb_f
  Thu Apr 29 2021  3:45                                                                                                    Page 55


   121 00:D39C: 2F D7                        .DW     dcb_g
   122 00:D39E: 00 00                        .DW     0               ;no drive h
   123                        
   124                        ;see if de-blocking required for sekdsk
   125                        ;returns number of dos/65 records per physical
   126                        ;sector in a and
   127                        ;returns z=1 if no de-blocking required else z=0
   128 00:D3A0: AE C1 71     sim_tstdbl      ldx     sim_sekdsk      ;get desired disk
   129                        ;see if de-blocking required for disk x
   130 00:D3A3: BD A9 D3     sim_tstdbx      lda     sim_spttbl,x    ;get dos/65 records/host sector
   131 00:D3A6: C9 01                        cmp     #1              ;test for no deblock
   132 00:D3A8: 60                           rts                     ;return
   133                        ;table containing number of DOS/65 records
   134                        ;per host physical sector.  if entry is 1
   135                        ;then de-blocking is skipped.
   136                        ;note that these two tables contain eight
   137                        ;entries even though only the first seven are used.
   138 00:D3A9: 04 04 04 04  sim_spttbl      .DB     4,4,4,4,4,4,4,4
       00:D3AD: 04 04 04 04 
   139                        ;table of records/block
   140 00:D3B1: 10 10 10 10  sim_rbltbl      .DB     16,16,16,16,16,16,16,16
       00:D3B5: 10 10 10 10 
   141                        ;home the selected disk
   142 00:D3B9: AD C2 71     sim_home        lda     sim_hstwrt      ;check for pending write
   143 00:D3BC: D0 03                        bne     sim_xlate       ;there is so skip (borrowed RTS)
   144 00:D3BE: 9C C3 71                     stz     sim_hstact      ;else, clear host active flag
   145 00:D3C1: 60           sim_xlate       rts                     ;return
   146                        ;translate record in ay for nxtdrv
   147                        ; - translation is only done for 8 in, sssd
   148                        ; - drives - no longer in system.
   149                        ; Note: use existing RTS in code above, save a byte.
   150                        ;sim_xlate       rts                     ;do nothing
   151                        ;
   152                        ;read the selected dos/65 record.
   153 00:D3C2: 9C C4 71     sim_read        stz     sim_unacnt      ;clear unallocated count
   154 00:D3C5: A2 01                        ldx     #1              ;x <-- 1
   155 00:D3C7: 8E D7 71                     stx     sim_readop      ;say is read operation
   156 00:D3CA: 8E D6 71                     stx     sim_rsflag      ;must read data
   157 00:D3CD: E8                           inx                     ;x <-- wrual
   158 00:D3CE: 8E D8 71                     stx     sim_wrtype      ;treat as unalloc
   159 00:D3D1: 4C 96 D4                     jmp     sim_rwoper      ;to perform the read
   160                        ;write the selected dos/65 record.
   161 00:D3D4: 8D D8 71     sim_write       sta     sim_wrtype      ;save param from pem
   162 00:D3D7: 20 A0 D3                     jsr     sim_tstdbl      ;see if one rec/sec
   163 00:D3DA: D0 05                        bne     ?B2             ;if not use type passed
   164 00:D3DC: A9 01                        lda     #wrdir          ;if is say directory
   165 00:D3DE: 8D D8 71                     sta     sim_wrtype      ;to force write
   166 00:D3E1: 9C D7 71     ?B2             stz     sim_readop      ;say is not a read operation
   167 00:D3E4: AD D8 71                     lda     sim_wrtype      ;get write type back
   168 00:D3E7: C9 02                        cmp     #wrual          ;write unallocated?
   169 00:D3E9: D0 24                        bne     ?B3             ;check for unalloc
   170                        ;write to unallocated, set parameters
   171 00:D3EB: AE C1 71                     ldx     sim_sekdsk      ;get next disk number
   172 00:D3EE: BD B1 D3                     lda     sim_rbltbl,x    ;get records/block
   173 00:D3F1: 8D C4 71                     sta     sim_unacnt
   174 00:D3F4: 8E D0 71                     stx     sim_unadsk      ;unadsk <-- sekdsk
   175 00:D3F7: AD C5 71                     lda     sim_sektrk
   176 00:D3FA: AC C6 71                     ldy     sim_sektrk+1
   177 00:D3FD: 8D D1 71                     sta     sim_unatrk      ;unatrk <-- sectrk
   178 00:D400: 8C D2 71                     sty     sim_unatrk+1
   179 00:D403: AD C7 71                     lda     sim_seksec
   180 00:D406: AC C8 71                     ldy     sim_seksec+1
   181 00:D409: 8D D3 71                     sta     sim_unasec      ;unasec <-- seksec
  Thu Apr 29 2021  3:45                                                                                                    Page 56


   182 00:D40C: 8C D4 71                     sty     sim_unasec+1
   183                        ;check for write to unallocated record
   184 00:D40F: AD C4 71     ?B3             lda     sim_unacnt      ;any unalloc remain?
   185 00:D412: F0 72                        beq     sim_alloc       ;skip if not
   186                        ;more unallocated records remain
   187 00:D414: CE C4 71                     dec     sim_unacnt      ;unacnt <-- unacnt-1
   188 00:D417: AD C1 71                     lda     sim_sekdsk
   189 00:D41A: CD D0 71                     cmp     sim_unadsk      ;sekdsk = unadsk?
   190 00:D41D: D0 67                        bne     sim_alloc       ;skip if not
   191                        ;disks are the same
   192 00:D41F: AD D1 71                     lda     sim_unatrk      ;sektrk = unatrk?
   193 00:D422: CD C5 71                     cmp     sim_sektrk
   194 00:D425: D0 5F                        bne     sim_alloc       ;no so skip
   195 00:D427: AD D2 71                     lda     sim_unatrk+1
   196 00:D42A: CD C6 71                     cmp     sim_sektrk+1
   197 00:D42D: D0 57                        bne     sim_alloc       ;skip if not
   198                        ;tracks are the same
   199 00:D42F: AD D3 71                     lda     sim_unasec      ;seksec = unasec?
   200 00:D432: CD C7 71                     cmp     sim_seksec
   201 00:D435: D0 4F                        bne     sim_alloc       ;no so skip
   202 00:D437: AD D4 71                     lda     sim_unasec+1
   203 00:D43A: CD C8 71                     cmp     sim_seksec+1
   204 00:D43D: D0 47                        bne     sim_alloc       ;skip if not
   205                        ;match, move to next sector for future ref
   206 00:D43F: EE D3 71                     inc     sim_unasec      ;unasec = unasec+1
   207 00:D442: D0 03                        bne     ?B4
   208 00:D444: EE D4 71                     inc     sim_unasec+1
   209                        ;calculate dos/65 records/track
   210 00:D447: AD C1 71     ?B4             lda     sim_sekdsk      ;get disk number
   211 00:D44A: 0A                           asl     a               ;mult by two
   212 00:D44B: AA                           tax                     ;make an index
   213 00:D44C: BD 90 D3                     lda     sim_dcbtbl,x    ;get dcb start
   214 00:D44F: BC 91 D3                     ldy     sim_dcbtbl+1,x
   215 00:D452: 85 8E                        sta     sim_dcbpnt      ;set low operand
   216 00:D454: 84 8F                        sty     sim_dcbpnt+1    ;then high operand
   217                        ;point has address now get spt at byte 2,3
   218 00:D456: A0 02                        ldy     #2              ;start at byte 2
   219 00:D458: A2 00                        ldx     #0              ;start save in low
   220 00:D45A: B1 8E        ?B5             lda     (sim_dcbpnt),y  ;get value
   221 00:D45C: 9D D9 71                     sta     sim_d65spt,x    ;and save
   222 00:D45F: C8                           iny
   223 00:D460: E8                           inx
   224 00:D461: E0 02                        cpx     #2              ;see if done
   225 00:D463: D0 F5                        bne     ?B5             ;loop if not
   226                        ;check for end of track
   227 00:D465: AD D3 71                     lda     sim_unasec      ;end of track?
   228 00:D468: CD D9 71                     cmp     sim_d65spt      ;count dos/65 sectors
   229 00:D46B: AD D4 71                     lda     sim_unasec+1
   230 00:D46E: ED DA 71                     sbc     sim_d65spt+1
   231 00:D471: 90 0E                        bcc     ?B6             ;skip if no overflow
   232                        ;overflow to next track
   233 00:D473: 9C D3 71                     stz     sim_unasec      ;unasec <-- 0
   234 00:D476: 9C D4 71                     stz     sim_unasec+1
   235 00:D479: EE D1 71                     inc     sim_unatrk      ;unatrk <-- unatrk+1
   236 00:D47C: D0 03                        bne     ?B6
   237 00:D47E: EE D2 71                     inc     sim_unatrk+1
   238                        ;match found, mark as unnecessary read
   239 00:D481: 9C D6 71     ?B6             stz     sim_rsflag      ;rsflag <-- 0
   240 00:D484: 80 10                        bra     sim_rwoper      ;to perform the write
   241                        ;not an unallocated record, requires pre-read
   242 00:D486: 9C C4 71     sim_alloc       stz     sim_unacnt      ;unacnt <-- 0
   243                        ;say preread required
   244 00:D489: A2 01                        ldx     #1              ;x <-- 1
  Thu Apr 29 2021  3:45                                                                                                    Page 57


   245 00:D48B: 8E D6 71                     stx     sim_rsflag      ;rsflag <-- 1
   246                        ;check for single record/sector - and if so
   247                        ;then say preread not required.
   248 00:D48E: 20 A0 D3                     jsr     sim_tstdbl      ;test
   249 00:D491: D0 03                        bne     sim_rwoper      ;more than one
   250 00:D493: 9C D6 71                     stz     sim_rsflag      ;say no preread
   251                        ;common code for read and write follows
   252                        ;enter here to perform the read/write
   253 00:D496: 9C D5 71     sim_rwoper      stz     sim_erflag      ;set no errors (yet)
   254 00:D499: AD C7 71                     lda     sim_seksec      ;compute host sector
   255 00:D49C: AC C8 71                     ldy     sim_seksec+1
   256 00:D49F: 8D CE 71                     sta     sim_sekhst
   257 00:D4A2: 8C CF 71                     sty     sim_sekhst+1
   258 00:D4A5: 20 A0 D3                     jsr     sim_tstdbl      ;get records/sector
   259 00:D4A8: 4A                           lsr     a               ;divide by two
   260 00:D4A9: AA                           tax                     ;make a counter
   261 00:D4AA: F0 09                        beq     ?B2             ;done if zero
   262 00:D4AC: 4E CF 71     ?L2             lsr     sim_sekhst+1    ;do high
   263 00:D4AF: 6E CE 71                     ror     sim_sekhst      ;then low
   264 00:D4B2: CA                           dex
   265 00:D4B3: D0 F7                        bne     ?L2             ;loop if more
   266                        ;active host sector?
   267 00:D4B5: AD C3 71     ?B2             lda     sim_hstact      ;host active flag
   268 00:D4B8: 48                           pha                     ;save flag
   269 00:D4B9: E8                           inx                     ;x <-- 1
   270 00:D4BA: 8E C3 71                     stx     sim_hstact
   271 00:D4BD: 68                           pla                     ;get flag back
   272 00:D4BE: F0 30                        beq     sim_filhst      ;fill host if not active
   273                        ;host buffer active, same as seek buffer?
   274 00:D4C0: AD C1 71                     lda     sim_sekdsk
   275 00:D4C3: CD C9 71                     cmp     sim_hstdsk      ;same disk?
   276 00:D4C6: D0 20                        bne     sim_nmatch
   277                        ;same disk, same track?
   278 00:D4C8: AD CA 71                     lda     sim_hsttrk      ;sektrk = hsttrk?
   279 00:D4CB: CD C5 71                     cmp     sim_sektrk
   280 00:D4CE: D0 18                        bne     sim_nmatch      ;no
   281 00:D4D0: AD CB 71                     lda     sim_hsttrk+1
   282 00:D4D3: CD C6 71                     cmp     sim_sektrk+1
   283 00:D4D6: D0 10                        bne     sim_nmatch
   284                        ;same disk, same track, same sector?
   285 00:D4D8: AD CE 71                     lda     sim_sekhst      ;sekhst = hstsec?
   286 00:D4DB: CD CC 71                     cmp     sim_hstsec
   287 00:D4DE: D0 08                        bne     sim_nmatch      ;no
   288 00:D4E0: AD CF 71                     lda     sim_sekhst+1
   289 00:D4E3: CD CD 71                     cmp     sim_hstsec+1
   290 00:D4E6: F0 37                        beq     sim_match       ;skip if match
   291                        ;proper disk, but not correct sector
   292 00:D4E8: AD C2 71     sim_nmatch      lda     sim_hstwrt      ;host written?
   293 00:D4EB: F0 03                        beq     sim_filhst      ;skip if was
   294 00:D4ED: 20 7D D5                     jsr     sim_writeh      ;else clear host buff
   295                        ;may have to fill the host buffer
   296                        ;so set host parameters
   297 00:D4F0: AD C1 71     sim_filhst      lda     sim_sekdsk
   298 00:D4F3: 8D C9 71                     sta     sim_hstdsk
   299 00:D4F6: AD C5 71                     lda     sim_sektrk
   300 00:D4F9: AC C6 71                     ldy     sim_sektrk+1
   301 00:D4FC: 8D CA 71                     sta     sim_hsttrk
   302 00:D4FF: 8C CB 71                     sty     sim_hsttrk+1
   303 00:D502: AD CE 71                     lda     sim_sekhst
   304 00:D505: AC CF 71                     ldy     sim_sekhst+1
   305 00:D508: 8D CC 71                     sta     sim_hstsec
   306 00:D50B: 8C CD 71                     sty     sim_hstsec+1
   307 00:D50E: AD D6 71                     lda     sim_rsflag      ;need to read?
  Thu Apr 29 2021  3:45                                                                                                    Page 58


   308 00:D511: F0 09                        beq     sim_noread      ;no
   309                        ;read desired physical sector from host
   310 00:D513: 20 87 D5                     jsr     sim_hcom        ;set parameters
   311 00:D516: 20 21 D6                     jsr     mon_rdesec      ;to rom
   312 00:D519: 8D D5 71                     sta     sim_erflag      ;save result
   313 00:D51C: 9C C2 71     sim_noread      stz     sim_hstwrt      ;clear, no pending write
   314                        ;copy data to or from buffer
   315 00:D51F: 64 90        sim_match       stz     sim_movepnt     ;clear pointer, later we'll set read
   316 00:D521: 64 91                        stz     sim_movepnt+1
   317 00:D523: 20 A0 D3                     jsr     sim_tstdbl      ;get records/sector
   318 00:D526: F0 3F                        beq     sim_endmve      ;done if no deblocking
   319 00:D528: 3A                           dec     a               ;decrement by one
   320 00:D529: 2D C7 71                     and     sim_seksec      ;mask sector number
   321 00:D52C: AA                           tax                     ;make a counter
   322 00:D52D: F0 10                        beq     sim_nooff       ;done if zero
   323 00:D52F: 18           ?L2             clc
   324 00:D530: A5 90                        lda     sim_movepnt
   325 00:D532: 69 80                        adc     #128
   326 00:D534: 85 90                        sta     sim_movepnt
   327 00:D536: A5 91                        lda     sim_movepnt+1
   328 00:D538: 69 00                        adc     #0
   329 00:D53A: 85 91                        sta     sim_movepnt+1
   330 00:D53C: CA                           dex
   331 00:D53D: D0 F0                        bne     ?L2             ;loop if more
   332                        ;pointer has relative host buffer address
   333 00:D53F: 18           sim_nooff       clc                     ;add hstbuf
   334 00:D540: A9 00                        lda     #<hstbuf
   335 00:D542: 65 90                        adc     sim_movepnt
   336 00:D544: 85 90                        sta     sim_movepnt
   337 00:D546: A9 06                        lda     #>hstbuf
   338 00:D548: 65 91                        adc     sim_movepnt+1
   339 00:D54A: 85 91                        sta     sim_movepnt+1
   340                        ;at this point pointer contains the address of the
   341                        ;record of interest in the hstbuf buffer.
   342 00:D54C: A0 7F                        ldy     #127            ;length of move - 1
   343 00:D54E: AE D7 71                     ldx     sim_readop      ;which way?
   344 00:D551: D0 0D                        bne     sim_rmove       ;skip if read
   345                        ;write operation so move from dmaadr to mvepnt
   346 00:D553: E8                           inx                     ;x <-- 1
   347 00:D554: 8E C2 71                     stx     sim_hstwrt      ;hstwrt <-- 1
   348 00:D557: B1 8C        ?L2             lda     (sim_dmaadr),y
   349 00:D559: 91 90                        sta     (sim_movepnt),y
   350 00:D55B: 88                           dey
   351 00:D55C: 10 F9                        bpl     ?L2             ;loop if more
   352 00:D55E: 30 07                        bmi     sim_endmve      ;else done
   353                        ;read operation so move from mvepnt to dmaadr
   354 00:D560: B1 90        sim_rmove       lda     (sim_movepnt),y
   355 00:D562: 91 8C                        sta     (sim_dmaadr),y
   356 00:D564: 88                           dey
   357 00:D565: 10 F9                        bpl     sim_rmove       ;loop if more
   358                        ;data has been moved to/from host buffer
   359 00:D567: AD D8 71     sim_endmve      lda     sim_wrtype      ;write type
   360 00:D56A: C9 01                        cmp     #wrdir          ;to directory?
   361 00:D56C: D0 0B                        bne     ?B2             ;done if not
   362                        ;clear host buffer for directory write
   363 00:D56E: AD D5 71                     lda     sim_erflag      ;get error flag
   364 00:D571: D0 06                        bne     ?B2             ;done if errors
   365 00:D573: 8D C2 71                     sta     sim_hstwrt      ;say buffer written
   366 00:D576: 20 7D D5                     jsr     sim_writeh
   367 00:D579: AD D5 71     ?B2             lda     sim_erflag
   368 00:D57C: 60                           rts
   369                        ;writeh performs the physical write to
   370                        ;the host disk.
  Thu Apr 29 2021  3:45                                                                                                    Page 59


   371 00:D57D: 20 87 D5     sim_writeh      jsr     sim_hcom        ;set-up params
   372 00:D580: 20 19 D6                     jsr     mon_wrtsec      ;to rom
   373 00:D583: 8D D5 71                     sta     sim_erflag      ;save result
   374 00:D586: 60                           rts
   375                        ;set parameters for host read/write
   376 00:D587: AD C9 71     sim_hcom        lda     sim_hstdsk      ;set disk number
   377 00:D58A: 85 D4                        sta     mon_nxtdrv      ;Save active Drive number
   378 00:D58C: AD CA 71                     lda     sim_hsttrk      ;then track
   379                        ;                ldy     sim_hsttrk+1   ;not used
   380 00:D58F: 85 D5                        sta     mon_nxttrk
   381 00:D591: AD CC 71                     lda     sim_hstsec      ;then sector
   382                        ;                ldy     sim_hstsec+1   ;not used
   383 00:D594: 85 D6                        sta     mon_nxtsec
   384 00:D596: AE C9 71                     ldx     sim_hstdsk      ;get host disk
   385 00:D599: 20 A3 D3                     jsr     sim_tstdbx      ;see if de-blocking
   386 00:D59C: F0 09                        beq     ?B2             ;branch if none
   387 00:D59E: A9 00                        lda     #<hstbuf        ;finally address
   388 00:D5A0: A0 06                        ldy     #>hstbuf
   389 00:D5A2: 85 F7                        sta     lba_addr_low    ;Save low byte Buffer address
   390 00:D5A4: 84 F8                        sty     lba_addr_high   ;Save low byte Buffer address
   391 00:D5A6: 60                           rts                     ;Return to Caller
   392 00:D5A7: A5 8C        ?B2             lda     sim_dmaadr      ;send normal address
   393 00:D5A9: A4 8D                        ldy     sim_dmaadr+1    ;for no de-blocking
   394 00:D5AB: 85 F7                        sta     lba_addr_low    ;Save low byte Buffer address
   395 00:D5AD: 84 F8                        sty     lba_addr_high   ;Save low byte Buffer address
   396 00:D5AF: 60                           rts                     ;Return to Caller
   397                        ;set sector number
   398 00:D5B0: 8D C7 71     sim_selsec      sta     sim_seksec      ;save low and high
   399 00:D5B3: 8C C8 71                     sty     sim_seksec+1
   400 00:D5B6: 85 D6                        sta     mon_nxtsec
   401 00:D5B8: 60                           rts
   402                        ;set buffer address
   403 00:D5B9: 85 8C        sim_setdma      sta     sim_dmaadr      ;store low
   404 00:D5BB: 84 8D                        sty     sim_dmaadr+1    ;and high
   405 00:D5BD: 85 F7                        sta     lba_addr_low    ;Save low byte Buffer address
   406 00:D5BF: 84 F8                        sty     lba_addr_high   ;Save low byte Buffer address
   407 00:D5C1: 60                           rts                     ;Return to Caller
   408                        ;set track
   409 00:D5C2: 8D C5 71     sim_seltrk      sta     sim_sektrk      ;save number
   410 00:D5C5: 8C C6 71                     sty     sim_sektrk+1
   411 00:D5C8: 85 D5                        sta     mon_nxttrk
   412 00:D5CA: 60                           rts
   413                        ;
   414                        ;**************************************************************************************************
   415                        ;
   416                        ;Console Input and Output Routines
   417                        ; There are three routines for Console I/O
   418                        ; 1- CONSTS - Console Status: tests to see if there is a character available
   419                        ; 2- CONRDE - Console Read: waits for a character to be available, then returns with it
   420                        ; 3- CONWRT - Console Write: sends a character to the console
   421                        ;
   422                        mon_consts
   423 00:D5CB: A5 DF                        lda     icnt            ;Load Input Buffer count
   424 00:D5CD: F0 01                        beq     conste          ;Branch if Buffer empty
   425 00:D5CF: 3A                           dec     a               ;Else, Decrement A (LDA #$FF)
   426 00:D5D0: 60           conste          rts                     ;Return to Caller
   427                        ;
   428                        mon_conrde
   429 00:D5D1: 20 39 FF                     jsr     b_chrin         ;Call BIOS for character in (waits)
   430 00:D5D4: 29 7F                        and     #$7F            ;Strip off high bit (ASCII only)
   431 00:D5D6: C9 08                        cmp     #bs             ;Check for Backspace character
   432 00:D5D8: D0 02                        bne     conrdx          ;If not, branch
   433 00:D5DA: A9 7F                        lda     #delete         ;Else, replace with Delete code
  Thu Apr 29 2021  3:45                                                                                                    Page 60


   434 00:D5DC: 60           conrdx          rts                     ;Return to Caller
   435                        ;
   436                        mon_conwrt
   437 00:D5DD: 48                           pha                     ;Save Character to Stack
   438 00:D5DE: 29 7F                        and     #$7F            ;Strip off high bit (ASCII only)
   439 00:D5E0: C9 7F                        cmp     #delete         ;Check for Delete code
   440 00:D5E2: D0 02                        bne     notdlt          ;If not, branch
   441 00:D5E4: A9 20                        lda     #' '            ;Else, load ASCII space
   442 00:D5E6: C9 01        notdlt          cmp     #clreol         ;Check for EOL code
   443 00:D5E8: D0 09                        bne     ntceol          ;If not, branch
   444 00:D5EA: A9 1B                        lda     #esc            ;Else, load ASCII escape
   445 00:D5EC: 20 3C FF                     jsr     b_chrout        ;Call BIOS for character send
   446 00:D5EF: A9 54                        lda     #'T'            ;Load upper case "T"
   447 00:D5F1: 80 0B                        bra     ntceos          ;Branch to send/exit
   448 00:D5F3: C9 02        ntceol          cmp     #clreos         ;Check for CLR code
   449 00:D5F5: D0 07                        bne     ntceos          ;If not, branch
   450 00:D5F7: A9 1B                        lda     #esc            ;Load ASCII escape
   451 00:D5F9: 20 3C FF                     jsr     b_chrout        ;Call BIOS for character send
   452 00:D5FC: A9 59                        lda     #'Y'            ;Load upper case "Y"
   453 00:D5FE: 20 3C FF     ntceos          jsr     b_chrout        ;Call BIOS for character send
   454 00:D601: 68           endvid          pla                     ;Get original Character from Stack
   455 00:D602: 60                           rts                     ;return to Caller
   456                        ;
   457                        ;Send null terminated string to console. note that routine will
   458                        ; also be terminated if high byte of pointer wraps from $FF to $00.
   459                        ; Input: A and Y are low and high bytes of string start
   460                        ; Output: carry clear
   461 00:D603: 85 B6        mon_txtout      sta     promptl         ;Save text string pointer
   462 00:D605: 84 B7                        sty     prompth         ;
   463 00:D607: A0 00                        ldy     #0              ;Zero Index
   464 00:D609: B1 B6        txtout_lp       lda     (promptl),y     ;Get character
   465 00:D60B: F0 0A                        beq     txtout_end      ;Quit if zero
   466 00:D60D: 20 DD D5                     jsr     mon_conwrt      ;Send character
   467 00:D610: C8                           iny                     ;Increment index
   468 00:D611: D0 F6                        bne     txtout_lp       ;Loop back if no rollover
   469 00:D613: E6 B7                        inc     prompth         ;Else, increment high byte of pointer
   470 00:D615: D0 F2                        bne     txtout_lp       ;Loop back if no rollover
   471 00:D617: 18           txtout_end      clc                     ;Set Carry for no error
   472 00:D618: 60                           rts                     ;Return to Caller
   473                        ;
   474                        ;**************************************************************************************************
   475                        ;
   476                        ;Disk Routines for LBA Read and Write
   477                        ; There are two routines here
   478                        ; 1- RDESEC: Read an LBA into the Buffer
   479                        ; 2- WRTSEC: Write an LBA from the Buffer
   480                        ; These routines call the C02 BIOS for actual LBA read and write along with the routines
   481                        ; to set the parameters for LBA requested and buffer address. These are 512-byte block accesses.
   482                        ;
   483                        mon_wrtsec
   484 00:D619: 20 38 D6                     jsr     wrlba           ;Calculate CHS to LBA
   485 00:D61C: 20 0C FF                     jsr     b_ide_write_lba ;Call BIOS to Write LBA
   486 00:D61F: 80 06                        bra     rd_wr_end       ;Branch to finish up
   487                        mon_rdesec
   488 00:D621: 20 38 D6                     jsr     wrlba           ;Calculate CHS to LBA
   489 00:D624: 20 09 FF                     jsr     b_ide_read_lba  ;Call BIOS to Read LBA
   490                        rd_wr_end
   491 00:D627: A5 D0                        lda     ide_status_ram  ;Get Status from BIOS call
   492 00:D629: 4A                           lsr     a               ;Shift error bit to carry
   493 00:D62A: B0 03                        bcs     ide_rw_err      ;Branch if error
   494 00:D62C: A9 00                        lda     #$00            ;Else, clear A reg
   495 00:D62E: 60                           rts                     ;Return to caller
   496                        ide_rw_err
  Thu Apr 29 2021  3:45                                                                                                    Page 61


   497 00:D62F: A9 35                        lda     #<io_err_msg    ;Point to error message
   498 00:D631: A0 D3                        ldy     #>io_err_msg
   499 00:D633: 20 5A E0                     jsr     m_promptr       ;Send it
   500 00:D636: 80 48                        bra     dos_entry       ;Restart DOS
   501                        ;
   502                        ;Calculate the LBA number from the Track and Sector parameters
   503                        ; The Sector count can be from 0 to 255 (256 total)
   504                        ; The Track count can be from 0 to 63 (64 total)
   505                        ;
   506                        ;24-bit addressing is supported by the C02BIOS V3.03
   507                        ; The upper 4-bits (28-bit) are always zeroed by the BIOS routines,
   508                        ; hence BIOS is limited to 8GB size as a result of 24-bit addressing.
   509                        ;
   510                        ;Once the Track and Sector values are moved to the LBA parameters,
   511                        ; an offset must be added which is based on the Drive number (0-7).
   512                        ; Partition sizes are limited to 8MB
   513                        ; Number of drives is limited to 8 (A - H)
   514                        ; Maximum available Data is limited to 64MB
   515                        ;
   516                        ;The Offset table is 4 bytes per entry and adds an LBA count to
   517                        ; shift the absolute LBA numbers to the appropriate drive number
   518                        ; being acessed (16384 blocks per).
   519                        ;
   520                        ; At entry;
   521                        ; NXTSEC contains 0 to 255
   522                        ;                       00000000|ssssssss
   523                        ;
   524                        ; NXTTRK contains 0 to 63
   525                        ;                       00000000|0ttttttt
   526                        ;
   527                        ;First, copy NXTSEC to LBA0 with end result being:
   528                        ;Second, copy NXTTRK to LBA1 and clear LBA2
   529                        ;
   530                        ; so LBA2|LBA1|LBA0 look like:
   531                        ;                       00000000|0ttttttt|ssssssss
   532                        ;
   533 00:D638: A5 D6        wrlba           lda     mon_nxtsec      ;Get requested Sector number
   534 00:D63A: 85 D1                        sta     ide_lba0        ;Save to LBA lowest order byte
   535 00:D63C: A5 D5                        lda     mon_nxttrk      ;Get requested Track number
   536 00:D63E: 85 D2                        sta     ide_lba1        ;Save to LBA middle order byte
   537 00:D640: 64 D3                        stz     ide_lba2        ;Zero out the Upper order byte
   538                        ;
   539                        ;All LBA data starts as LBA 0 for each drive number.
   540                        ; So the drive number is used as an index to the Offset table.
   541                        ; This is then added to the 24-bit LBA address and stored to
   542                        ; the BIOS variables for the requested LBA for Read or Write.
   543                        ; Note: "LBA3" is not needed, as the BIOS handles 24-bit input
   544                        ; and zeros the upper 4-bits of the (28-bit) address!
   545                        ;
   546 00:D642: A5 D4                        lda     mon_nxtdrv      ;Get drive number
   547 00:D644: 0A                           asl     a               ;Multiply by two
   548 00:D645: 0A                           asl     a               ;Multiply by two (now = 4)
   549 00:D646: AA                           tax                     ;Xfer offset to X reg
   550                        ;
   551 00:D647: 18                           clc                     ;Clear Carry for Add
   552 00:D648: A5 D1                        lda     ide_lba0        ;Get Low order LBA
   553 00:D64A: 7D 60 D6                     adc     offset,x        ;Add in low order offset
   554 00:D64D: 85 FA                        sta     lba_low_byte    ;Save to BIOS variable
   555 00:D64F: E8                           inx                     ;Increment index to next offset byte
   556 00:D650: A5 D2                        lda     ide_lba1        ;Get Middle order LBA
   557 00:D652: 7D 60 D6                     adc     offset,x        ;Add in high order offset
   558 00:D655: 85 FB                        sta     lba_high_byte   ;Save to BIOS variable
   559 00:D657: E8                           inx                     ;Increment index to next offset byte
  Thu Apr 29 2021  3:45                                                                                                    Page 62


   560 00:D658: A5 D3                        lda     ide_lba2        ;Get the High order LBA
   561 00:D65A: 7D 60 D6                     adc     offset,x        ;Add in extended order offset
   562 00:D65D: 85 FC                        sta     lba_ext_byte    ;Save to BIOS variable
   563 00:D65F: 60                           rts                     ;Return to Caller
   564                        ;
   565                        ;At this point LBA address is calculated and stored.
   566                        ; The C02BIOS 3.03 variables are already loaded per the
   567                        ; routine above. Using the LBA Read or Write function
   568                        ; will transfer the LBA parameters, so we're done here.
   569                        ;
   570                        ;Table of LBA offsets for all drives A thru H
   571                        offset
   572 00:D660: 00 00 00 00                  .LONG   0               ;Drive A CP/M default
   573 00:D664: 00 40 00 00                  .LONG   16384           ;Drive B
   574 00:D668: 00 80 00 00                  .LONG   32768           ;Drive C
   575 00:D66C: 00 C0 00 00                  .LONG   49152           ;Drive D
   576 00:D670: 00 00 01 00                  .LONG   65536           ;Drive E
   577 00:D674: 00 40 01 00                  .LONG   81920           ;Drive F
   578 00:D678: 00 80 01 00                  .LONG   98304           ;Drive G
   579 00:D67C: 00 C0 01 00                  .LONG   114688          ;Drive H
   580                        ;
   581                        ;**************************************************************************************************
   582                        ;DOS/65 ENTRY
   583                        ; Note: The address here is called from C02Monitor via a CTRL-B command. By default, the address
   584                        ; is located at $D680 in ROM. If any changes are made to this SIM module, ensure that the code
   585                        ; is either at the same address or change the address that the monitor calls!
   586                        ;
   587 00:D680: A2 FF        dos_entry       ldx     #$FF            ;Set
   588 00:D682: 9A                           txs                     ;Stack pointer
   589                        ;Initialize all of ram by transferring block from
   590                        ; ROM location to start of RAM. All monitor and
   591                        ; DOS/65 non-page 0 RAM is initialized.
   592 00:D683: A9 00                        lda     #$00            ;Get length low byte
   593 00:D685: A0 02                        ldy     #$02            ;Get length high byte
   594                        ;
   595 00:D687: 20 9A D6                     jsr     memory_move     ;Move Image from ROM to RAM
   596 00:D68A: 20 B1 D6                     jsr     clearmaps       ;Clear out RAM for Disk maps
   597 00:D68D: 20 CB D6                     jsr     clearbuf        ;Clear out host buffer
   598 00:D690: 20 00 FF                     jsr     b_ide_reset     ;Reset IDE Controller
   599                        ;
   600                        ;DOS/65 bootstrap from ROM by going to SIM to start
   601                        ; the process. Code and data that the LINKER placed in ROM at
   602                        ; ROM address has already been transfered via above.
   603 00:D693: 4C 47 D3     mon_boot        jmp     sim_boot        ;Jump to SIM start
   604                        ;
   605                        ;Warm boot dos/65 CCM & PEM from ROM. this is called from
   606                        ; SIM and returns where SIM executes refreshed system.
   607 00:D696: A9 80        mon_warm        lda     #$80            ;Get length low byte
   608 00:D698: A0 01                        ldy     #$01            ;Get length high byte
   609                        ;
   610                        ;Memory move routine
   611                        ; Memory move is used for both cold boot and warm boot.
   612                        ; the ROM image for cold/warm boot differs in the amount of
   613                        ; ROM data to be moved. Cold boot requires 512 bytes where
   614                        ; Warm boot required 384 bytes.
   615                        memory_move
   616 00:D69A: 85 BC                        sta     lenl            ;Save length low byte
   617 00:D69C: 84 BD                        sty     lenh            ;Save length high byte
   618                        ;
   619 00:D69E: A9 00                        lda     #<romorg        ;Get pointer to ROM start
   620 00:D6A0: A0 D8                        ldy     #>romorg        ;
   621 00:D6A2: 85 B8                        sta     srcl            ;Store to Page 0 pointer
   622 00:D6A4: 84 B9                        sty     srch            ;
  Thu Apr 29 2021  3:45                                                                                                    Page 63


   623 00:D6A6: A9 00                        lda     #<ccmram        ;point to destination
   624 00:D6A8: A0 70                        ldy     #>ccmram        ;
   625 00:D6AA: 85 BA                        sta     tgtl            ;Store to Page 0 pointer
   626 00:D6AC: 84 BB                        sty     tgth            ;
   627 00:D6AE: 4C 09 E0                     jmp     m_move_ram      ;Use Monitor routine to move memory
   628                        ;
   629                        ;Clearmaps routine
   630                        ; Only on a coldboot... the disk buffers need to be cleared.
   631                        ; this saves 3.5KB of empty ROM space that is copied to RAM
   632                        ; during a cold start. The variables used for start and end
   633                        ; of RAM are: bufmap and bufmapend
   634                        clearmaps
   635 00:D6B1: A9 00                        lda     #<bufmap        ;get start of buffer space
   636 00:D6B3: A0 72                        ldy     #>bufmap
   637 00:D6B5: 85 BA                        sta     tgtl            ;save to page zero pointer
   638 00:D6B7: 84 BB                        sty     tgth
   639                        ;
   640 00:D6B9: 38                           sec                     ;set carry for subtraction
   641 00:D6BA: A9 00                        lda     #<bufmapend     ;get end of buffer space lo byte
   642 00:D6BC: E5 BA                        sbc     tgtl            ;subtract start lo byte
   643 00:D6BE: 85 BC                        sta     lenl            ;save it to page zero pointer
   644 00:D6C0: A9 80                        lda     #>bufmapend     ;get end of buffer space hi byte
   645 00:D6C2: E5 BB                        sbc     tgth            ;subtract start hi byte
   646 00:D6C4: 85 BD                        sta     lenh            ;save it to page zero pointer
   647                        fill_mem2
   648 00:D6C6: 64 C3                        stz     temp2           ;Zero fill byte value
   649                        ;
   650                        ;Memory fill routine: fills a block of memory with any desired fill byte
   651                        ; based on target and length pointers. The fill byte is stored in TEMP2.
   652 00:D6C8: 4C 0C E0     fill_mem        jmp     m_fill_ram      ;Use Monitor routine to fill memory
   653                        ;
   654                        ;The Host Buffer has been moved to low RAM. As a safety, this buffer
   655                        ; is also cleared during a cold boot. The location is the default LBA
   656                        ; buffer for the C02BIOS and will have Identity Data loaded there
   657                        ; from booting the C02 Pocket SBC.
   658                        clearbuf
   659 00:D6CB: A9 00                        lda     #<hstbuf        ;get the location of the
   660 00:D6CD: A0 06                        ldy     #>hstbuf        ;host buffer
   661 00:D6CF: 85 BA                        sta     tgtl            ;save to page zero pointer
   662 00:D6D1: 84 BB                        sty     tgth            ;lo/hi bytes
   663                        ;
   664 00:D6D3: 64 BC                        stz     lenl            ;save it to page zero pointer
   665 00:D6D5: A0 02                        ldy     #$02            ;to 512 bytes
   666 00:D6D7: 84 BD                        sty     lenh            ;lo/hi bytes
   667 00:D6D9: 80 EB                        bra     fill_mem2       ;Go clear it
   668                        ;
   669                        ;**************************************************************************************************
   670                        ;disk control blocks
   671                        ; Updated to support seven drives by default - KM
   672                        ;drive a (CF 8MB)
   673 00:D6DB: FF 0F        dcb_a           .DW     4095            ;max block number
   674 00:D6DD: 00 04                        .DW     1024            ;records per track
   675 00:D6DF: 00 00                        .DW     0               ;number system tracks
   676 00:D6E1: 01                           .DB     1               ;block size = 2048
   677 00:D6E2: FF 03                        .DW     1023            ;max directory
   678 00:D6E4: 00 72                        .DW     almpa           ;address of allocation map
   679 00:D6E6: 80                           .DB     128             ;do not do checksums
   680 00:D6E7: 00 00                        .DW     0               ;phony address
   681                        ;drive b (CF 8MB)
   682 00:D6E9: FF 0F        dcb_b           .DW     4095            ;max block number
   683 00:D6EB: 00 04                        .DW     1024            ;records per track
   684 00:D6ED: 00 00                        .DW     0               ;number system tracks
   685 00:D6EF: 01                           .DB     1               ;block size = 2048
  Thu Apr 29 2021  3:45                                                                                                    Page 64


   686 00:D6F0: FF 03                        .DW     1023            ;max directory
   687 00:D6F2: 00 74                        .DW     almpb           ;address of allocation map
   688 00:D6F4: 80                           .DB     128             ;do not do checksums
   689 00:D6F5: 00 00                        .DW     0               ;phony address
   690                        ;drive c (CF 8MB)
   691 00:D6F7: FF 0F        dcb_c           .DW     4095            ;max block number
   692 00:D6F9: 00 04                        .DW     1024            ;records per track
   693 00:D6FB: 00 00                        .DW     0               ;number system tracks
   694 00:D6FD: 01                           .DB     1               ;block size = 2048
   695 00:D6FE: FF 03                        .DW     1023            ;max directory
   696 00:D700: 00 76                        .DW     almpc           ;address of allocation map
   697 00:D702: 80                           .DB     128             ;do not do checksums
   698 00:D703: 00 00                        .DW     0               ;phony address
   699                        ;drive d (CF 8MB)
   700 00:D705: FF 0F        dcb_d           .DW     4095            ;max block number
   701 00:D707: 00 04                        .DW     1024            ;records per track
   702 00:D709: 00 00                        .DW     0               ;number system tracks
   703 00:D70B: 01                           .DB     1               ;block size = 2048
   704 00:D70C: FF 03                        .DW     1023            ;max directory
   705 00:D70E: 00 78                        .DW     almpd           ;address of allocation map
   706 00:D710: 80                           .DB     128             ;do not do checksums
   707 00:D711: 00 00                        .DW     0               ;phony address
   708                        ;drive e (CF 8MB)
   709 00:D713: FF 0F        dcb_e           .DW     4095            ;max block number
   710 00:D715: 00 04                        .DW     1024            ;records per track
   711 00:D717: 00 00                        .DW     0               ;number system tracks
   712 00:D719: 01                           .DB     1               ;block size = 2048
   713 00:D71A: FF 03                        .DW     1023            ;max directory
   714 00:D71C: 00 7A                        .DW     almpe           ;address of allocation map
   715 00:D71E: 80                           .DB     128             ;do not do checksums
   716 00:D71F: 00 00                        .DW     0               ;phony address
   717                        ;drive f (CF 8MB)
   718 00:D721: FF 0F        dcb_f           .DW     4095            ;max block number
   719 00:D723: 00 04                        .DW     1024            ;records per track
   720 00:D725: 00 00                        .DW     0               ;number system tracks
   721 00:D727: 01                           .DB     1               ;block size = 2048
   722 00:D728: FF 03                        .DW     1023            ;max directory
   723 00:D72A: 00 7C                        .DW     almpf           ;address of allocation map
   724 00:D72C: 80                           .DB     128             ;do not do checksums
   725 00:D72D: 00 00                        .DW     0               ;phony address
   726                        ;drive g (CF 8MB)
   727 00:D72F: FF 0F        dcb_g           .DW     4095            ;max block number
   728 00:D731: 00 04                        .DW     1024            ;records per track
   729 00:D733: 00 00                        .DW     0               ;number system tracks
   730 00:D735: 01                           .DB     1               ;block size = 2048
   731 00:D736: FF 03                        .DW     1023            ;max directory
   732 00:D738: 00 7E                        .DW     almpg           ;address of allocation map
   733 00:D73A: 80                           .DB     128             ;do not do checksums
   734 00:D73B: 00 00                        .DW     0               ;phony address
   735                        ;drive h (CF 8MB)
   736                        ;dcb_h           .DW     4095            ;max block number
   737                        ;                .DW     1024            ;records per track
   738                        ;                .DW     0               ;number system tracks
   739                        ;                .DB     1               ;block size = 2048
   740                        ;                .DW     1023            ;max directory
   741                        ;                .DW     almph           ;address of allocation map
   742                        ;                .DB     128             ;do not do checksums
   743                        ;                .DW     0               ;phony address
   744                        
   745                                        end
  2777                        ;
  2778 00:D73D:                      ends
  2779                        
  Thu Apr 29 2021  3:45                                                                                                    Page 65


  2780                                data
  2781 00:0000: 65                   byte    $65
  2782 00:0001:                      ends
  2783                        
  2784                                end


      Lines assembled: 3957
      Errors: 0
