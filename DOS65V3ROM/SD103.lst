  Sun Mar 14 2021 21:19                                                                                                    Page 1


                                               ***************************************
                                               **      WDC 65C02 Macro Assembler    **
                                               **                                   **
                                               **     Version 3.49.1- Feb  6 2006    **
                                               ***************************************

     1                        	globals	on
     2                        	case	off
     3                        	chip	W65C02S
     4                        	pw	132
     5                        	pl	66
     6                        ;SD.ASM VER 1.03 (WDC Assembler Format)
     7                        ;DOS/65Super Directory based on CP/M Super Directory by Bruce R. Ratoff
     8                        ;that was based on DIRS by Keith Petersen, W8SDZ
     9                        ;
    10                        ;Displays the directory of a DOS/65 drive, sorted alphabetically,
    11                        ;with the file size in K, rounded to the nearest DOS/65 block size.
    12                        ;
    13                        ;THIS LATEST VARIATION ON A COMMON THEME WILL AUTOMATICALLY ADJUST
    14                        ;ITSELF FOR ANY BLOCK SIZE AND DIRECTORY LENGTH UNDER DOS/65 2.1X or 3.x.
    15                        ;PROVISIONS ARE MADE FOR (1) AUTOMATIC PAUSES
    16                        ;WHEN THE SCREEN FILLS UP; (2) searching individual or multiple
    17                        ;USER AREAS; (3) summary line output giving
    18                        ;DRIVE AND USER INFORMATION, # OF FILES MATCHED AND HOW MUCH SPACE THEY
    19                        ;CONSUME, AND THE AMOUNT OF FREE SPACE REMAINING ON THE DISK; (4) accepting
    20                        ;ambiguous file names WITH OR WITHOUT A DRIVE NAME.
    21                        ;
    22                        ;Released:		27 March 2015 (V1.00) - Rich Leary
    23                        ;Last Revision:		29 March 2015 (V1.01) - Rich Leary
    24                        ;				corrected error with $'s in file name
    25                        ;			30 March 2015 (V1.02) - Rich Leary
    26                        ;				eliminated duplicate searches
    27                        ;			4 August 2017 (V1.03) - Rich Leary
    28                        ;				changed option char to =
    29                        ;
    30                        ;NOTE: Simple labels are used when doing some of the various
    31                        ;6502/65C02 branch instructions. For example note that in
    32                        ;the following code fragment the label NZ001 is a simple label that
    33                        ;usually is only referenced within a very small address span.
    34                        ;		inc	hl
    35                        ;		bne	nz001
    36                        ;		inc	hl+1
    37                        ;	nz001
    38                        ;In this case the label designates code flow as a result of a simple
    39                        ;arithmetic operation.
    40                        ;Several generic versions of such labels are used in this program and
    41                        ;the follow the general pattern of
    42                        ;		ccnnn
    43                        ;where cc denotes a flag condition and nnn is a sequential numerical
    44                        ;designator. cc's used include:
    45                        ;	nz	not zero
    46                        ;	eq	zero
    47                        ;	cc	carry clear or borrow set
    48                        ;	cs	carry set or borrow clear
    49                        ;	pl	plus
    50                        ;	mi	minus
    51                        ;Labels used are as follows:
    52                        ;	nz	nz001,nz004,nz005,nz020,nz021,nz010,nz011,nz013,
    53                        ;		nz009,nz020
    54                        ;	eq	eq030
    55                        ;	cc	cc002,cc004,cc005,cc006,cc050,cc003
    56                        ;	cs	cs002
    57                        ;	pl	pl001
  Sun Mar 14 2021 21:19                                                                                                    Page 2


    58                        ;	mi
    59                        ;
    60                        ;fixed values
    61             00000000   FALSE	EQU	0
    62             00000001   TRUE	EQU	1
    63                        ;ASCII characters
    64             0000000A   lf	equ	10			;line feed
    65             0000000D   cr	equ	13			;carriage return
    66             0000007C   DELIM	EQU	7CH			;delimiter - vertical bar
    67                        ;
    68                        ;*****************************
    69                        ;			     *
    70                        ; USER OPTION SPECIFICATIONS *
    71                        ;			     *
    72                        ;*****************************
    73                        
    74             00000001   V3	EQU	true			;True if DOS/65 V3.x vs V2.1
    75             00000001   AOPT	EQU	TRUE			;True to allow searching all user areas
    76             00000001   NOPT	EQU	TRUE			;True to allow disabling page pause option
    77             00000001   OPTION	EQU	TRUE			;True if allowing ANY command line options
    78             00000001   PGPAWZ	EQU	TRUE			;True for pause after each page
    79             00000001   REPERR	EQU	TRUE			;True to report command line option errors
    80             00000001   REPSIZ	EQU	TRUE			;True to report file sizes
    81             00000001   REPUSR	EQU	TRUE			;True to report user numbers
    82             00000001   UOPT	EQU	TRUE			;True to allow user number option
    83                        
    84                        
    85             00000004   NPL	EQU	4			;names/line (max of 3 for 64x16)
    86                        ;						    (MAX OF 4 FOR 80X24)
    87                        
    88             00000014   LPS	EQU	20			;lines/screen (max of 12 for 64x16)
    89                        ;						      (MAX OF 20 FOR 80X24)
    90                        ;
    91                        ;PEM FUNCTION DEFINITIONS
    92             00000000   wboot	equ	0		;do warm boot
    93             00000001   RDCHR	EQU	1		;Read char from console
    94             00000002   WRCHR	EQU	2		;Write char to console
    95             00000006   noecho	equ	6		;read char from console - no echo
    96             00000009   string	equ	9		;send $-terminated string to console
    97             0000000B   CONST	EQU	11		;Check console status
    98             0000000E   SELDSK	EQU	14		;Select disk
    99             00000011   SEARCH	EQU	17		;A=$ff if not found
   100             00000012   NEXT	EQU	18		;same
   101             00000019   CURDSK	EQU	25		;Get currently logged disk name
   102             0000001A   SETDMA	EQU	26		;Set current buffer addressDMA
   103             0000001B   GALLOC	EQU	27		;Get address of allocation vector
   104             00000022   CurDCB	EQU	34		;Get current disk parameters
   105             00000024   CURUSR	EQU	36		;Get or set current user number (3.x only)
   106                        ;DCB contents are:
   107                        ;	MAXBLK	.word		maximum block number
   108                        ;	NRECRD	.word		number 128 byte records per track
   109                        ;	NSYSTR	.word		number system tracks
   110                        ;	BLKSCD	.byte		0=1024,1=2048,2=4096,3=8192,4=16384
   111                        ;	MAXDIR	.word		max directory number
   112                        ;	ALCMAP	.word		address of allocation map
   113                        ;	CHKFLG	.byte		check directory flag
   114                        ;	CHKMAP	.word		address of checksum map
   115                        ;DOS/65 addresses
   116             00000030   pzstrt	equ	$30		;page zero start
   117             00000103   PEM	EQU	$103		;fixed PEM entry point
   118             00000107   DflFCB	equ	$107		;default FCB
   119             00000128   DflBuf	equ	$128		;default disk buffer
   120             00000800   TEA	EQU	$800
  Sun Mar 14 2021 21:19                                                                                                    Page 3


   121                        ;
   122                        	page0
   123                        ;page zero storage
   124                        	org	pzstrt
   125 00:0030:              oldusr	defs	1		;user number upon invocation
   126 00:0031:              newusr	defs	1		;user number selected by "$U" option
   127 00:0032:              OLDDSK	DEFS	1		;Holder for currently logged-in drive
   128 00:0033:              curdrv	defs	1		;current drive
   129 00:0034:              SCOUNT	DEFS	2		;# to sort
   130 00:0036:              SUPSPC	DEFS	1		;Leading space flag for decimal routine
   131 00:0037:              TOTFIL	DEFS	2		;Total number of files
   132 00:0039:              TOTSIZ	DEFS	2		;Total size of all files
   133 00:003B:              HL	defs	2		;16 bit pointer
   134                        ;next three variables are associated with option scan process
   135 00:003D:              BufInd	defs	1		;index into command line buffer
   136 00:003E:              BufCnt	defs	1		;number char left in buffer
   137 00:003F:              ScnChr	defs	1		;command line chr being compared
   138 00:0040:              TmpDig	defs	1		;save digit in scan
   139 00:0041:              COUNT	DEFS	2		;Entry count
   140 00:0043:              counts	defs	2		;save as COUNT is modified
   141 00:0045:              FREEBY	DEFS	2		;Contains number of K left on directory	drive
   142 00:0047:              GAP	DEFS	2		;Sort routine storage
   143 00:0049:              I	DEFS	2		;Sort routine storage
   144 00:004B:              J	DEFS	2		;Sort routine storage
   145 00:004D:              JPnt	defs	2		;pointer in COMPARE
   146 00:004F:              JG	DEFS	2		;Sort routine storage
   147 00:0051:              JGPnt	defs	2		;pointer in COMPARE
   148 00:0053:              LZFLG	DEFS	1		;0 when printing leading zeros
   149 00:0054:              MAXUSR	DEFS	1		;Maximum user # for drive
   150 00:0055:              NEXTT	DEFS	2		;Next table entry
   151                        ;copy of DCB for selected drive
   152                        DCBCPY
   153 00:0057:              MAXBLK	defs	2
   154 00:0059:              NRECRD	defs	2
   155 00:005B:              NSYSTR	defs	2
   156 00:005D:              BLKSCD	defs	1
   157 00:005E:              MAXDIR	defs	2
   158 00:0060:              ALCMAP	defs	2
   159 00:0062:              CHKFLG	defs	1
   160 00:0063:              CHKMAP	defs	2
   161                        ;more variables
   162 00:0065:              numblk	defs	2		;number of blocks
   163 00:0067:              BlkCnt	defs	2		;counter for allocated blocks
   164 00:0069:              AlcPnt	defs	2		;pointer used to scan map
   165 00:006B:              BytTmp	defs	1		;temp in map scan
   166 00:006C:              nmepnt	defs	2		;pointer in setting up ORDER
   167 00:006E:              fldcnt	defs	1		;count of fields per line
   168 00:006F:              MsgSav	defs	2		;save message pointer
   169 00:0071:              Extent	defs	2		;extent number of last directory entry
   170                        				;and working location for file size
   171 00:0073:              minus	defs	2		;save for modulus
   172 00:0075:              remain	defs	1		;remainder in K calculation
   173 00:0076:              curext	defs	1		;current extent
   174 00:0077:              srchfr	defs	1		;first search in extent = 1, else 0
   175 00:0078:              indx	defs	2		;index pointer in MSgZer
   176 00:007A:              	ends
   177                        ;
   178                        	code
   179                        ;********************************
   180                        ;				*
   181                        ; BEGIN	EXECUTABLE PROGRAM CODE	*
   182                        ;				*
   183                        ;********************************
  Sun Mar 14 2021 21:19                                                                                                    Page 4


   184                        
   185                        	ORG	TEA
   186 00:0800: A9 10        START	lda	#<opnmsg	;point to message
   187 00:0802: A0 0E        	ldy	#>opnmsg
   188 00:0804: 20 0F 0D     	jsr	msgout		;send it
   189                        
   190                        	if	v3
   191 00:0807: A9 0F        	lda	#15
   192 00:0809: 85 54        	sta	maxusr
   193 00:080B: A9 FF        	LDA	#255		;Get current user number if DOS/65 V3
   194 00:080D: A2 24        	ldx	#36
   195 00:080F: 20 03 01     	jsr	pem
   196                        	else
   197                        	lda	#0
   198                        	sta	maxusr
   199                        	endif
   200                        
   201 00:0812: 85 30        	sta	OLDUSR		;Initialize start up user number
   202 00:0814: 85 31        	sta	NEWUSR		;..and make new user match it
   203 00:0816: A2 19        	ldx	#CURDSK
   204 00:0818: 20 03 01     	jsr	pem		;Get current disk nr
   205 00:081B: 85 32        	sta	OLDDSK		;Save for reset if needed
   206                        ;IF AT LEAST ONE OPTION IS ALLOWED, SCAN THE COMMAND LINE FOR THE
   207                        ;OPTION FIELD DELIMITER. THE OPTION FIELD DELIMITER IS CONSIDERED
   208                        ;VALID ONLY IF IT IS PRECEDED BY AT LEAST 1 SPACE (OTHERWISE, IT
   209                        ;MAY BE PART OF THE DIRECTORY FILENAME). ANY UNRECOGNIZED OPTIONS
   210                        ;OR ILLEGAL USER NUMBERS WILL BE FLAGGED OR IGNORED (SEE REPERR).
   211                        ;WE SCAN THE COMMAND LINE BUFFER RATHER THAN THE 2ND DEFAULT FCB
   212                        ;BECAUSE ALL OPTIONS PLUS A 2 DIGIT USER NUMBER WON't fit in
   213                        ;THE FCB NAME FIELD).
   214                        
   215                        	IF	OPTION
   216 00:081D: AE 28 01     	ldx	DflBuf		;get length of command line
   217 00:0820: A0 00        	ldy	#0		;Set command line buffer index
   218                        ;
   219                        ;SEARCH FOR THE COMMAND LINE DELIMITER. IF NOT FOUND, ASSUME NO OPTIONS.
   220 00:0822: C8           SCNDOL	iny			;advance index
   221 00:0823: CA           	dex			;drop count
   222 00:0824: 10 03        	bpl	pl001		;continue if positive
   223 00:0826: 4C DF 08     	jmp	ckrest		;exit if command line buffer empty
   224 00:0829: B9 28 01     pl001	lda	DflBuf,y	;get character
   225 00:082C: C9 3D        	cmp	#'='
   226 00:082E: D0 F2        	bne	SCNDOL		;loop if not found
   227 00:0830: 88           	dey			;'=' found - make sure space precedes it
   228 00:0831: B9 28 01     	lda	DflBuf,y
   229 00:0834: C8           	iny
   230 00:0835: C9 20        	cmp	#' '
   231 00:0837: D0 E9        	bne	SCNDOL		;No space - ignore "=" and search again
   232                        ;VALID DELIMITER FOUND. SCAN THE REST OF THE BUFFER FOR OPTIONS. ERRORS
   233                        ;PAST THIS POINT WILL CAUSE AN ABORT IF THE COMMAND LINE ERROR OPTION IS
   234                        ;ENABLED. OTHERWISE, THE DUD OPTION WILL BE IGNORED AND SD WILL ATTEMPT
   235                        ;TO CONTINUE STUMBLING THROUGH THE REST OF THE FIELD.
   236 00:0839: C8           scnopt	iny			;bump index into buffer
   237 00:083A: 84 3D        	sty	Bufind		;save index
   238 00:083C: CA           	dex			;drop count
   239 00:083D: 86 3E        	stx	BufCnt		;save for later
   240 00:083F: 10 03        	bpl	scnagn		;continue if more
   241 00:0841: 4C DF 08     	jmp	ckrest		;if exhausted quit
   242 00:0844: B9 28 01     SCNAGN	lda	DflBuf,y	;Get the next option character
   243 00:0847: 85 3F        	sta	ScnChr		;save char
   244 00:0849: C9 20        	cmp	#' '		;Do we have a space?
   245 00:084B: F0 EC        	beq	SCNOPT		;Ignore it if so
   246                        ;scan option table by first setting x & y
  Sun Mar 14 2021 21:19                                                                                                    Page 5


   247 00:084D: A2 03        	ldx	#OEnd-OTbl+1	;get length
   248 00:084F: A0 FF        	ldy	#255		;set index to -1
   249 00:0851: C8           NoMach	iny			;bump index
   250 00:0852: CA           	dex			;drop count
   251 00:0853: F0 13        	beq	Ck4Usr		;if none check battery
   252 00:0855: B9 9A 0E     	lda	Otbl,y		;get char
   253 00:0858: C5 3F        	cmp	ScnChr		;compare to command line char
   254 00:085A: D0 F5        	bne	NoMach		;loop if no match
   255 00:085C: A9 00        	lda	#0		;else activate by erasing
   256 00:085E: 99 9A 0E     	sta	OTbl,y		;option letter
   257 00:0861: A6 3E        	ldx	BufCnt		;restore count
   258 00:0863: A4 3D        	ldy	BufInd		;and index
   259 00:0865: 4C 39 08     	jmp	ScnOpt		;loop for next command line chr
   260                        ;IF OPTION CHARACTER DOESN't match the table, see if we have a User
   261                        ;OPTION.
   262 00:0868: A4 3D        CK4USR	ldy	BufInd		;get index
   263 00:086A: A6 3E        	ldx	BufCnt		;and count
   264 00:086C: B9 28 01     	lda	dFLbUF,y	;and character
   265                        
   266                        	IF	UOPT		;Check for user	number option
   267 00:086F: C9 55        	cmp	#'U'		;see if U
   268 00:0871: D0 38        	bne	CLERR		;Last option, so bad deal if that ain't it
   269 00:0873: C8           UAGN	iny			;Bump to user number digit
   270 00:0874: CA           	dex			;DROP COUNT
   271 00:0875: 30 34        	BMI	CLERR		;Error if nothing left
   272 00:0877: B9 28 01     	LDA	dFLbUF,Y	;Get decimal digit
   273 00:087A: C9 20        	CMP	#' '		;Ignore leading spaces
   274 00:087C: F0 F5        	BEQ	UAGN
   275 00:087E: 38           	SEC
   276 00:087F: E9 30        	sbc	#'0'		;Subtract ASCII BIAS
   277                        ;If result requires borrow then error
   278 00:0881: 90 28        	bcc	CLERR		;Error if < 0
   279 00:0883: C9 0A        	cmp	#10
   280 00:0885: B0 24        	bcs	CLERR		;Error if > 9
   281 00:0887: 85 31        	sta	NEWUSR		;Save user number as it may be only 1 digit
   282 00:0889: C8           	iny			;Bump to possible 2nd digit of user number
   283 00:088A: CA           	dex
   284 00:088B: 30 52        	bmi	CKREST		;If no more buffer, exit with complete user #
   285 00:088D: B9 28 01     	lda	DflBuf,y	;Else, check for another digit
   286 00:0890: 38           	sec
   287 00:0891: E9 30        	sbc	#'0'
   288 00:0893: 90 AF        	bcc	SCNAGN		;If next char not numeric not part of
   289 00:0895: C9 0A        	cmp	#10		;user number so go check for another option
   290 00:0897: B0 AB        	bcs	SCNAGN
   291                        ;At this point we have a two digit number but only legal first digit is 1. So
   292                        ;check that it is 1
   293 00:0899: 85 40        	sta	tmpdig		;save low digit
   294 00:089B: A5 31        	LDA	newusr		;get it
   295 00:089D: C9 01        	cmp	#1		;check it
   296 00:089F: D0 0A        	bne	clerr		;error if not 1
   297 00:08A1: 18           	clc			;now them all up
   298 00:08A2: A5 40        	lda	tmpdig		;get low back
   299 00:08A4: 69 0A        	adc	#10		;add 10
   300                        ;Note that user number could still be > 15 and illegal
   301 00:08A6: 85 31        	sta	NEWUSR		;Save the total user number
   302 00:08A8: 4C 39 08     	JMP	SCNOPT		;Continue scanning
   303                        	ENDIF			;Balance UOPT
   304                        
   305                        ;IF COMMAND LINE ERROR OPTION ENABLED, PLAYBACK THE COMMAND LINE UP
   306                        ;TO THE CHARACTER THAT WE GAGGED ON AND EXIT. IF REPERR IS NOT ENABLED,
   307                        ;THEN CONTINUE AS IF NOTHING WERE AMISS TO AVOID ACKNOWLEDGING THAT
   308                        ;SOME OPTIONS ARE AVAILABLE.
   309                        CLERR
  Sun Mar 14 2021 21:19                                                                                                    Page 6


   310                        	IF	REPERR
   311 00:08AB: A9 00        	lda	#0		;get ready to flag end
   312 00:08AD: C8           	iny
   313 00:08AE: 99 28 01     	sta	DflBuf,y	;do it
   314 00:08B1: 20 C7 0C     	jsr	CRLF
   315 00:08B4: A9 3B        	lda	#<errms2
   316 00:08B6: A0 0E        	ldy	#>errms2
   317 00:08B8: 20 0F 0D     	jsr	MsgOut
   318 00:08BB: A9 41        	lda	#<errtag
   319 00:08BD: A0 0E        	ldy	#>errtag
   320 00:08BF: 20 0F 0D     	jsr	MsgOut
   321 00:08C2: A0 01        	ldy	#1		;Playback bad command line to error point
   322 00:08C4: B9 28 01     CLELP	lda	dflbuf,y
   323 00:08C7: F0 0B        	beq	CLEX
   324 00:08C9: 84 3D        	sty	BufInd		;save index
   325 00:08CB: 20 DB 0C     	jsr	TYPE
   326 00:08CE: A4 3D        	ldy	BufInd		;get index back
   327 00:08D0: C8           	iny			;bump it
   328 00:08D1: 4C C4 08     	jmp	CLELP
   329                        ;identify error point
   330 00:08D4: A9 3F        CLEX	lda	#'?'		;Tag line with a '?' field
   331 00:08D6: 20 DB 0C     	jsr	TYPE
   332 00:08D9: 20 C7 0C     	jsr	CRLF		;Space down 1 more line
   333 00:08DC: 4C 03 0E     	JMP	EXIT		;..and return to DOS/65
   334                        	ELSE
   335                        
   336                        	JMP	SCNOPT		;If not reporting errors, ignore the dud
   337                        	ENDIF			;Balance REPERR
   338                        	ENDIF			;Balance OPTION
   339                        
   340                        ;OPTIONS INPUT complete OR none SPECIFIED.
   341                        CKREST
   342                        ;
   343 00:08DF: AD 08 01     	lda	DflFCB+1	;point to name
   344 00:08E2: C9 20        	cmp	#' '		;see if blank
   345 00:08E4: D0 0A        	bne	gotfcb		;if not use
   346                        ;NO FCB - MAKE	FCB ALL	'?'
   347 00:08E6: A2 0B        	ldx	#11		;FN+FT count
   348 00:08E8: A9 3F        	lda	#'?'		;get ?
   349 00:08EA: 9D 07 01     QLOOP	sta	DflFCB,x	;Store '?' IN FCB
   350 00:08ED: CA           	dex
   351 00:08EE: D0 FA        	bne	qloop		;loop if more
   352                        GOTFCB
   353                        ;Clear rest of FCB
   354 00:08F0: A9 00        	lda	#0		;get zero
   355 00:08F2: A0 0C        	ldy	#12
   356 00:08F4: 99 07 01     clrfcb	sta	DflFCB,y	;write 0
   357 00:08F7: C8           	iny
   358 00:08F8: C0 21        	cpy	#33		;see if past end
   359 00:08FA: D0 F8        	bne	clrfcb
   360 00:08FC: 20 4C 0D     	jsr	SETSRC		;Set DMA for PEM media change check
   361 00:08FF: AD 07 01     	lda	DflFCB		;get drive code from FCB
   362 00:0902: D0 05        	bne	notdfl		;if non-zero not default
   363 00:0904: A5 32        	lda	olddsk		;get old
   364 00:0906: 4C 0E 09     	jmp	setdfl		;set default
   365 00:0909: 38           notdfl	sec			;Normalize drive code for SELECT
   366 00:090A: E9 01        	sbc	#1
   367 00:090C: 29 07        	and	#%00000111	;look at three bits only
   368 00:090E: 85 33        setdfl	sta	curdrv		;save for later
   369 00:0910: A2 0E        	ldx	#SELDSK		;Select the directory drive to retrieve
   370 00:0912: 20 03 01     	jsr	PEM		;..the proper allocation vector
   371 00:0915: A9 00        	lda	#0		;clear auto
   372 00:0917: 8D 07 01     	sta	DflFCB
  Sun Mar 14 2021 21:19                                                                                                    Page 7


   373                        ;DOS/65 disk definition structure is not the same as CP/Ms.
   374 00:091A: A2 22        usedfl	ldx	#CurDCB		;request DCB
   375 00:091C: 20 03 01     	jsr	pem
   376 00:091F: 85 3B        	sta	hl		;save in pointer
   377 00:0921: 84 3C        	sty	hl+1
   378                        ;HL points to DCB - make a local copy of the 14 bytes
   379 00:0923: A0 00        	ldy	#0
   380 00:0925: B1 3B        DCBLPE	lda	(hl),y		;get actual
   381 00:0927: 99 57 00     	sta	DCBCPY,y	;save copy
   382 00:092A: C8           	iny			;bump index
   383 00:092B: C0 0E        	cpy	#14
   384 00:092D: D0 F6        	bne	DCBLPE		;loop 14 times
   385                        ;
   386                        ;CALCULATE # OF K FREE ON SELECTED DRIVE NOW
   387 00:092F: A0 00        FREE	ldy	#0		;clear
   388 00:0931: 84 67        	sty	BlkCnt		;block counter
   389 00:0933: 84 68        	sty	BlkCnt+1	;low and high
   390                        ;Get address of allocation vector
   391 00:0935: A5 60        	lda	AlcMap		;low then high
   392 00:0937: A4 61        	ldy	AlcMap+1
   393 00:0939: 85 69        	sta	AlcPnt		;set pointer
   394 00:093B: 84 6A        	sty	AlcPnt+1
   395                        ;calculate length of allocation map
   396 00:093D: A5 57        	lda	maxblk
   397 00:093F: A4 58        	ldy	maxblk+1
   398 00:0941: 85 65        	sta	NumBlk		;save max
   399 00:0943: 84 66        	sty	NumBlk+1
   400 00:0945: E6 65        	inc	NumBlk		;bump by one
   401 00:0947: D0 02        	bne	gspbyt		;skip if not roll over
   402 00:0949: E6 66        	inc	NumBlk+1
   403 00:094B: A0 00        GSPBYT	ldy	#0
   404 00:094D: B1 69        	lda	(AlcPnt),y	;get byte
   405 00:094F: 85 6B        	sta	BytTmp		;save it
   406 00:0951: A2 08        	ldx	#8		;Set to process 8 blocks
   407 00:0953: 06 6B        GSPLUP	asl	BytTmp		;Test bit
   408 00:0955: B0 06        	bcs	NOTFRE		;block used if c=1
   409 00:0957: E6 67        	INC	BlkCnt		;else bump count
   410 00:0959: D0 02        	bne	notfre		;skip if no roll over
   411 00:095B: E6 68        	inc	BlkCnt+1	;else bump high
   412 00:095D: 38           NOTFRE	sec			;drop total left by one
   413 00:095E: A5 65        	lda	NumBlk
   414 00:0960: E9 01        	sbc	#1
   415 00:0962: 85 65        	sta	NumBlk
   416 00:0964: A5 66        	lda	NumBlk+1	;get high
   417 00:0966: E9 00        	sbc	#0
   418 00:0968: 85 66        	sta	NumBlk+1
   419 00:096A: 05 65        	ora	NumBlk		;see if now zero
   420 00:096C: F0 0C        	beq	endalc		;done if zero
   421 00:096E: CA           	dex			;Count down 8 bits
   422 00:096F: D0 E2        	bne	GSPLUP		;Do another bit
   423 00:0971: E6 69        	inc	AlcPnt		;go to next byte
   424 00:0973: D0 02        	bne	nz001		;skip if no roll over
   425 00:0975: E6 6A        	inc	AlcPnt+1
   426 00:0977: 4C 4B 09     nz001	jmp	GSPBYT		;Process it
   427                        ;have now scanned the entire map
   428 00:097A: A5 67        ENDALC	lda	BlkCnt		;get free block count
   429 00:097C: A4 68        	ldy	BlkCnt+1
   430 00:097E: 85 45        	sta	freeby		;and save
   431 00:0980: 84 46        	sty	freeby+1
   432 00:0982: A6 5D        	ldx	BlkSCd		;get block size code from DCB copy
   433 00:0984: F0 09        	beq	savfre		;done if 1K
   434 00:0986: 85 6B        	sta	BytTmp		;set up temp
   435 00:0988: 06 45        FREKLP	asl	freeby		;shift low
  Sun Mar 14 2021 21:19                                                                                                    Page 8


   436 00:098A: 26 46        	rol	freeby+1
   437 00:098C: CA           	dex			;drop multiplier
   438 00:098D: D0 F9        	bne	freklp		;loop if more
   439                        ;Free space has been calculated - now set up search of directory. One
   440                        ;awkward aspect of that results from fact that DOS/65 does not do
   441                        ;wild card searches on the EXTENT. What code does is first search for
   442                        ;EXTENT=0 , then do EXTENT=1, etc. For EXTENT>0 use the first search
   443                        ;results to terminate searches beyond that point.
   444                        SAVFRE
   445                        ;
   446                        ;REENTER HERE ON SUBSEQUENT PASSES WHILE IN THE ALL-USERS MODE
   447                        SETTBL
   448 00:098F: A9 B3        	lda	#<name		;of name
   449 00:0991: 85 55        	sta	nextt		;and init next table entry pointer
   450 00:0993: A9 0E        	lda	#>name
   451 00:0995: 85 56        	sta	nextt+1
   452                        ;pointer calculated and saved now
   453                        
   454                        	IF	UOPT
   455 00:0997: A5 31        	lda	NEWUSR		;Get user area for directory
   456 00:0999: A2 24        	ldx	#CURUSR		;Get the user function
   457                        
   458                        	if	v3
   459 00:099B: 20 03 01     	jsr	pem		;..and set new user number if V3
   460                        	endif
   461                        
   462                        	ENDIF
   463                        
   464                        ;
   465                        ;LOOK UP THE FCB IN THE DIRECTORY
   466 00:099E: A9 00        SFIRST	lda	#0		;initialize counters
   467 00:09A0: A8           	tay
   468 00:09A1: 85 41        	sta	COUNT		;Initialize match counter
   469 00:09A3: 84 42        	sty	count+1
   470 00:09A5: 85 37        	sta	TOTFIL		;initialize total file counter
   471 00:09A7: 84 38        	sty	totfil+1
   472 00:09A9: 85 39        	sta	TOTSIZ		;initialize total size counter
   473 00:09AB: 84 3A        	sty	totsiz+1
   474 00:09AD: 20 4C 0D     	jsr	SETSRC		;Set DMA for directory search
   475                        ;set FCB for actual search
   476 00:09B0: A9 00        	lda	#0		;reset current EXTENT to 0
   477 00:09B2: 85 76        	sta	curext
   478 00:09B4: A5 76        newext	lda	curext		;get current EXTENT
   479 00:09B6: 8D 13 01     	sta	DflFCB+12
   480                        ;set flag so we will know this is first search for this extent
   481 00:09B9: A9 01        	lda	#1
   482 00:09BB: 85 77        	sta	srchfr
   483 00:09BD: A2 11        	ldx	#SEARCH		;Get 'search first' function
   484 00:09BF: 4C C8 09     	JMP	LOOK		;..and go search for 1st match
   485                        ;
   486                        ;READ MORE DIRECTORY ENTRIES
   487 00:09C2: A9 00        MORDIR	lda	#0		;clear search first
   488 00:09C4: 85 77        	sta	srchfr
   489 00:09C6: A2 12        	ldx	#NEXT		;Search next but first
   490 00:09C8: A9 07        LOOK	lda	#<DflFCB
   491 00:09CA: A0 01        	LDY	#>DflFCB
   492 00:09CC: 20 03 01     	jsr	PEM		;Read directory entry
   493 00:09CF: C9 FF        	cmp	#255		;check for not found
   494                        ;Check for "not found" (0FFH)
   495 00:09D1: D0 0B        	bne	some		;if not use
   496                        ;search found nothing so see if it was a first
   497 00:09D3: A5 77        	lda	srchfr		;read flag
   498 00:09D5: F0 02        	beq	ntfirs		;not a first so bump EXTENT
  Sun Mar 14 2021 21:19                                                                                                    Page 9


   499                        ;was a first search so done
   500 00:09D7: D0 3F        	bne	sprint		;go sort and print
   501                        ;was not a first search try new EXTENT
   502 00:09D9: E6 76        ntfirs	inc	curext		;else bump current
   503 00:09DB: 4C B4 09     	jmp	newext		;and loop
   504                        ;
   505                        ;POINT TO DIRECTORY ENTRY
   506                        SOME
   507 00:09DE: 29 03        	AND	#3		;Make modulus 4
   508 00:09E0: 0A           	asl	a		;multiply by 32
   509 00:09E1: 0A           	asl	a
   510 00:09E2: 0A           	asl	a
   511 00:09E3: 0A           	asl	a
   512 00:09E4: 0A           	asl	a
   513                        ;at this point a=0,32,64, or 96
   514 00:09E5: AA           	tax			;make an index
   515 00:09E6: BD 28 01     	lda	DflBuf,x	;get user number
   516 00:09E9: C5 31        	cmp	NEWUSR		;compare to current user
   517 00:09EB: D0 D5        	bne	MORDIR		;Ignore if different
   518 00:09ED: E8           	inx			;go to name field
   519 00:09EE: A0 00        	ldy	#0		;clear destination index
   520                        ;MOVE ENTRY TO TABLE
   521 00:09F0: BD 28 01     TMOVE	LDA	DflBuf,x	;Get entry char
   522 00:09F3: 29 7F        	AND	#$7F		;Remove attributes
   523 00:09F5: 91 55        	sta	(nextt),y	;Store in table
   524 00:09F7: C8           	iny			;bump destination index
   525 00:09F8: E8           	inx			;and source
   526 00:09F9: C0 0C        	cpy	#12		;see if destination at 12
   527 00:09FB: D0 F3        	bne	tmove
   528                        ;at this point y is pointing to the correct destination for
   529                        ;record count but x is two short so bump x
   530 00:09FD: E8           	inx
   531 00:09FE: E8           	inx
   532 00:09FF: BD 28 01     	lda	dflbuf,x	;get record count
   533 00:0A02: 91 55        	sta	(nextt),y	;and save
   534                        ;now adjust table pointer to get ready for next match
   535 00:0A04: 18           	clc			;add 16 to address
   536 00:0A05: A5 55        	lda	nextt		;get low
   537 00:0A07: 69 10        	adc	#16		;add 16
   538 00:0A09: 85 55        	sta	nextt		;save low
   539 00:0A0B: 90 02        	bcc	CC002		;if no carry skip high bump
   540 00:0A0D: E6 56        	inc	nextt+1
   541 00:0A0F: E6 41        CC002	inc	count		;bump match counter
   542 00:0A11: D0 02        	bne	nz004
   543 00:0A13: E6 42        	inc	count+1
   544 00:0A15: 4C C2 09     NZ004	JMP	MORDIR		;loop for more
   545                        ;
   546                        ;SORT AND PRINT
   547                        SPRINT
   548                        ;
   549                        
   550                        	IF	AOPT OR UOPT
   551 00:0A18: 20 44 0D     	jsr	SETFOP		;set file & user #
   552                        	ENDIF
   553                        
   554 00:0A1B: A5 41        	lda	COUNT		;Get file name count
   555 00:0A1D: 05 42        	ora	count+1		;any found
   556 00:0A1F: D0 03        	bne	nz005		;yes so keep going
   557 00:0A21: 4C 2B 0C     	JMP	PRTOTL		;Exit if no files found
   558                        NZ005
   559 00:0A24: A9 00        	lda	#0		;set A to 0
   560 00:0A26: 85 36        	sta	SUPSPC		;Enable leading space suppression
   561 00:0A28: A5 41        	lda	count		;save count as sort count
  Sun Mar 14 2021 21:19                                                                                                    Page 10


   562 00:0A2A: A4 42        	ldy	count+1
   563 00:0A2C: 85 34        	sta	scount
   564 00:0A2E: 84 35        	sty	scount+1
   565                        ;test for only one entry
   566 00:0A30: C0 00        	cpy	#0		;if high not zero can
   567 00:0A32: D0 07        	bne	sort		;not be one
   568 00:0A34: C9 01        	cmp	#1		;test low
   569 00:0A36: D0 03        	bne	sort		;if not one do sort
   570 00:0A38: 4C C8 0A     	jmp	done		;else done
   571                        ;
   572                        ;THIS SORT ROUTINE IS ADAPTED FROM SOFTWARE TOOLS
   573                        ;BY KERNIGAN AND PLAUGHER. As written it works with an array
   574                        ;of items numbered from 1 to N (SCOUNT). That is why COMPARE
   575                        ;and SWAP do a -1 record offset in the start to handle actual
   576                        ;data addresses of 0 to N-1. The items in this
   577                        ;case is the table of file names, types, extents, and records.
   578                        ;While V1.00 only deals with 13 of the 16 bytes in each table record
   579                        ;that was done because expanding the sort table indices to handle
   580                        ;16 byte records is a lot easier than handing 13 byte records.
   581                        ;The extra three bytes are ignored fir now.
   582 00:0A3B: A5 34        SORT	lda	scount		;get number of entries
   583 00:0A3D: A4 35        	ldy	scount+1
   584 00:0A3F: 85 3B        	sta	hl		;and put in HL
   585 00:0A41: 84 3C        	sty	hl+1
   586 00:0A43: 46 3C        L0	lsr	hl+1		;gap=gap/2
   587 00:0A45: 66 3B        	ror	hl
   588 00:0A47: A5 3B        	lda	hl		;see if zero
   589 00:0A49: 05 3C        	ora	hl+1
   590 00:0A4B: F0 7B        	beq	done		;if so none left
   591 00:0A4D: A5 3B        	lda	hl		;make gap odd
   592 00:0A4F: 09 01        	ora	#1
   593 00:0A51: 85 3B        	sta	hl
   594 00:0A53: 85 47        	sta	gap		;save gap
   595 00:0A55: A5 3C        	lda	hl+1
   596 00:0A57: 85 48        	sta	gap+1
   597 00:0A59: E6 3B        	inc	hl		;I=GAP+1
   598 00:0A5B: D0 02        	bne	nz020		;skip if no wrap
   599 00:0A5D: E6 3C        	inc	hl+1
   600                        nz020
   601                        
   602 00:0A5F: A5 3B        L2	lda	hl
   603 00:0A61: A4 3C        	ldy	hl+1
   604 00:0A63: 85 49        	sta	I		;actually use I
   605 00:0A65: 84 4A        	sty	I+1
   606 00:0A67: 38           	sec			;J=I-GAP
   607 00:0A68: A5 49        	lda	I
   608 00:0A6A: E5 47        	sbc	gap
   609 00:0A6C: 85 4B        	sta	J
   610 00:0A6E: A5 4A        	lda	I+1
   611 00:0A70: E5 48        	sbc	gap+1
   612 00:0A72: 85 4C        	sta	J+1
   613 00:0A74: 18           L3	clc			;JG=J+GAP
   614 00:0A75: A5 4B        	lda	J
   615 00:0A77: 65 47        	adc	GAP
   616 00:0A79: 85 4F        	sta	JG
   617 00:0A7B: A5 4C        	lda	J+1
   618 00:0A7D: 65 48        	adc	GAP+1
   619 00:0A7F: 85 50        	sta	JG+1
   620                        ;Do the comparison between the two entries in NAME - only compare
   621                        ;12 bytes. COMPARE returns with CS result if A(J)>A(JG)
   622                        ;in which case swap is needed. But if A(J)<=A(JG) as CC shows do not swap.
   623 00:0A81: A9 0C        	lda	#12		;compare 12 characters
   624 00:0A83: 20 9E 0D     	jsr	compare		;compare A(J) and A(JG)
  Sun Mar 14 2021 21:19                                                                                                    Page 11


   625 00:0A86: 90 19        	bcc	L5		;do nothing if C clear
   626 00:0A88: 20 89 0D     	jsr	SWAP		;Exchange A(J) and A(JG)
   627 00:0A8B: 38           	sec			;J=J-GAP
   628 00:0A8C: A5 4B        	lda	J
   629 00:0A8E: E5 47        	sbc	gap
   630 00:0A90: 85 4B        	sta	J
   631 00:0A92: A5 4C        	lda	J+1
   632 00:0A94: E5 48        	sbc	gap+1
   633 00:0A96: 85 4C        	sta	J+1
   634 00:0A98: 30 07        	bmi	L5		;if J<0
   635 00:0A9A: 05 4B        	ora	J		;check for zero
   636 00:0A9C: F0 03        	beq	L5		;if J=0
   637 00:0A9E: 4C 74 0A     	jmp	L3		;if J>0
   638 00:0AA1: E6 49        L5	inc	I		;I=I+1
   639 00:0AA3: D0 02        	bne	NZ021
   640 00:0AA5: E6 4A        	inc	I+1
   641                        NZ021
   642                        ;If I<=N goto L2
   643 00:0AA7: 38           	sec			;do as subtract N-I
   644 00:0AA8: A5 34        	lda	scount
   645 00:0AAA: E5 49        	sbc	I
   646 00:0AAC: A5 35        	lda	scount+1
   647 00:0AAE: E5 4A        	sbc	I+1
   648 00:0AB0: B0 0B        	bcs	CS002		;I<=N
   649 00:0AB2: A5 47        	lda	gap
   650 00:0AB4: A4 48        	ldy	gap+1		;preload gap into hl
   651 00:0AB6: 85 3B        	sta	hl
   652 00:0AB8: 84 3C        	sty	hl+1
   653 00:0ABA: 4C 43 0A     	jmp	L0
   654 00:0ABD: A5 49        CS002	lda	I
   655 00:0ABF: A4 4A        	ldy	I+1
   656 00:0AC1: 85 3B        	sta	hl		;preload I into HL
   657 00:0AC3: 84 3C        	sty	hl+1
   658 00:0AC5: 4C 5F 0A     	jmp	L2
   659                        ;SORT IS ALL DONE - PRINT ENTRIES
   660                        DONE
   661                        
   662                        NOOUT
   663 00:0AC8: A9 B3        	lda	#<name		;initialize table pointer
   664 00:0ACA: A0 0E        	ldy	#>name
   665 00:0ACC: 85 6C        	sta	nmepnt		;by saving
   666 00:0ACE: 84 6D        	sty	nmepnt+1
   667 00:0AD0: 4C BF 0B     	JMP	NEWLIN		;Start new line	and output the files
   668                        
   669                        ;OUTPUT THE DIRECTORY FILES WE've matched.
   670 00:0AD3: 38           ENTRY	sec			;drop file count
   671 00:0AD4: A5 41        	lda	count
   672 00:0AD6: E9 01        	sbc	#1
   673 00:0AD8: 85 41        	sta	count		;and save
   674 00:0ADA: A5 42        	lda	count+1
   675 00:0ADC: E9 00        	sbc	#0
   676 00:0ADE: 85 42        	sta	count+1
   677 00:0AE0: 05 41        	ora	count		;see if last file
   678 00:0AE2: F0 16        	beq	OKPRNT		;If COUNT=0, last file so skip compare
   679                        ;COMPARE EACH ENTRY TO MAKE SURE THAT IT ISN't part of a multiple
   680                        ;EXTENT FILE. GO ONLY WHEN WE HAVE THE LAST EXTENT OF THE FILE.
   681 00:0AE4: 20 30 0D     	jsr	CKABRT		;Check for abort code from keyboard
   682 00:0AE7: 20 67 0D     	jsr	COMPR		;Does this entry match next one?
   683 00:0AEA: D0 0E        	bne	OKPRNT		;No, print it
   684 00:0AEC: 18           	clc			;bump pointer by 16
   685 00:0AED: A5 6C        	lda	nmepnt
   686 00:0AEF: 69 10        	adc	#16
   687 00:0AF1: 85 6C        	sta	nmepnt
  Sun Mar 14 2021 21:19                                                                                                    Page 12


   688 00:0AF3: 90 02        	bcc	cc004
   689 00:0AF5: E6 6D        	inc	nmepnt+1
   690 00:0AF7: 4C D3 0A     cc004	JMP	ENTRY		;Loop back for next lowest extent
   691                        ;VALID ENTRY OBTAINED - SPIT IT OUT.
   692                        OKPRNT
   693                        ;First do name
   694 00:0AFA: A0 00        	ldy	#0		;start at first byte
   695 00:0AFC: B1 6C        CNAME	lda	(nmepnt),y	;get name char
   696 00:0AFE: 99 9C 0E     	sta	namcpy,y	;save it
   697 00:0B01: C8           	iny
   698 00:0B02: C0 08        	cpy	#8		;see if past end
   699 00:0B04: D0 F6        	bne	cname		;loop if more
   700                        ;now do type
   701 00:0B06: A2 00        	ldx	#0		;use second index for copy
   702 00:0B08: B1 6C        ctype	lda	(nmepnt),y	;get char
   703 00:0B0A: 9D A5 0E     	sta	typcpy,x	;save it
   704 00:0B0D: E8           	inx
   705 00:0B0E: C8           	iny
   706 00:0B0F: C0 0B        	cpy	#11		;see if past end
   707 00:0B11: D0 F5        	bne	ctype		;loop if more
   708                        ;now print
   709 00:0B13: A9 9C        	lda	#<namcpy	;point to name
   710 00:0B15: A0 0E        	ldy	#>namcpy
   711 00:0B17: 20 14 0D     	jsr	msgzer		;print it
   712 00:0B1A: A9 2E        	LDA	#'.'		;Period	after FN
   713 00:0B1C: 20 DB 0C     	jsr	TYPE
   714 00:0B1F: A9 A5        	lda	#<typcpy	;point to type
   715 00:0B21: A0 0E        	ldy	#>typcpy
   716 00:0B23: 20 14 0D     	jsr	msgzer		;print it
   717                        ;COMPUTE THE SIZE OF THE FILE AND UPDATE OUR SUMMARY DATUM.
   718 00:0B26: A0 0B        	ldy	#11		;get extent
   719 00:0B28: B1 6C        	lda	(nmepnt),y
   720 00:0B2A: 85 71        	sta	extent
   721 00:0B2C: A9 00        	lda	#0		;set high to 0
   722 00:0B2E: 85 72        	sta	extent+1
   723 00:0B30: C8           	iny			;point to record count of last extent
   724 00:0B31: B1 6C        	lda	(nmepnt),y	;get it
   725                        ;now convert whole extents to KB
   726 00:0B33: A2 04        	ldx	#4		;multiply by 16
   727 00:0B35: 06 71        extmul	asl	extent
   728 00:0B37: 26 72        	rol	extent+1
   729 00:0B39: CA           	dex
   730 00:0B3A: D0 F9        	bne	extmul		;loop if more
   731                        ;now convert record count to KB
   732 00:0B3C: 86 75        	stx	remain		;clear remainder
   733 00:0B3E: 4A           	lsr	a		;divide by 2
   734 00:0B3F: 66 75        	ror	remain		;set remainder if any
   735 00:0B41: 4A           	lsr	a
   736 00:0B42: 66 75        	ror	remain
   737 00:0B44: 4A           	lsr	a
   738 00:0B45: 66 75        	ror	remain
   739 00:0B47: 29 1F        	and	#%00011111
   740 00:0B49: 18           	clc			;add to existing
   741 00:0B4A: 65 71        	adc	extent
   742 00:0B4C: 85 71        	sta	extent
   743 00:0B4E: 90 02        	bcc	cc005
   744 00:0B50: E6 72        	inc	extent+1
   745 00:0B52: A5 75        cc005	lda	remain		;test remainder
   746 00:0B54: F0 06        	beq	norem		;if none ignore
   747 00:0B56: E6 71        	inc	extent		;else bump by 1K
   748 00:0B58: D0 02        	bne	norem
   749 00:0B5A: E6 72        	inc	extent+1
   750                        norem
  Sun Mar 14 2021 21:19                                                                                                    Page 13


   751                        ;now round up to whole blocks
   752 00:0B5C: A6 5D        	ldx	blkscd		;get DCB parameter
   753 00:0B5E: BD A9 0E     	lda	kblkm,x		;get K/BLK mask
   754 00:0B61: 25 71        	AND	extent		;use as rounding
   755 00:0B63: F0 15        	beq	noblk		;if result 0 size is correct
   756 00:0B65: BD A9 0E     	lda	kblkm,x		;get mask again
   757 00:0B68: 49 FF        	eor	#%11111111	;complement
   758 00:0B6A: 25 71        	and	extent		;clear partial
   759 00:0B6C: 85 71        	sta	extent
   760 00:0B6E: 18           	clc			;add block size to total
   761 00:0B6F: BD AE 0E     	lda	kblk,x
   762 00:0B72: 65 71        	adc	extent
   763 00:0B74: 85 71        	sta	extent		;save
   764 00:0B76: 90 02        	bcc	noblk
   765 00:0B78: E6 72        	inc	extent+1
   766                        ;now add this file size to total
   767 00:0B7A: 18           noblk	clc
   768 00:0B7B: A5 39        	lda	totsiz
   769 00:0B7D: 65 71        	adc	extent
   770 00:0B7F: 85 39        	sta	totsiz
   771 00:0B81: A5 3A        	lda	totsiz+1
   772 00:0B83: 65 72        	adc	extent+1
   773 00:0B85: 85 3A        	sta	totsiz+1
   774                        ;now bump file count
   775 00:0B87: E6 37        	inc	totfil
   776 00:0B89: D0 02        	bne	nz010
   777 00:0B8B: E6 38        	inc	totfil+1
   778                        nz010
   779                        ;IF REPORT SIZE ENABLED, OUTPUT THE SIZE OF THE INDIVIDUAL FILE.
   780                        
   781                        	IF	REPSIZ		;If file size report wanted
   782 00:0B8D: A9 01        	lda	#1		;do not suppress spaces
   783 00:0B8F: 85 36        	sta	supspc
   784 00:0B91: A5 71        	lda	extent		;get file size
   785 00:0B93: A4 72        	ldy	extent+1
   786 00:0B95: 85 3B        	sta	hl		;pass in HL
   787 00:0B97: 84 3C        	sty	hl+1
   788 00:0B99: 20 C9 0B     	jsr	DECPRT		;..go print it
   789 00:0B9C: A9 4B        	LDA	#'K'		;..and follow with K size
   790 00:0B9E: 20 DB 0C     	jsr	TYPE
   791                        	ENDIF
   792                        
   793                        ;ONE FILE OUTPUT - TEST TO SEE IF WE HAVE TO OUTPUT ANOTHER ONE.
   794                        ;but first point to next entry in NAME
   795 00:0BA1: 18           	clc
   796 00:0BA2: A5 6C        	lda	nmepnt
   797 00:0BA4: 69 10        	adc	#16
   798 00:0BA6: 85 6C        	sta	nmepnt
   799 00:0BA8: 90 02        	bcc	cc050
   800 00:0BAA: E6 6D        	inc	nmepnt+1
   801 00:0BAC: A5 41        cc050	lda	count		;test count
   802 00:0BAE: 05 42        	ora	count+1
   803 00:0BB0: D0 03        	bne	nz011
   804 00:0BB2: 4C 2B 0C     	jmp	prtotl		;if no more do summary
   805                        ;AT LEAST ONE MORE FILE TO OUTPUT - CAN WE PUT IT ON THE CURRENT LINE?
   806 00:0BB5: C6 6E        nz011	dec	fldcnt		;drop counter
   807 00:0BB7: F0 06        	beq	newlin		;if zero new line
   808 00:0BB9: 20 D1 0C     	jsr	FENCE		;If room left, output the fence character
   809 00:0BBC: 4C D3 0A     	JMP	ENTRY		;.. and go output another file
   810                        ;CURRENT LINE FULL, START A NEW ONE.
   811 00:0BBF: A9 04        NEWLIN	lda	#NPL		;Reset names per line counter
   812 00:0BC1: 85 6E        	sta	fldcnt		;set counter
   813 00:0BC3: 20 C7 0C     	jsr	CRLF		;Space down to next line
  Sun Mar 14 2021 21:19                                                                                                    Page 14


   814                        
   815                        	IF	NPL<4		;If printing less than 4 wide ..
   816                        	clc
   817                        	LDA	curdrv		;.. precede new line with drive name
   818                        	ADC	#'A'
   819                        	jsr	TYPE
   820                        
   821                        	IF	REPUSR and v3	;If reporting user numbers and running under
   822                        				;V3, output the user number too
   823                        	jsr	TYPUSR
   824                        	ENDIF			;Balance REPUSR and v3
   825                        
   826                        	lda	#':'		;Tag header with a colon and a space
   827                        	jsr	FPAD		;..and exit back to ENTRY
   828                        
   829                        	ENDIF			;Balance NPL GT	3
   830                        
   831 00:0BC6: 4C D3 0A     	jmp	ENTRY		;Go back and output another file
   832                        ;
   833                        ;PRINT HL IN DECIMAL WITH LEADING ZERO SUPPRESSION
   834 00:0BC9: A9 00        DECPRT	lda	#0		;Clear leading zero flag
   835 00:0BCB: 85 53        	sta	LZFLG
   836 00:0BCD: A9 E8        	lda	#<1000
   837 00:0BCF: A0 03        	ldy	#>1000		;do 1000's first
   838 00:0BD1: 20 EA 0B     	jsr	DIGIT
   839 00:0BD4: A9 64        	lda	#<100
   840 00:0BD6: A0 00        	ldy	#>100
   841 00:0BD8: 20 EA 0B     	jsr	DIGIT
   842 00:0BDB: A9 0A        	lda	#<10
   843 00:0BDD: A0 00        	ldy	#>10
   844 00:0BDF: 20 EA 0B     	jsr	DIGIT
   845 00:0BE2: 18           	clc
   846 00:0BE3: A9 30        	LDA	#'0'		;Get 1's digit
   847 00:0BE5: 65 3B        	ADC	hl
   848 00:0BE7: 4C DB 0C     	JMP	TYPE
   849                        ;do decimal digit
   850 00:0BEA: A2 30        DIGIT	LDX	#'0'		;Start off with ASCII 0
   851 00:0BEC: 85 73        	sta	minus		;save modulus
   852 00:0BEE: 84 74        	sty	minus+1
   853 00:0BF0: 38           DIGLP	sec			;subtract
   854 00:0BF1: A5 3B        	lda	hl		;modulus from hl
   855 00:0BF3: E5 73        	sbc	minus
   856 00:0BF5: 85 3B        	sta	hl		;and save
   857 00:0BF7: A5 3C        	lda	hl+1
   858 00:0BF9: E5 74        	sbc	minus+1
   859 00:0BFB: 85 3C        	sta	hl+1
   860 00:0BFD: 90 04        	bcc	digex		;done if borrow
   861 00:0BFF: E8           	INX			;Bump digit
   862 00:0C00: 4C F0 0B     	JMP	DIGLP		;Loop back
   863                        ;at this point HL reflects the last borrow so add modulus back
   864 00:0C03: 18           DIGEX	clc			;add modulus back
   865 00:0C04: A5 3B        	lda	hl
   866 00:0C06: 65 73        	adc	minus
   867 00:0C08: 85 3B        	sta	hl
   868 00:0C0A: A5 3C        	lda	hl+1
   869 00:0C0C: 65 74        	adc	minus+1
   870 00:0C0E: 85 3C        	sta	hl+1
   871 00:0C10: 8A           	txa			;move digit to A
   872 00:0C11: C9 30        	cmp	#'0'		;see if zero
   873 00:0C13: D0 11        	bne	dignz		;go send it
   874                        ;we know digit is a 0 - check if leading 0 or not
   875 00:0C15: A5 53        	LDA	LZFLG		;Leading zero?
   876 00:0C17: F0 05        	beq	notyp0		;if clear do not type
  Sun Mar 14 2021 21:19                                                                                                    Page 15


   877 00:0C19: A9 30        	LDA	#'0'		;else do type
   878 00:0C1B: 4C DB 0C     	JMP	TYPE		;Print digit
   879 00:0C1E: A5 36        notyp0	LDA	SUPSPC		;Get space suppression flag
   880 00:0C20: F0 03        	beq	nospac		;if clear no space
   881 00:0C22: 4C D9 0C     	JMP	SPACE		;Leading zero...print space
   882 00:0C25: 60           nospac	rts
   883                        ;print non-zero digit
   884 00:0C26: 85 53        DIGNZ	sta	LZFLG		;Set leading flag so next zero prints
   885 00:0C28: 4C DB 0C     	JMP	TYPE		;And print digit
   886                        ;
   887                        ;SHOW TOTAL SPACE AND FILES USED
   888 00:0C2B: A9 00        PRTOTL	lda	#0		;suppress leading spaces
   889 00:0C2D: 85 36        	sta	supspc
   890 00:0C2F: A5 37        	lda	totfil		;check total file count
   891 00:0C31: 05 38        	ora	totfil+1
   892 00:0C33: F0 4A        	beq	nxtusr		;skip if nothing found
   893 00:0C35: 8D 98 0E     	sta	fndflg		;set file found flag
   894 00:0C38: A9 57        	lda	#<totms1	;Print [CR,LF,LF]"DRIVE "
   895 00:0C3A: A0 0E        	ldy	#>totms1
   896 00:0C3C: 20 0F 0D     	jsr	MsgOut
   897 00:0C3F: 18           	clc
   898 00:0C40: A5 33        	LDA	curdrv
   899 00:0C42: 69 41        	ADC	#'A'
   900 00:0C44: 20 DB 0C     	jsr	TYPE		;Output	the drive code
   901                        
   902                        	IF	REPUSR and v3
   903 00:0C47: A9 62        	lda	#<TOTMS2	;Print ", USER "
   904 00:0C49: A0 0E        	ldy	#>totms2
   905 00:0C4B: 20 0F 0D     	jsr	MsgOut
   906 00:0C4E: 20 B1 0C     	jsr	TYPUSR		;Output	the user number
   907                        	ENDIF
   908                        
   909 00:0C51: A9 6A        NOUSER	lda	#<totms3	;print "CONTAINS "
   910 00:0C53: A0 0E        	ldy	#>totms3
   911 00:0C55: 20 0F 0D     	jsr	msgout
   912 00:0C58: A5 39        	lda	totsiz		;print total K used by files
   913 00:0C5A: A4 3A        	ldy	totsiz+1
   914 00:0C5C: 85 3B        	sta	hl
   915 00:0C5E: 84 3C        	sty	hl+1
   916 00:0C60: 20 C9 0B     	jsr	decprt
   917 00:0C63: A9 75        	lda	#<totms4	;print "K IN "
   918 00:0C65: A0 0E        	ldy	#>totms4
   919 00:0C67: 20 0F 0D     	jsr	msgout
   920 00:0C6A: A5 37        	lda	totfil		;print total files
   921 00:0C6C: A4 38        	ldy	totfil+1
   922 00:0C6E: 85 3B        	sta	hl
   923 00:0C70: 84 3C        	sty	hl+1
   924 00:0C72: 20 C9 0B     	jsr	DECPRT		;Print number of files matched
   925 00:0C75: A9 7B        	lda	#<TOTMS5	;Print " FILES WITH "
   926 00:0C77: A0 0E        	ldy	#>totms5
   927 00:0C79: 20 0F 0D     	jsr	MsgOut
   928 00:0C7C: 20 55 0D     	jsr	PRTFRE		;Output	free space remaining & " FREE."
   929                        ;DIRECTORY FOR ONE USER AREA COMPLETED. IF ALL USERS OPTION IS
   930                        ;SELECTED, THEN GO DO ANOTHER DIRECTORY ON THE NEXT USER NUMBER
   931                        ;UNTIL WE EXCEED THE MAXIMUM USER # FOR THE SELECTED DRIVE.
   932                        NXTUSR
   933                        	IF	AOPT		;If all users option enabled
   934 00:0C7F: AD 9A 0E     	lda	AOPFLG		;If not all users mode - skip next
   935 00:0C82: D0 0E        	bne	goclz
   936                        
   937                        	if	v3
   938 00:0C84: 20 30 0D     	jsr	CKABRT		;Check for user abort first
   939 00:0C87: A5 54        	lda	MAXUSR		;No abort - get maximum	user number
  Sun Mar 14 2021 21:19                                                                                                    Page 16


   940 00:0C89: E6 31        	inc	newusr		;bump user
   941 00:0C8B: C5 31        	cmp	newusr		;compare max to new
   942 00:0C8D: 90 03        	bcc	cc003		;if borrow at end
   943 00:0C8F: 4C 8F 09     	jmp	settbl		;else use
   944                        cc003
   945                        	endif			;balance v3
   946                        
   947                        	ENDIF			;Balance AOPT
   948                        
   949                        ; WE've finished all of our outputting.
   950                        
   951                        GOCLZ
   952                        
   953                        ;DIRECTORY FOR ALL USER AREAS COMPLETED.
   954 00:0C92: AD 98 0E     NXTDSK	lda	fndflg		;get flag
   955 00:0C95: D0 17        	bne	ndsk		;exit if none
   956 00:0C97: A9 00        	lda	#0		;clear flag
   957 00:0C99: 8D 98 0E     	sta	fndflg
   958 00:0C9C: 18           	clc
   959 00:0C9D: A5 33        	LDA	curdrv		;Stash ASCII drive in NO FILE msg
   960 00:0C9F: 69 41        	ADC	#'A'
   961 00:0CA1: 8D 52 0E     	sta	NOFMS2
   962 00:0CA4: A9 45        	lda	#<NOFMS1	;Print "NO FILE ON ? - "
   963 00:0CA6: A0 0E        	ldy	#>nofms1
   964 00:0CA8: 20 0F 0D     	jsr	MsgOut
   965 00:0CAB: 20 55 0D     	jsr	PRTFRE		;Tag with free message
   966 00:0CAE: 4C 03 0E     NDSK	JMP	EXIT		;All done - exit to CCP
   967                        
   968                        ;PRINT THE USER NUMBER OF THE DIRECTORY IN DECIMAL
   969                        TYPUSR
   970                        	IF	REPUSR
   971 00:0CB1: A5 31        	LDA	NEWUSR
   972 00:0CB3: C9 0A        	CMP	#10		;If user no. > 9 print leading 1
   973 00:0CB5: 90 0A        	bcc	DUX
   974 00:0CB7: A9 31        	LDA	#'1'
   975 00:0CB9: 20 DB 0C     	jsr	TYPE
   976 00:0CBC: 38           	sec
   977 00:0CBD: A5 31        	LDA	NEWUSR		;Print low digit of user no.
   978 00:0CBF: E9 0A        	SBC	#10
   979 00:0CC1: 18           DUX	clc
   980 00:0CC2: 69 30        	ADC	#'0'
   981 00:0CC4: 4C DB 0C     	JMP	TYPE
   982                        	ENDIF
   983                        ;
   984                        ;FORCE NEW LINE ON console
   985 00:0CC7: A9 0D        CRLF	LDA	#cr		;Send CR
   986 00:0CC9: 20 DB 0C     	jsr	TYPE
   987 00:0CCC: A9 0A        	LDA	#lf		;Send LF
   988 00:0CCE: 4C DB 0C     	JMP	TYPE		;Exit to caller from TYPE
   989                        ;
   990                        ;SEPARATE THE DIRECTORY OUTPUT ON A LINE WITH A SPACE, THE DELIMITER,
   991                        ;FOLLOWED BY ANOTHER SPACE.
   992 00:0CD1: 20 D9 0C     FENCE	jsr	SPACE
   993 00:0CD4: A9 7C        	LDA	#DELIM		;Fence character
   994 00:0CD6: 20 DB 0C     FPAD	jsr	TYPE		;Print it, fall into space
   995 00:0CD9: A9 20        SPACE	LDA	#' '		;Fall through to TYPE
   996                        ;OUTPUT CHARACTER IN A TO CONSOLE - and save char as function
   997                        ;of options selected
   998 00:0CDB: 48           TYPE	pha			;Save the character to output
   999 00:0CDC: 20 0A 0D     	jsr	TYPE1		;Send it to console
  1000 00:0CDF: 68           	pla			;Restore the output character
  1001                        ;TEST PAGE PAUSE TEST IF NOT ACTIVE.
  1002 00:0CE0: C9 0A        	cmp	#lf		;see if lf
  Sun Mar 14 2021 21:19                                                                                                    Page 17


  1003 00:0CE2: D0 25        	bne	typret		;done if not
  1004                        
  1005                        	IF	NOPT AND PGPAWZ
  1006 00:0CE4: AD 9B 0E     	LDA	NOPFLG		;Is the page pause function disabled?
  1007 00:0CE7: F0 20        	beq	TYPRET		;Exit if so
  1008                        	ENDIF
  1009                        
  1010                        	IF	PGPAWZ
  1011 00:0CE9: EE 99 0E     	inc	LINCNT		;Get line count
  1012 00:0CEC: AD 99 0E     	lda	lincnt
  1013 00:0CEF: C9 14        	cmp	#lps		;see if at end screen
  1014 00:0CF1: D0 16        	bne	NOTEOS		;Skip if not
  1015 00:0CF3: A9 2D        	lda	#<eosmsg	;Else, display pause message
  1016 00:0CF5: A0 0E        	ldy	#>eosmsg
  1017 00:0CF7: 20 0F 0D     	jsr	msgout
  1018 00:0CFA: 20 2B 0D     	jsr	CINPUT		;Wait for character
  1019 00:0CFD: C9 03        	CMP	#'C'-$40
  1020 00:0CFF: D0 03        	bne	nz013		;continue if not
  1021 00:0D01: 4C 03 0E     	JMP	EXIT		;Abort on CTRL-C
  1022 00:0D04: A9 00        nz013	lda	#0		;reset line count
  1023 00:0D06: 8D 99 0E     	sta	lincnt
  1024                        NOTEOS
  1025                        	ENDIF
  1026                        
  1027 00:0D09: 60           TYPRET	rts			;Exit from TYPE
  1028                        ;
  1029                        ;OUTPUT CHARACTER in A to console
  1030 00:0D0A: A2 02        TYPE1	ldx	#WRCHR
  1031 00:0D0C: 4C 03 01     	jmp	pem		;Call CONOUT via pem
  1032                        ;
  1033                        ;Print $-terminated message on console
  1034                        ;Message start in AY
  1035 00:0D0F: A2 09        MsgOut	ldx	#string
  1036 00:0D11: 4C 03 01     	jmp	pem
  1037                        ;
  1038                        ;Print 0 terminated message on console - start in AY
  1039                        ;at entry.
  1040 00:0D14: 85 78        MsgZer	sta	indx		;save address
  1041 00:0D16: 84 79        	sty	indx+1
  1042 00:0D18: A0 00        MsgZLp	ldy	#0		;clear index
  1043 00:0D1A: B1 78        	lda	(indx),y	;get character
  1044 00:0D1C: F0 0C        	beq	MsgZX		;done if zero
  1045 00:0D1E: 20 DB 0C     	jsr	type		;else send to console
  1046 00:0D21: E6 78        	inc	indx		;bump address
  1047 00:0D23: D0 F3        	bne	MsgZLp		;loop
  1048 00:0D25: E6 79        	inc	indx+1
  1049 00:0D27: 4C 18 0D     	jmp	MsgZLp		;loop
  1050 00:0D2A: 60           MsgZX	rts
  1051                        ;FETCH CHARACTER FROM CONSOLE (WITHOUT ECHO)
  1052 00:0D2B: A2 06        CINPUT	ldx	#noecho		;read input w/o echo
  1053 00:0D2D: 4C 03 01     	jmp	pem
  1054                        ;
  1055                        ;CHECK FOR A CTRL-C ENTERED FROM THE KEYBOARD. JUMP TO
  1056                        ;EXIT IF CTRL-C. System already checks for and handles ctl-s
  1057                        ;and ctl-q for pause and resume.
  1058 00:0D30: A2 0B        CKABRT	ldx	#const		;check console input
  1059 00:0D32: 20 03 01     	jsr	pem
  1060 00:0D35: F0 0C        	beq	eq030		;done if nothing there
  1061 00:0D37: A2 06        	ldx	#noecho		;something there - get
  1062 00:0D39: 20 03 01     	jsr	pem		;without echo
  1063 00:0D3C: C9 03        	cmp	#'C'-$40	;see if ctl-c
  1064 00:0D3E: D0 03        	bne	eq030		;if not ignore
  1065 00:0D40: 4C 03 0E     	jmp	exit		;else exit
  Sun Mar 14 2021 21:19                                                                                                    Page 18


  1066 00:0D43: 60           eq030	rts
  1067                        ;
  1068                        ;RETURN TO OLD USER AREA
  1069                        SETFOP
  1070                        	IF	UOPT OR AOPT
  1071 00:0D44: A5 30        	lda	OLDUSR		;Get user number at start up
  1072 00:0D46: A2 24        	LDX	#CURUSR
  1073                        
  1074                        	if	v3
  1075 00:0D48: 20 03 01     	jsr	pem		;Reset the old user number if V3
  1076                        	endif
  1077                        
  1078                        	ENDIF
  1079                        
  1080 00:0D4B: 60           	rts
  1081                        ;
  1082                        ;MOVE DISK BUFFER DMA TO DEFAULT BUFFER FOR DIRECTORY SEARCH OPERATIONS
  1083                        ;AND BDOS MEDIA CHANGE ROUTINES.
  1084 00:0D4C: A9 28        SETSRC	lda	#<DflBuf	;point to default
  1085 00:0D4E: A0 01        	ldy	#>DflBuf
  1086 00:0D50: A2 1A        	ldx	#SETDMA
  1087 00:0D52: 4C 03 01     	jmp	pem
  1088                        ;
  1089                        ;PRINT THE AMOUNT OF FREE SPACE REMAINING ON THE SELECTED DRIVE
  1090 00:0D55: A5 45        PRTFRE	lda	FreeBy		;get space
  1091 00:0D57: A4 46        	ldy	FreeBy+1
  1092 00:0D59: 85 3B        	sta	hl
  1093 00:0D5B: 84 3C        	sty	hl+1
  1094 00:0D5D: 20 C9 0B     	jsr	DECPRT		;Print K free
  1095 00:0D60: A9 88        	lda	#<totms6	;point to message
  1096 00:0D62: A0 0E        	ldy	#>totms6	;Print " FREE."
  1097 00:0D64: 4C 0F 0D     	JMP	MsgOut
  1098                        ;
  1099                        ;ROUTINE used to compact tables. This
  1100                        ;routine assumes SORT puts the extents for a given
  1101                        ;file in order such that the last extent will be
  1102                        ;the last entry matching the name and type fields.
  1103                        ;NEXTT is the pointer to the NAME entry.
  1104                        ;At exit EQ (z=1) will be set if a match - NE (z=0)
  1105                        ;will be set if not a match.
  1106 00:0D67: A5 6C        compr	lda	nmepnt		;copy pointer
  1107 00:0D69: A4 6D        	ldy	nmepnt+1
  1108 00:0D6B: 85 55        	sta	nextt		;set second pointer
  1109 00:0D6D: 84 56        	sty	nextt+1
  1110                        ;now increase nextt to point to next entry
  1111 00:0D6F: 18           	clc
  1112 00:0D70: A5 55        	lda	nextt		;bump by 2
  1113 00:0D72: 69 10        	adc	#16
  1114 00:0D74: 85 55        	sta	nextt
  1115 00:0D76: 90 02        	bcc	cc006
  1116 00:0D78: E6 56        	inc	nextt+1
  1117 00:0D7A: A0 00        cc006	ldy	#0		;set index too start
  1118 00:0D7C: A2 0B        	ldx	#11		;compare 11
  1119 00:0D7E: B1 6C        comprlp	lda	(nmepnt),y	;get first
  1120 00:0D80: D1 55        	cmp	(nextt),y	;do compare
  1121 00:0D82: D0 04        	bne	nz009		;exit if mismatch
  1122 00:0D84: C8           	iny
  1123 00:0D85: CA           	dex			;drop count
  1124 00:0D86: D0 F6        	bne	comprlp		;loop if more
  1125 00:0D88: 60           nz009	rts
  1126                        ;
  1127                        ;SWAP ENTRIES IN THE NAME TABLE. Note that COMPARE calculates
  1128                        ;and saves the pointers JPNT and JGPNT and nothing changes them
  Sun Mar 14 2021 21:19                                                                                                    Page 19


  1129                        ;between COMPARE and call to SWAP.
  1130 00:0D89: A2 0D        SWAP	ldx	#13		;only 13 valid bytes
  1131 00:0D8B: A0 00        	ldy	#0
  1132 00:0D8D: B1 4D        swaplp	lda	(jpnt),y	;get low of j
  1133 00:0D8F: 85 6B        	sta	byttmp		;save
  1134 00:0D91: B1 51        	lda	(jgpnt),y	;get low of JG
  1135 00:0D93: 91 4D        	sta	(jpnt),y	;swap into j
  1136 00:0D95: A5 6B        	lda	byttmp		;now swap into jg
  1137 00:0D97: 91 51        	sta	(jgpnt),y
  1138 00:0D99: C8           	iny
  1139 00:0D9A: CA           	dex
  1140 00:0D9B: D0 F0        	bne	swaplp		;loop if more
  1141 00:0D9D: 60           	rts
  1142                        ;
  1143                        ;This is the compare routine for the Shell sort.
  1144                        ;Compare A(J) with A(JG) and return with CS if
  1145                        ;A(J) > A(JG) and hence swap required. If CC
  1146                        ;then A(J) <= A(JG) and no swap required.
  1147                        COMPARE
  1148                        ;First  translate simple counts in J and JG to pointers
  1149                        ;to the NAME table.
  1150                        ;Do JPnt first
  1151 00:0D9E: A5 4B        	lda	j
  1152 00:0DA0: A4 4C        	ldy	j+1
  1153 00:0DA2: 85 4D        	sta	jpnt		;copy to pointer
  1154 00:0DA4: 84 4E        	sty	jpnt+1		;now do 16x
  1155 00:0DA6: A2 04        	ldx	#4
  1156 00:0DA8: 06 4D        jx16	asl	jpnt
  1157 00:0DAA: 26 4E        	rol	jpnt+1
  1158 00:0DAC: CA           	dex
  1159 00:0DAD: D0 F9        	bne	jx16
  1160                        ;name-16 is used to change start from 1 to 0
  1161 00:0DAF: 18           	clc			;now add table start
  1162 00:0DB0: A5 4D        	lda	jpnt
  1163 00:0DB2: 69 A3        	adc	#(name-16)*256/256	;use actual start
  1164 00:0DB4: 85 4D        	sta	jpnt
  1165 00:0DB6: A5 4E        	lda	jpnt+1
  1166 00:0DB8: 69 0E        	adc	#(name-16)/256
  1167 00:0DBA: 85 4E        	sta	jpnt+1
  1168                        ;now do jgpnt
  1169 00:0DBC: A5 4F        	lda	jg
  1170 00:0DBE: A4 50        	ldy	jg+1
  1171 00:0DC0: 85 51        	sta	jgpnt		;copy to pointer
  1172 00:0DC2: 84 52        	sty	jgpnt+1		;now do 16x
  1173 00:0DC4: A2 04        	ldx	#4
  1174 00:0DC6: 06 51        jgx16	asl	jgpnt
  1175 00:0DC8: 26 52        	rol	jgpnt+1
  1176 00:0DCA: CA           	dex
  1177 00:0DCB: D0 F9        	bne	jgx16
  1178 00:0DCD: 18           	clc			;now add table start
  1179 00:0DCE: A5 51        	lda	jgpnt
  1180 00:0DD0: 69 A3        	adc	#(name-16)*256/256	;use actual start
  1181 00:0DD2: 85 51        	sta	jgpnt
  1182 00:0DD4: A5 52        	lda	jgpnt+1
  1183 00:0DD6: 69 0E        	adc	#(name-16)/256
  1184 00:0DD8: 85 52        	sta	jgpnt+1
  1185                        ;At this point jpnt and jgpnt point to the start of an entry in NAME
  1186 00:0DDA: A2 0C        	ldx	#12		;compare first 12
  1187 00:0DDC: A0 00        	ldy	#0		;get index ready
  1188 00:0DDE: B1 4D        cmplpe	lda	(jpnt),y	;get a(J)
  1189 00:0DE0: D1 51        	cmp	(jgpnt),y	;compare a(jg)
  1190 00:0DE2: D0 06        	bne	nz030		;done if not same
  1191 00:0DE4: C8           	iny			;next byte
  Sun Mar 14 2021 21:19                                                                                                    Page 20


  1192 00:0DE5: CA           	dex			;drop counter
  1193 00:0DE6: D0 F6        	bne	cmplpe
  1194                        ;At this point all bytes tested and are equal so
  1195                        ;clear carry and return.
  1196 00:0DE8: 18           	clc
  1197 00:0DE9: 60           	rts
  1198                        ;at this point we know there is a difference so they
  1199                        ;can not be equal. That means that a(j) must be greater
  1200                        ;if C set (no borrow) or smaller if C clear (borrow). If A(j) is
  1201                        ;smaller then no swap is required so just return. In the
  1202                        ;same path if C is set (no borrow) then swap is required
  1203                        ;so just return.
  1204 00:0DEA: 60           nz030	rts			;exit
  1205                        ;
  1206                        ;ERROR EXIT
  1207 00:0DEB: 85 6F        ERXIT	sta	msgsav		;save message address
  1208 00:0DED: 84 70        	sty	msgsav+1
  1209 00:0DEF: 20 C7 0C     	jsr	CRLF		;Space down
  1210 00:0DF2: A5 6F        	lda	msgsav		;get message pointer
  1211 00:0DF4: A4 70        	ldy	msgsav+1
  1212 00:0DF6: 20 0F 0D     	jsr	msgout		;Print it
  1213 00:0DF9: A9 3A        	lda	#<errms1	;print ERROR
  1214 00:0DFB: A0 0E        	ldy	#>errms1
  1215 00:0DFD: 20 0F 0D     	jsr	msgout
  1216 00:0E00: 20 C7 0C     	jsr	CRLF		;Space down fall into exit
  1217                        ;
  1218                        ;EXIT - ALL DONE
  1219 00:0E03: A2 0B        EXIT	ldx	#CONST		;Check console status
  1220 00:0E05: 20 03 01     	jsr	pem
  1221 00:0E08: F0 05        	beq	L001		;Char waiting?
  1222 00:0E0A: A2 01        	ldx	#RDCHR
  1223 00:0E0C: 20 03 01     	jsr	pem		;Gobble	up char
  1224 00:0E0F: 60           L001	rts
  1225                        ;
  1226                        ;**********************
  1227                        ;		      *
  1228                        ; END OF PROGRAM CODE *
  1229                        ;		      *
  1230                        ;**********************
  1231                        
  1232                        ; INITIALIZED DATA AREA
  1233                        ;messages
  1234 00:0E10: 44 4F 53 2F  opnmsg	defb	'DOS/65 SUPER DIRECTORY V1.03$'
       00:0E14: 36 35 20 53 
       00:0E18: 55 50 45 52 
       00:0E1C: 20 44 49 52 
       00:0E20: 45 43 54 4F 
       00:0E24: 52 59 20 56 
       00:0E28: 31 2E 30 33 
       00:0E2C: 24 
  1235                        
  1236                        	IF	PGPAWZ
  1237 00:0E2D: 0A 5B 20 4D  EOSMSG	DEFB	lf,'[ More ]',cr,lf,lf,'$'
       00:0E31: 6F 72 65 20 
       00:0E35: 5D 0D 0A 0A 
       00:0E39: 24 
  1238                        	ENDIF
  1239                        
  1240 00:0E3A: 20           ERRMS1	DEFB	' '
  1241 00:0E3B: 45 52 52 4F  ERRMS2	DEFB	'ERROR$'
       00:0E3F: 52 24 
  1242                        
  1243                        	IF	REPERR
  Sun Mar 14 2021 21:19                                                                                                    Page 21


  1244 00:0E41: 20 2D 3E 24  ERRTAG	DEFB	' ->$'
  1245                        	ENDIF
  1246                        
  1247 00:0E45: 0D 0A 4E 4F  NOFMS1	DEFB	cr,lf,'NO FILE ON '
       00:0E49: 20 46 49 4C 
       00:0E4D: 45 20 4F 4E 
       00:0E51: 20 
  1248 00:0E52: 20 20 2D 20  NOFMS2	DEFB	'  - $'
       00:0E56: 24 
  1249                        
  1250 00:0E57: 0D 0A 0D 0A  TOTMS1	DEFB	cr,lf,cr,lf,'DRIVE $'
       00:0E5B: 44 52 49 56 
       00:0E5F: 45 20 24 
  1251                        
  1252                        	IF	REPUSR
  1253 00:0E62: 2C 20 55 53  TOTMS2	DEFB	', USER $'
       00:0E66: 45 52 20 24 
  1254                        	ENDIF
  1255                        
  1256 00:0E6A: 20 43 4F 4E  TOTMS3	DEFB	' CONTAINS $'
       00:0E6E: 54 41 49 4E 
       00:0E72: 53 20 24 
  1257 00:0E75: 4B 20 49 4E  TOTMS4	DEFB	'K IN $'
       00:0E79: 20 24 
  1258 00:0E7B: 20 46 49 4C  TOTMS5	DEFB	' FILES WITH $'
       00:0E7F: 45 53 20 57 
       00:0E83: 49 54 48 20 
       00:0E87: 24 
  1259 00:0E88: 4B 20 46 52  TOTMS6	DEFB	'K FREE',cr,lf,'$'
       00:0E8C: 45 45 0D 0A 
       00:0E90: 24 
  1260 00:0E91: 55 53 45 52  USRMSG	DEFB	'USER #$'
       00:0E95: 20 23 24 
  1261                        
  1262 00:0E98: 00           FNDFLG	DEFB	0		;Flag whether any files matched
  1263                        
  1264                        	IF	PGPAWZ
  1265 00:0E99: 00           LINCNT	DEFB	0		;Count of lines printed	on screen
  1266                        	ENDIF
  1267                        ;
  1268                        ;OPTION FIELD LOOKUP TABLE.
  1269                        ;NOTE THAT YOU CAN FORCE ANY OF THESE OPTIONS AS A DEFAULT BY
  1270                        ;CHANGING THE LETTER FOR THE OPTION INTO A ZERO (ASSUMING THAT
  1271                        ;ITS ENABLING EQUATE IS TRUE). EACH OPTION THAT YOU HARD-WIRE IN
  1272                        ;THIS MANNER WILL NO LONGER BE RECOGNIZED AS A COMMAND LINE OPTION,
  1273                        ;AND IF YOU REDUNDANTLY KEY IT IN, SD WILL FLAG IT AS UNRECOGNIZED.
  1274             00000E9A   OTBL	EQU	*		;Mark start of option table
  1275                        
  1276                        	IF	AOPT		;All users-option flag
  1277 00:0E9A: 41           AOPFLG	DEFB	'A'
  1278                        	ENDIF
  1279                        
  1280                        	IF	NOPT AND PGPAWZ	;No page-pause option flag
  1281 00:0E9B: 4E           NOPFLG	DEFB	'N'
  1282                        	ENDIF
  1283                        
  1284             00000E9C   OEND	EQU	*		;Mark end of option table
  1285                        
  1286                        ;END OF OPTION LOOKUP TABLE
  1287                        ;Locations to store printing copy of name and type fields
  1288 00:0E9C: 20 20 20 20  namcpy	defb	'        ',0
       00:0EA0: 20 20 20 20 
       00:0EA4: 00 
  Sun Mar 14 2021 21:19                                                                                                    Page 22


  1289 00:0EA5: 20 20 20 00  typcpy	defb	'   ',0
  1290                        ;table of mask for KB per block - use BLKSCD to index
  1291 00:0EA9: 00 01 03 07  kblkm	defb	0,1,3,7,15
       00:0EAD: 0F 
  1292                        ;table of K to add for partial block
  1293 00:0EAE: 00 02 04 08  kblk	defb	0,2,4,8,16
       00:0EB2: 10 
  1294                        ;
  1295                        ;UNINITIALIZED DATA AREA
  1296                        ;This area consists of one table - NAME. When SORT is
  1297                        ;executed, the entire value used for the comparison is the first 12 bytes
  1298                        ;entry in NAME containing:
  1299                        ;	name - 8 bytes
  1300                        ;	type - 3 bytes
  1301                        ;	extent - 1 byte
  1302                        ;	records - 1 byte
  1303                        ;	dummy - 3 bytes
  1304                        ;as extracted from each 32 byte directory entry.
  1305                        ;NAME
  1306                        ;	NAME	fixed start of table
  1307                        ;	nmepnt	word pointer used during table set up
  1308                        ;	NEXTT	word pointer to next table entry
  1309                        ;	COUNT	word showing number of actual table entries
  1310                        ;	COUNTS	word holding saved value of COUNT
  1311                        ;	SCOUNT	word showing number entries to sort
  1312                        ;
  1313             00000EB3   NAME	EQU	*		;name table starts here
  1314                        	ends
  1315                        	end


      Lines assembled: 1315
      Errors: 0
